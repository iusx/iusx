[{"data":1,"prerenderedAt":922},["Reactive",2],{"content-query-oWUEheo9Hm":3},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":7,"director":9,"time":10,"img":11,"plan":12,"target":13,"current":14,"progress":15,"barClass":7,"displayType":16,"body":17,"_type":917,"_id":918,"_source":919,"_file":920,"_extension":921},"/plan/security/cve-learn","security",false,"","CVE learn","My","2025","14/1.png","100,100",100,1,0,"percent",{"type":18,"children":19,"toc":910},"root",[20],{"type":21,"tag":22,"props":23,"children":28},"element","book-content",{":by":24,":img":25,":plan":26,":title":27},"director","img","plan","title",[29,34,41,46,51,56,61,65,72,79,92,135,149,161,183,186,192,208,230,267,291,313,329,337,345,357,365,386,394,397,403,414,434,461,466,487,535,556,561,579,592,620,625,628,634,658,710,762,782,805,815,843,851,856,864,877,885],{"type":21,"tag":30,"props":31,"children":33},"text-title",{":t":32},"CVE is my dream.",[],{"type":21,"tag":35,"props":36,"children":37},"p",{},[38],{"type":39,"value":40},"text","早在我上小学时，就觉得 CVE 很帅。步入初中时，在初三那年我拿到了广东电信 IPTV 的通用漏洞。步入社会时，我拿到了 Github 的 Bug bounty。但我始终没有去拿一个 CVE 的编号。因为水是可以水的，但我已经水了 CNVD 和 Hackerone，我希望我的第一个 CVE 编号可以是不那么水的，有一点含金量的。",{"type":21,"tag":35,"props":42,"children":43},{},[44],{"type":39,"value":45},"虽然我并不是 Security 行业或领域的从业人员，只是一个爱好者。但我一直觉得 Security 很帅。同样的，虽然我不是 Design 行业的从业人员，但我觉得可以让自己做出来的 project 会好看，有个性。",{"type":21,"tag":35,"props":47,"children":48},{},[49],{"type":39,"value":50},"我并不是一个专精的人。很多时候我每项感兴趣的领域单拎出来都会被降维打击。虽然我单项领域无法媲美专业的从业者，但我感兴趣的领域都有点建树和作品。将 Security、Design、Animation、Computer 合在一起，与之能媲美的人可能会少那么一点。",{"type":21,"tag":35,"props":52,"children":53},{},[54],{"type":39,"value":55},"而现在，我只有 Design 的代表作，而 Security、Animation、Computer 还没有一个能拿得出手的作品。因此我希望会在未来三年，尽可能的补全这些我感兴趣领域的代表作。可能因为 Work 比较闲的缘故，我的时间总会多那么一点来放到我感兴趣的领域上。即使达不到也没有关系，至少也是努力过了，无论如何三年后的自己总会比现在的自己稍微厉害那么一点点。",{"type":21,"tag":35,"props":57,"children":58},{},[59],{"type":39,"value":60},"因此这个页面会记录一些我感兴趣的 CVE 和 CWE 的编号来让我学习，可能会获取到一些新的思路和对某个方面的理解。来帮助我实现这个目标，顺便看看冷门的 CWE 方向，毕竟 OWASP TOP 10 个人没有太大的兴趣。",{"type":21,"tag":62,"props":63,"children":64},"hr",{},[],{"type":21,"tag":66,"props":67,"children":69},"h1",{"id":68},"rust-3",[70],{"type":39,"value":71},"rust 3",{"type":21,"tag":73,"props":74,"children":76},"h2",{"id":75},"cve-2022-36114-1",[77],{"type":39,"value":78},"CVE-2022-36114 1",{"type":21,"tag":80,"props":81,"children":86},"cve-info",{":type":82,"cve":83,"to":84,":cwe":85},"2","CVE-2022-36114","https://nvd.nist.gov/vuln/detail/CVE-2022-36114","400",[87],{"type":21,"tag":35,"props":88,"children":89},{},[90],{"type":39,"value":91},"不受控制的资源消耗",{"type":21,"tag":35,"props":93,"children":94},{},[95,97,106,108,115,117,124,126,133],{"type":39,"value":96},"利用 Cargo 的 ",{"type":21,"tag":98,"props":99,"children":103},"a",{"href":100,"rel":101},"https://doc.rust-lang.org/cargo/reference/build-scripts.html",[102],"nofollow",[104],{"type":39,"value":105},"build script",{"type":39,"value":107}," 在构建阶段编译第三方的非 Rust code，同时结合 ",{"type":21,"tag":98,"props":109,"children":112},{"href":110,"rel":111},"https://doc.rust-lang.org/book/ch20-05-macros.html#how-to-write-a-custom-derive-macro",[102],[113],{"type":39,"value":114},"procedural macros",{"type":39,"value":116},"，在执行 ",{"type":21,"tag":118,"props":119,"children":121},"code",{"className":120},[],[122],{"type":39,"value":123},"cargo run",{"type":39,"value":125}," 的过程中触发了一个 ",{"type":21,"tag":98,"props":127,"children":130},{"href":128,"rel":129},"https://en.wikipedia.org/wiki/Zip_bomb",[102],[131],{"type":39,"value":132},"Zip Bomb",{"type":39,"value":134}," 行为。",{"type":21,"tag":35,"props":136,"children":137},{},[138,140,147],{"type":39,"value":139},"对于这个问题的修复，rust-lang 已经给出了一个 ",{"type":21,"tag":98,"props":141,"children":144},{"href":142,"rel":143},"https://github.com/rust-lang/wg-security-response/blob/4bbe734e6404ece6f4e85027564f8995d4ab70e0/patches/CVE-2022-36114/0001-CVE-2022-36114-limit-the-maximum-unpacked-size-of-a-.patch",[102],[145],{"type":39,"value":146},"补丁修复",{"type":39,"value":148}," Zip_bomb 的问题:",{"type":21,"tag":150,"props":151,"children":156},"pre",{"code":152,"language":153,"meta":7,"className":154},"// 在解压 .crate 文件（tar.gz）时，限制最多只能解压出 512MB 的内容。\n+const MAX_UNPACK_SIZE: u64 = 512 * 1024 * 1024;\n","c",[155],"language-c",[157],{"type":21,"tag":118,"props":158,"children":159},{"__ignoreMap":7},[160],{"type":39,"value":152},{"type":21,"tag":35,"props":162,"children":163},{},[164,166,172,174,181],{"type":39,"value":165},"同时引入了 ",{"type":21,"tag":118,"props":167,"children":169},{"className":168},[],[170],{"type":39,"value":171},"LimitErrorReader",{"type":39,"value":173},": 超过就抛出错误，避免资源被耗尽（比如磁盘写爆）。除此之外并没有对 macros、build 加以限制，只是建议尽可能的用 ",{"type":21,"tag":98,"props":175,"children":178},{"href":176,"rel":177},"https://crates.io/",[102],[179],{"type":39,"value":180},"crates",{"type":39,"value":182}," 上提交的 crate。",{"type":21,"tag":62,"props":184,"children":185},{},[],{"type":21,"tag":73,"props":187,"children":189},{"id":188},"cve-2023-40030-1",[190],{"type":39,"value":191},"CVE-2023-40030 1",{"type":21,"tag":80,"props":193,"children":198},{":type":194,"cve":195,"to":196,":cwe":197},"1","CVE-2023-40030","https://nvd.nist.gov/vuln/detail/cve-2023-40030","79",[199],{"type":21,"tag":35,"props":200,"children":201},{},[202,204],{"type":39,"value":203},"{OWASP TOP TEN}: 不恰当的网页生成输入中和 XSS",{"type":21,"tag":205,"props":206,"children":207},"br",{},[],{"type":21,"tag":35,"props":209,"children":210},{},[211,213,219,221,228],{"type":39,"value":212},"看到这篇通告的时候，我就回想起为什么我看 ",{"type":21,"tag":118,"props":214,"children":216},{"className":215},[],[217],{"type":39,"value":218},"cargo build --timings",{"type":39,"value":220}," 的时候肿么没想到会有 CWE-79。",{"type":21,"tag":98,"props":222,"children":225},{"href":223,"rel":224},"https://doc.rust-lang.org/cargo/reference/timings.html",[102],[226],{"type":39,"value":227},"--timings",{"type":39,"value":229}," 是一个生成 build 时间的 html 报告。",{"type":21,"tag":35,"props":231,"children":232},{},[233,235,241,243,249,251,257,259,265],{"type":39,"value":234},"可以通过在 ",{"type":21,"tag":118,"props":236,"children":238},{"className":237},[],[239],{"type":39,"value":240},"Cargo.toml",{"type":39,"value":242}," 中加入 ",{"type":21,"tag":118,"props":244,"children":246},{"className":245},[],[247],{"type":39,"value":248},"features = [\"\u003Cimg src='' onerror=alert(0)\"]",{"type":39,"value":250}," 来触发一个 CWE-79, 因此对这个问题的修复就是，将之前的 ",{"type":21,"tag":118,"props":252,"children":254},{"className":253},[],[255],{"type":39,"value":256},"Warning",{"type":39,"value":258},", 换成了 ",{"type":21,"tag":118,"props":260,"children":262},{"className":261},[],[263],{"type":39,"value":264},"bail!",{"type":39,"value":266}," 机制。",{"type":21,"tag":268,"props":269,"children":271},"text-space",{"type":270},"tip",[272],{"type":21,"tag":35,"props":273,"children":274},{},[275,280,282,289],{"type":21,"tag":118,"props":276,"children":278},{"className":277},[],[279],{"type":39,"value":264},{"type":39,"value":281}," 宏来自 ",{"type":21,"tag":98,"props":283,"children":286},{"href":284,"rel":285},"https://docs.rs/anyhow/latest/anyhow/macro.bail.html",[102],[287],{"type":39,"value":288},"anyhow",{"type":39,"value":290}," 用于方便地提前返回错误。",{"type":21,"tag":35,"props":292,"children":293},{},[294,296,303,305,311],{"type":39,"value":295},"可以看一下 ",{"type":21,"tag":98,"props":297,"children":300},{"href":298,"rel":299},"https://github.com/rust-lang/cargo/commit/9835622853f08be9a4b58ebe29dcec8f43b64b33#diff-99a8f4b284589e7db1aec698aa8f9ef9390f3ee3ecddc399dd6be1aa9ee00388L440-L446",[102],[301],{"type":39,"value":302},"fix pr",{"type":39,"value":304},"，非常有意思，比如 ",{"type":21,"tag":118,"props":306,"children":308},{"className":307},[],[309],{"type":39,"value":310},"validate_feature_name",{"type":39,"value":312}," 函数。",{"type":21,"tag":35,"props":314,"children":315},{},[316,318,324,326],{"type":39,"value":317},"原来：遇到非法 feature name，只输出 ",{"type":21,"tag":118,"props":319,"children":321},{"className":320},[],[322],{"type":39,"value":323},"warning",{"type":39,"value":325},"，流程继续。",{"type":21,"tag":205,"props":327,"children":328},{},[],{"type":21,"tag":150,"props":330,"children":332},{"code":331},"if let Some(ch) = chars.next() {Add commentMore actions\n        if !(unicode_xid::UnicodeXID::is_xid_start(ch) || ch == '_' || ch.is_digit(10)) {\n            config.shell().warn(&format!(\n                \"invalid character `{}` in feature `{}` in package {}, \\\n                the first character must be a Unicode XID start character or digit \\\n                (most letters or `_` or `0` to `9`)\\n\\\n                {}\",\n                ch, name, pkg_id, FUTURE\n            ))?;\n\n        }\n    }\n",[333],{"type":21,"tag":118,"props":334,"children":335},{"__ignoreMap":7},[336],{"type":39,"value":331},{"type":21,"tag":268,"props":338,"children":339},{"type":270},[340],{"type":21,"tag":35,"props":341,"children":342},{},[343],{"type":39,"value":344},"我本来想看看 2025-6-27 的 src/cargo/core/summary.rs 这个 fix pr 的区别。但我发现了一个流量密码，那就是 Rc → Arc, 问就是 Thread Safety！",{"type":21,"tag":35,"props":346,"children":347},{},[348,350,355],{"type":39,"value":349},"现在：遇到非法 feature name，直接 ",{"type":21,"tag":118,"props":351,"children":353},{"className":352},[],[354],{"type":39,"value":264},{"type":39,"value":356},"，构建中止，用户必须修正。",{"type":21,"tag":150,"props":358,"children":360},{"code":359}," if let Some(ch) = chars.next() {Add commentMore actions\n        if !(unicode_xid::UnicodeXID::is_xid_start(ch) || ch == '_' || ch.is_digit(10)) {\n            bail!(\n                \"invalid character `{}` in feature `{}` in package {}, \\\n                the first character must be a Unicode XID start character or digit \\\n                (most letters or `_` or `0` to `9`)\",\n                ch,\n                name,\n                pkg_id\n            );\n        }\n    }\n",[361],{"type":21,"tag":118,"props":362,"children":363},{"__ignoreMap":7},[364],{"type":39,"value":359},{"type":21,"tag":35,"props":366,"children":367},{},[368,370,376,378,384],{"type":39,"value":369},"在单元测试中，来验证 feature name 是否合法，例如只有 ",{"type":21,"tag":118,"props":371,"children":373},{"className":372},[],[374],{"type":39,"value":375},"is_ok()",{"type":39,"value":377}," 是合法的，而 ",{"type":21,"tag":118,"props":379,"children":381},{"className":380},[],[382],{"type":39,"value":383},"is_err()",{"type":39,"value":385}," 是不合法的：",{"type":21,"tag":150,"props":387,"children":389},{"code":388}," #[test]Add commentMore actions\n    fn valid_feature_names() {\n        let loc = CRATES_IO_INDEX.into_url().unwrap();\n        let source_id = SourceId::for_registry(&loc).unwrap();\n        let pkg_id = PackageId::new(\"foo\", \"1.0.0\", source_id).unwrap();\n\n        assert!(validate_feature_name(pkg_id, \"c++17\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"128bit\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"_foo\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"feat-name\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"feat_name\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"foo.bar\").is_ok());\n\n        assert!(validate_feature_name(pkg_id, \"+foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"-foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \".foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"foo:bar\").is_err());\n        assert!(validate_feature_name(pkg_id, \"foo?\").is_err());\n        assert!(validate_feature_name(pkg_id, \"?foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"ⒶⒷⒸ\").is_err());\n        assert!(validate_feature_name(pkg_id, \"a¼\").is_err());\n    }\n",[390],{"type":21,"tag":118,"props":391,"children":392},{"__ignoreMap":7},[393],{"type":39,"value":388},{"type":21,"tag":62,"props":395,"children":396},{},[],{"type":21,"tag":73,"props":398,"children":400},{"id":399},"cve-2023-41051-1",[401],{"type":39,"value":402},"CVE-2023-41051 1",{"type":21,"tag":80,"props":404,"children":408},{":type":194,"cve":405,"to":406,":cwe":407},"CVE-2023-51051","https://nvd.nist.gov/vuln/detail/cve-2023-41051","125",[409],{"type":21,"tag":35,"props":410,"children":411},{},[412],{"type":39,"value":413},"越界访问（out-of-bounds）: 访问了本不属于该内存区域的数据。",{"type":21,"tag":35,"props":415,"children":416},{},[417,424,426,432],{"type":21,"tag":98,"props":418,"children":421},{"href":419,"rel":420},"https://github.com/rust-vmm/vm-memory",[102],[422],{"type":39,"value":423},"vm-memory",{"type":39,"value":425}," 的 ",{"type":21,"tag":118,"props":427,"children":429},{"className":428},[],[430],{"type":39,"value":431},"VolatileMemory",{"type":39,"value":433}," 实现未对边界进行严格校验，导致有可能读取到非法的内存区域：",{"type":21,"tag":435,"props":436,"children":437},"ol",{},[438,450],{"type":21,"tag":439,"props":440,"children":441},"li",{},[442,448],{"type":21,"tag":118,"props":443,"children":445},{"className":444},[],[446],{"type":39,"value":447},"VolatileMemory::get_slice",{"type":39,"value":449},": 返回一段“易失性切片”（VolatileSlice），用于后续的底层操作",{"type":21,"tag":439,"props":451,"children":452},{},[453,459],{"type":21,"tag":118,"props":454,"children":456},{"className":455},[],[457],{"type":39,"value":458},"VolatileMemory::read/write",{"type":39,"value":460},": 直接从这块内存读/写数据，保证每次都实际发生内存访问",{"type":21,"tag":35,"props":462,"children":463},{},[464],{"type":39,"value":465},"VolatileMemory trait 就是定义了一套访问“虚拟机物理内存”或“特殊硬件内存区域”的低层接口，保证每次读写都真实发生，且不被编译器优化。它让不同的底层实现都能用统一的 trait 操作。",{"type":21,"tag":35,"props":467,"children":468},{},[469,471,477,479,485],{"type":39,"value":470},"但问题来了，这个通告并不涉及 ",{"type":21,"tag":118,"props":472,"children":474},{"className":473},[],[475],{"type":39,"value":476},"read/write",{"type":39,"value":478},"，更多的是 ",{"type":21,"tag":118,"props":480,"children":482},{"className":481},[],[483],{"type":39,"value":484},"get_slice",{"type":39,"value":486}," 方法，例如：",{"type":21,"tag":435,"props":488,"children":489},{},[490,499,508,517,526],{"type":21,"tag":439,"props":491,"children":492},{},[493],{"type":21,"tag":118,"props":494,"children":496},{"className":495},[],[497],{"type":39,"value":498},"get_atomic_ref",{"type":21,"tag":439,"props":500,"children":501},{},[502],{"type":21,"tag":118,"props":503,"children":505},{"className":504},[],[506],{"type":39,"value":507},"aligned_as_ref",{"type":21,"tag":439,"props":509,"children":510},{},[511],{"type":21,"tag":118,"props":512,"children":514},{"className":513},[],[515],{"type":39,"value":516},"aligned_as_mut",{"type":21,"tag":439,"props":518,"children":519},{},[520],{"type":21,"tag":118,"props":521,"children":523},{"className":522},[],[524],{"type":39,"value":525},"get_ref",{"type":21,"tag":439,"props":527,"children":528},{},[529],{"type":21,"tag":118,"props":530,"children":532},{"className":531},[],[533],{"type":39,"value":534},"get_array_ref",{"type":21,"tag":35,"props":536,"children":537},{},[538,540,546,548,554],{"type":39,"value":539},"上述方法有个共同点，都是利用 ",{"type":21,"tag":118,"props":541,"children":543},{"className":542},[],[544],{"type":39,"value":545},"ref",{"type":39,"value":547}," 类方法引起的。它们都尝试返回指向底层内存的 Rust 类型引用（如 &T、",{"type":21,"tag":118,"props":549,"children":551},{"className":550},[],[552],{"type":39,"value":553},"&[T]",{"type":39,"value":555}," 等），而不是直接读写原始字节数据。它们的实现通常会调用 get_slice，假设返回的内存区域长度足够大。",{"type":21,"tag":35,"props":557,"children":558},{},[559],{"type":39,"value":560},"如果自定义实现的 get_slice 返回的切片长度不足，就会导致这些 ref 方法产生越界引用，造成内存安全风险。例如：",{"type":21,"tag":435,"props":562,"children":563},{},[564,569,574],{"type":21,"tag":439,"props":565,"children":566},{},[567],{"type":39,"value":568},"这些方法假设 get_slice 返回的 VolatileSlice 长度是你要求的大小（比如 T 是 u32，就要 4 字节）。",{"type":21,"tag":439,"props":570,"children":571},{},[572],{"type":39,"value":573},"如果自定义实现的 get_slice 返回的 VolatileSlice 比你要求的短（比如只返回了2字节）",{"type":21,"tag":439,"props":575,"children":576},{},[577],{"type":39,"value":578},"这些方法还是会照常把这块内存强转成 &T，这时你访问 &T 时就可能会读到超出实际内存范围以外的内容",{"type":21,"tag":35,"props":580,"children":581},{},[582,584,590],{"type":39,"value":583},"仔细欣赏 ",{"type":21,"tag":98,"props":585,"children":588},{"href":586,"rel":587},"https://github.com/rust-vmm/vm-memory/commit/aff1dd4a5259f7deba56692840f7a2d9ca34c9c8#diff-0870facad91de878abbdf4dc43212b8de558021cf0971f62148c2cab381bd150R109-R275",[102],[589],{"type":39,"value":302},{"type":39,"value":591}," 你会发现：",{"type":21,"tag":35,"props":593,"children":594},{},[595,597,603,605,610,612,618],{"type":39,"value":596},"这些方法内部，都会调用 ",{"type":21,"tag":118,"props":598,"children":600},{"className":599},[],[601],{"type":39,"value":602},"get_slice(offset, count)",{"type":39,"value":604}," 拿到一块内存切片，然后把它 reinterpret_cast 成你要的类型引用。因此给 ",{"type":21,"tag":118,"props":606,"children":608},{"className":607},[],[609],{"type":39,"value":484},{"type":39,"value":611}," 加上 ",{"type":21,"tag":118,"props":613,"children":615},{"className":614},[],[616],{"type":39,"value":617},"assert_eq!",{"type":39,"value":619}," 就意味着：",{"type":21,"tag":35,"props":621,"children":622},{},[623],{"type":39,"value":624},"“如果你要 8 字节引用，必须实际拿到 8 字节的内存切片，否则直接 panic，不做 unsafe 操作！”",{"type":21,"tag":62,"props":626,"children":627},{},[],{"type":21,"tag":73,"props":629,"children":631},{"id":630},"cve-2023-38497-1",[632],{"type":39,"value":633},"CVE-2023-38497 1",{"type":21,"tag":80,"props":635,"children":640},{":type":636,"cve":637,"to":638,"cwe":639},"3","CVE-2023-38497","https://nvd.nist.gov/vuln/detail/cve-2023-38497","278,732",[641,649],{"type":21,"tag":35,"props":642,"children":643},{},[644,646],{"type":39,"value":645},"278: 不安全的保留继承权限",{"type":21,"tag":205,"props":647,"children":648},{},[],{"type":21,"tag":650,"props":651,"children":652},"ul",{},[653],{"type":21,"tag":439,"props":654,"children":655},{},[656],{"type":39,"value":657},"732: 关键资源的权限分配错误",{"type":21,"tag":35,"props":659,"children":660},{},[661,663,670,672,678,680,685,687,692,694,700,702,708],{"type":39,"value":662},"CWE-278 还是较为冷门的，毕竟只有一个参考，既 ",{"type":21,"tag":98,"props":664,"children":667},{"href":665,"rel":666},"https://www.cve.org/CVERecord?id=CVE-2005-1724",[102],[668],{"type":39,"value":669},"CVE-2005-1724",{"type":39,"value":671},"。CWE-278 这个类的漏洞常见表现之一就是 ",{"type":21,"tag":673,"props":674,"children":675},"strong",{},[676],{"type":39,"value":677},"权限限制”",{"type":39,"value":679},"。总的来说 umask 是 ",{"type":21,"tag":673,"props":681,"children":682},{},[683],{"type":39,"value":684},"限制新建文件或目录默认权限的一个机制。",{"type":39,"value":686},"，可以看看 ",{"type":21,"tag":688,"props":689,"children":690},"sup",{},[691],{"type":39,"value":194},{"type":39,"value":693},"，我清晰记得有时候需要执行什么 ",{"type":21,"tag":118,"props":695,"children":697},{"className":696},[],[698],{"type":39,"value":699},"bash",{"type":39,"value":701}," 脚本的时候，会使用 ",{"type":21,"tag":118,"props":703,"children":705},{"className":704},[],[706],{"type":39,"value":707},"chmod 777",{"type":39,"value":709},", 要不然运行不了。",{"type":21,"tag":268,"props":711,"children":712},{"type":270},[713,723,728,749,757],{"type":21,"tag":35,"props":714,"children":715},{},[716,718],{"type":39,"value":717},"CVE-2005-1724 是一个典型的“配置安全限制无效”型漏洞，使得 NFS 导出的目录被所有人都能访问，造成权限绕过和潜在的数据泄露/篡改风险。其归类于 CWE-278 ",{"type":21,"tag":673,"props":719,"children":720},{},[721],{"type":39,"value":722},"属于权限/访问控制失效问题。",{"type":21,"tag":35,"props":724,"children":725},{},[726],{"type":39,"value":727},"而 CWE-732 又是 CWE-278 的子类，因此会有两个 CWE 的分配。",{"type":21,"tag":35,"props":729,"children":730},{},[731,733,739,741,747],{"type":39,"value":732},"比如 CVE-2005-1724 在正常情况下，在导出（export）NFS 文件系统时，通常会用 ",{"type":21,"tag":118,"props":734,"children":736},{"className":735},[],[737],{"type":39,"value":738},"-network",{"type":39,"value":740}," 和 ",{"type":21,"tag":118,"props":742,"children":744},{"className":743},[],[745],{"type":39,"value":746},"-mask",{"type":39,"value":748},"：",{"type":21,"tag":150,"props":750,"children":752},{"code":751},"/some/dir -network 192.168.1.0 -mask 255.255.255.0\n",[753],{"type":21,"tag":118,"props":754,"children":755},{"__ignoreMap":7},[756],{"type":39,"value":751},{"type":21,"tag":35,"props":758,"children":759},{},[760],{"type":39,"value":761},"这样本应只有 192.168.1.0/24 网络内的主机可以访问该目录。但在 Mac OS X 10.4.x 的 NFS 服务实现没有正确处理/生效这些参数。因此构成了 CWE-278",{"type":21,"tag":35,"props":763,"children":764},{},[765,767,772,774,780],{"type":39,"value":766},"要想理解本次的 CVE，我们首先需要理解标题 ",{"type":21,"tag":673,"props":768,"children":769},{},[770],{"type":39,"value":771},"Cargo 在解压 crate 包时未按照 umask 限制文件权限",{"type":39,"value":773},"。而 ",{"type":21,"tag":118,"props":775,"children":777},{"className":776},[],[778],{"type":39,"value":779},"umask",{"type":39,"value":781}," 是默认权限，翻译成人话就是：",{"type":21,"tag":783,"props":784,"children":786},"text-tip",{"type":785},"big",[787],{"type":21,"tag":35,"props":788,"children":789},{},[790,792,798,800,803],{"type":39,"value":791},"Cargo 在解压 crate 包时，没有按照 umask 分个默认的权限。攻击者可以利用这一点也就是 ",{"type":21,"tag":118,"props":793,"children":795},{"className":794},[],[796],{"type":39,"value":797},"777",{"type":39,"value":799}," 权限构建攻击脚本。",{"type":21,"tag":205,"props":801,"children":802},{},[],{"type":39,"value":804},"\n↑ 可能不是很严谨",{"type":21,"tag":35,"props":806,"children":807},{},[808,810],{"type":39,"value":809},"过去 Cargo 解压 .crate 包时，直接采用了压缩包内的文件权限（比如 777/666），",{"type":21,"tag":673,"props":811,"children":812},{},[813],{"type":39,"value":814},"没有结合操作系统的 umask，导致解压后的文件权限过宽，其他本地用户可能能写入、篡改这些源码文件。",{"type":21,"tag":35,"props":816,"children":817},{},[818,820,826,828,834,836,841],{"type":39,"value":819},"在 ",{"type":21,"tag":118,"props":821,"children":823},{"className":822},[],[824],{"type":39,"value":825},"src/cargo/util/mod.rs",{"type":39,"value":827}," 中新增了 ",{"type":21,"tag":118,"props":829,"children":831},{"className":830},[],[832],{"type":39,"value":833},"get_umask()",{"type":39,"value":835}," 函数。以在解压文件时，强制用 ",{"type":21,"tag":118,"props":837,"children":839},{"className":838},[],[840],{"type":39,"value":779},{"type":39,"value":842}," 限制新文件的权限。：",{"type":21,"tag":150,"props":844,"children":846},{"code":845},"#[cfg(unix)]\npub fn get_umask() -> u32 {\n    use std::sync::OnceLock;\n    static UMASK: OnceLock\u003Clibc::mode_t> = OnceLock::new();\n    // SAFETY: Syscalls are unsafe. Calling `umask` twice is even unsafer for\n    // multithreading program, since it doesn't provide a way to retrive the\n    // value without modifications. We use a static `OnceLock` here to ensure\n    // it only gets call once during the entire program lifetime.\n    *UMASK.get_or_init(|| unsafe {\n        let umask = libc::umask(0o022);\n        libc::umask(umask);\n        umask\n    }) as u32 // it is u16 on macos\n}\n",[847],{"type":21,"tag":118,"props":848,"children":849},{"__ignoreMap":7},[850],{"type":39,"value":845},{"type":21,"tag":35,"props":852,"children":853},{},[854],{"type":39,"value":855},"以及很有艺术性的一行 code:",{"type":21,"tag":150,"props":857,"children":859},{"code":858},"fs::set_permissions(path, Permissions::from_mode(final_mode)).unwrap();\n",[860],{"type":21,"tag":118,"props":861,"children":862},{"__ignoreMap":7},[863],{"type":39,"value":858},{"type":21,"tag":35,"props":865,"children":866},{},[867,869,875],{"type":39,"value":868},"解压 crate 时，读取每个文件的原始权限（如 0o777），实际写入磁盘时，会用 原始权限 & ",{"type":21,"tag":118,"props":870,"children":872},{"className":871},[],[873],{"type":39,"value":874},"!umask",{"type":39,"value":876}," 得到最终权限，再 chmod 到文件上:",{"type":21,"tag":150,"props":878,"children":880},{"code":879},"assert_eq!(metadata.mode() & 0o777, 0o644 & !umask);\n",[881],{"type":21,"tag":118,"props":882,"children":883},{"__ignoreMap":7},[884],{"type":39,"value":879},{"type":21,"tag":886,"props":887,"children":890},"div",{"id":888,"className":889},"refer-anchor-1",[545],[891],{"type":21,"tag":650,"props":892,"children":893},{},[894],{"type":21,"tag":439,"props":895,"children":896},{},[897,902,904],{"type":21,"tag":898,"props":899,"children":900},"span",{},[901],{"type":39,"value":194},{"type":39,"value":903}," ",{"type":21,"tag":98,"props":905,"children":908},{"href":906,"rel":907},"https://langzi989.github.io/2017/09/13/Linux%E4%B8%ADumash%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/",[102],[909],{"type":39,"value":906},{"title":7,"searchDepth":911,"depth":911,"links":912},2,[913,914,915,916],{"id":75,"depth":911,"text":78},{"id":188,"depth":911,"text":191},{"id":399,"depth":911,"text":402},{"id":630,"depth":911,"text":633},"markdown","content:plan:security:cve-learn.md","content","plan/security/cve-learn.md","md",1755781163323]