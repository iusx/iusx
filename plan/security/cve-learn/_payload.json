[{"data":1,"prerenderedAt":1040},["Reactive",2],{"content-query-oWUEheo9Hm":3},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":7,"director":9,"img":10,"time":11,"plan":12,"target":13,"current":14,"displayType":15,"body":16,"_type":1000,"_id":1001,"_source":1002,"_file":1003,"_extension":1004,"head":1005},"/plan/security/cve-learn","security",false,"","CVE learn","My","14/1.png","2025.06.29","100,100",100,1,"percent",{"type":17,"children":18,"toc":989},"root",[19],{"type":20,"tag":21,"props":22,"children":27},"element","book-content",{":by":23,":img":24,":plan":25,":title":26},"director","img","plan","title",[28,33,40,45,50,55,60,64,71,78,85,98,141,155,167,189,192,198,214,236,273,297,319,335,343,351,363,371,392,400,403,409,420,440,467,472,493,541,562,567,585,598,626,631,634,640,664,718,770,790,813,823,851,859,864,872,885,893,896,902,906,918,975,981],{"type":20,"tag":29,"props":30,"children":32},"text-title",{":t":31},"CVE is my dream.",[],{"type":20,"tag":34,"props":35,"children":36},"p",{},[37],{"type":38,"value":39},"text","早在我上小学时，就觉得 CVE 很帅。步入初中时，在初三那年我拿到了广东电信 IPTV 的通用漏洞。步入社会时，我拿到了 Github 的 Bug bounty。但我始终没有去拿一个 CVE 的编号。因为水是可以水的，但我已经水了 CNVD 和 Hackerone，我希望我的第一个 CVE 编号可以是不那么水的，有一点含金量的。",{"type":20,"tag":34,"props":41,"children":42},{},[43],{"type":38,"value":44},"虽然我并不是 Security 行业或领域的从业人员，只是一个爱好者。但我一直觉得 Security 很帅。同样的，虽然我不是 Design 行业的从业人员，但我觉得可以让自己做出来的 project 会好看，有个性。",{"type":20,"tag":34,"props":46,"children":47},{},[48],{"type":38,"value":49},"我并不是一个专精的人。很多时候我每项感兴趣的领域单拎出来都会被降维打击。虽然我单项领域无法媲美专业的从业者，但我感兴趣的领域都有点建树和作品。将 Security、Design、Animation、Computer 合在一起，与之能媲美的人可能会少那么一点。",{"type":20,"tag":34,"props":51,"children":52},{},[53],{"type":38,"value":54},"而现在，我只有 Design 的代表作，而 Security、Animation、Computer 还没有一个能拿得出手的作品。因此我希望会在未来三年，尽可能的补全这些我感兴趣领域的代表作。可能因为 Work 比较闲的缘故，我的时间总会多那么一点来放到我感兴趣的领域上。即使达不到也没有关系，至少也是努力过了，无论如何三年后的自己总会比现在的自己稍微厉害那么一点点。",{"type":20,"tag":34,"props":56,"children":57},{},[58],{"type":38,"value":59},"因此这个页面会记录一些我感兴趣的 CVE 和 CWE 的编号来让我学习，可能会获取到一些新的思路和对某个方面的理解。来帮助我实现这个目标，顺便看看冷门的 CWE 方向，毕竟 OWASP TOP 10 个人没有太大的兴趣。",{"type":20,"tag":61,"props":62,"children":63},"hr",{},[],{"type":20,"tag":65,"props":66,"children":68},"h1",{"id":67},"rust-3",[69],{"type":38,"value":70},"rust 3",{"type":20,"tag":72,"props":73,"children":75},"h2",{"id":74},"github-3",[76],{"type":38,"value":77},"Github 3",{"type":20,"tag":79,"props":80,"children":82},"h3",{"id":81},"cve-2022-36114-1",[83],{"type":38,"value":84},"CVE-2022-36114 1",{"type":20,"tag":86,"props":87,"children":92},"cve-info",{":type":88,"cve":89,"to":90,":cwe":91},"2","CVE-2022-36114","https://nvd.nist.gov/vuln/detail/CVE-2022-36114","400",[93],{"type":20,"tag":34,"props":94,"children":95},{},[96],{"type":38,"value":97},"不受控制的资源消耗",{"type":20,"tag":34,"props":99,"children":100},{},[101,103,112,114,121,123,130,132,139],{"type":38,"value":102},"利用 Cargo 的 ",{"type":20,"tag":104,"props":105,"children":109},"a",{"href":106,"rel":107},"https://doc.rust-lang.org/cargo/reference/build-scripts.html",[108],"nofollow",[110],{"type":38,"value":111},"build script",{"type":38,"value":113}," 在构建阶段编译第三方的非 Rust code，同时结合 ",{"type":20,"tag":104,"props":115,"children":118},{"href":116,"rel":117},"https://doc.rust-lang.org/book/ch20-05-macros.html#how-to-write-a-custom-derive-macro",[108],[119],{"type":38,"value":120},"procedural macros",{"type":38,"value":122},"，在执行 ",{"type":20,"tag":124,"props":125,"children":127},"code",{"className":126},[],[128],{"type":38,"value":129},"cargo run",{"type":38,"value":131}," 的过程中触发了一个 ",{"type":20,"tag":104,"props":133,"children":136},{"href":134,"rel":135},"https://en.wikipedia.org/wiki/Zip_bomb",[108],[137],{"type":38,"value":138},"Zip Bomb",{"type":38,"value":140}," 行为。",{"type":20,"tag":34,"props":142,"children":143},{},[144,146,153],{"type":38,"value":145},"对于这个问题的修复，rust-lang 已经给出了一个 ",{"type":20,"tag":104,"props":147,"children":150},{"href":148,"rel":149},"https://github.com/rust-lang/wg-security-response/blob/4bbe734e6404ece6f4e85027564f8995d4ab70e0/patches/CVE-2022-36114/0001-CVE-2022-36114-limit-the-maximum-unpacked-size-of-a-.patch",[108],[151],{"type":38,"value":152},"补丁修复",{"type":38,"value":154}," Zip_bomb 的问题:",{"type":20,"tag":156,"props":157,"children":162},"pre",{"code":158,"language":159,"meta":7,"className":160},"// 在解压 .crate 文件（tar.gz）时，限制最多只能解压出 512MB 的内容。\n+const MAX_UNPACK_SIZE: u64 = 512 * 1024 * 1024;\n","c",[161],"language-c",[163],{"type":20,"tag":124,"props":164,"children":165},{"__ignoreMap":7},[166],{"type":38,"value":158},{"type":20,"tag":34,"props":168,"children":169},{},[170,172,178,180,187],{"type":38,"value":171},"同时引入了 ",{"type":20,"tag":124,"props":173,"children":175},{"className":174},[],[176],{"type":38,"value":177},"LimitErrorReader",{"type":38,"value":179},": 超过就抛出错误，避免资源被耗尽（比如磁盘写爆）。除此之外并没有对 macros、build 加以限制，只是建议尽可能的用 ",{"type":20,"tag":104,"props":181,"children":184},{"href":182,"rel":183},"https://crates.io/",[108],[185],{"type":38,"value":186},"crates",{"type":38,"value":188}," 上提交的 crate。",{"type":20,"tag":61,"props":190,"children":191},{},[],{"type":20,"tag":79,"props":193,"children":195},{"id":194},"cve-2023-40030-1",[196],{"type":38,"value":197},"CVE-2023-40030 1",{"type":20,"tag":86,"props":199,"children":204},{":type":200,"cve":201,"to":202,":cwe":203},"1","CVE-2023-40030","https://nvd.nist.gov/vuln/detail/cve-2023-40030","79",[205],{"type":20,"tag":34,"props":206,"children":207},{},[208,210],{"type":38,"value":209},"{OWASP TOP TEN}: 不恰当的网页生成输入中和 XSS",{"type":20,"tag":211,"props":212,"children":213},"br",{},[],{"type":20,"tag":34,"props":215,"children":216},{},[217,219,225,227,234],{"type":38,"value":218},"看到这篇通告的时候，我就回想起为什么我看 ",{"type":20,"tag":124,"props":220,"children":222},{"className":221},[],[223],{"type":38,"value":224},"cargo build --timings",{"type":38,"value":226}," 的时候肿么没想到会有 CWE-79。",{"type":20,"tag":104,"props":228,"children":231},{"href":229,"rel":230},"https://doc.rust-lang.org/cargo/reference/timings.html",[108],[232],{"type":38,"value":233},"--timings",{"type":38,"value":235}," 是一个生成 build 时间的 html 报告。",{"type":20,"tag":34,"props":237,"children":238},{},[239,241,247,249,255,257,263,265,271],{"type":38,"value":240},"可以通过在 ",{"type":20,"tag":124,"props":242,"children":244},{"className":243},[],[245],{"type":38,"value":246},"Cargo.toml",{"type":38,"value":248}," 中加入 ",{"type":20,"tag":124,"props":250,"children":252},{"className":251},[],[253],{"type":38,"value":254},"features = [\"\u003Cimg src='' onerror=alert(0)\"]",{"type":38,"value":256}," 来触发一个 CWE-79, 因此对这个问题的修复就是，将之前的 ",{"type":20,"tag":124,"props":258,"children":260},{"className":259},[],[261],{"type":38,"value":262},"Warning",{"type":38,"value":264},", 换成了 ",{"type":20,"tag":124,"props":266,"children":268},{"className":267},[],[269],{"type":38,"value":270},"bail!",{"type":38,"value":272}," 机制。",{"type":20,"tag":274,"props":275,"children":277},"text-space",{"type":276},"tip",[278],{"type":20,"tag":34,"props":279,"children":280},{},[281,286,288,295],{"type":20,"tag":124,"props":282,"children":284},{"className":283},[],[285],{"type":38,"value":270},{"type":38,"value":287}," 宏来自 ",{"type":20,"tag":104,"props":289,"children":292},{"href":290,"rel":291},"https://docs.rs/anyhow/latest/anyhow/macro.bail.html",[108],[293],{"type":38,"value":294},"anyhow",{"type":38,"value":296}," 用于方便地提前返回错误。",{"type":20,"tag":34,"props":298,"children":299},{},[300,302,309,311,317],{"type":38,"value":301},"可以看一下 ",{"type":20,"tag":104,"props":303,"children":306},{"href":304,"rel":305},"https://github.com/rust-lang/cargo/commit/9835622853f08be9a4b58ebe29dcec8f43b64b33#diff-99a8f4b284589e7db1aec698aa8f9ef9390f3ee3ecddc399dd6be1aa9ee00388L440-L446",[108],[307],{"type":38,"value":308},"fix pr",{"type":38,"value":310},"，非常有意思，比如 ",{"type":20,"tag":124,"props":312,"children":314},{"className":313},[],[315],{"type":38,"value":316},"validate_feature_name",{"type":38,"value":318}," 函数。",{"type":20,"tag":34,"props":320,"children":321},{},[322,324,330,332],{"type":38,"value":323},"原来：遇到非法 feature name，只输出 ",{"type":20,"tag":124,"props":325,"children":327},{"className":326},[],[328],{"type":38,"value":329},"warning",{"type":38,"value":331},"，流程继续。",{"type":20,"tag":211,"props":333,"children":334},{},[],{"type":20,"tag":156,"props":336,"children":338},{"code":337},"if let Some(ch) = chars.next() {Add commentMore actions\n        if !(unicode_xid::UnicodeXID::is_xid_start(ch) || ch == '_' || ch.is_digit(10)) {\n            config.shell().warn(&format!(\n                \"invalid character `{}` in feature `{}` in package {}, \\\n                the first character must be a Unicode XID start character or digit \\\n                (most letters or `_` or `0` to `9`)\\n\\\n                {}\",\n                ch, name, pkg_id, FUTURE\n            ))?;\n\n        }\n    }\n",[339],{"type":20,"tag":124,"props":340,"children":341},{"__ignoreMap":7},[342],{"type":38,"value":337},{"type":20,"tag":274,"props":344,"children":345},{"type":276},[346],{"type":20,"tag":34,"props":347,"children":348},{},[349],{"type":38,"value":350},"我本来想看看 2025-6-27 的 src/cargo/core/summary.rs 这个 fix pr 的区别。但我发现了一个流量密码，那就是 Rc → Arc, 问就是 Thread Safety！",{"type":20,"tag":34,"props":352,"children":353},{},[354,356,361],{"type":38,"value":355},"现在：遇到非法 feature name，直接 ",{"type":20,"tag":124,"props":357,"children":359},{"className":358},[],[360],{"type":38,"value":270},{"type":38,"value":362},"，构建中止，用户必须修正。",{"type":20,"tag":156,"props":364,"children":366},{"code":365}," if let Some(ch) = chars.next() {Add commentMore actions\n        if !(unicode_xid::UnicodeXID::is_xid_start(ch) || ch == '_' || ch.is_digit(10)) {\n            bail!(\n                \"invalid character `{}` in feature `{}` in package {}, \\\n                the first character must be a Unicode XID start character or digit \\\n                (most letters or `_` or `0` to `9`)\",\n                ch,\n                name,\n                pkg_id\n            );\n        }\n    }\n",[367],{"type":20,"tag":124,"props":368,"children":369},{"__ignoreMap":7},[370],{"type":38,"value":365},{"type":20,"tag":34,"props":372,"children":373},{},[374,376,382,384,390],{"type":38,"value":375},"在单元测试中，来验证 feature name 是否合法，例如只有 ",{"type":20,"tag":124,"props":377,"children":379},{"className":378},[],[380],{"type":38,"value":381},"is_ok()",{"type":38,"value":383}," 是合法的，而 ",{"type":20,"tag":124,"props":385,"children":387},{"className":386},[],[388],{"type":38,"value":389},"is_err()",{"type":38,"value":391}," 是不合法的：",{"type":20,"tag":156,"props":393,"children":395},{"code":394}," #[test]Add commentMore actions\n    fn valid_feature_names() {\n        let loc = CRATES_IO_INDEX.into_url().unwrap();\n        let source_id = SourceId::for_registry(&loc).unwrap();\n        let pkg_id = PackageId::new(\"foo\", \"1.0.0\", source_id).unwrap();\n\n        assert!(validate_feature_name(pkg_id, \"c++17\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"128bit\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"_foo\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"feat-name\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"feat_name\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"foo.bar\").is_ok());\n\n        assert!(validate_feature_name(pkg_id, \"+foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"-foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \".foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"foo:bar\").is_err());\n        assert!(validate_feature_name(pkg_id, \"foo?\").is_err());\n        assert!(validate_feature_name(pkg_id, \"?foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"ⒶⒷⒸ\").is_err());\n        assert!(validate_feature_name(pkg_id, \"a¼\").is_err());\n    }\n",[396],{"type":20,"tag":124,"props":397,"children":398},{"__ignoreMap":7},[399],{"type":38,"value":394},{"type":20,"tag":61,"props":401,"children":402},{},[],{"type":20,"tag":79,"props":404,"children":406},{"id":405},"cve-2023-41051-1",[407],{"type":38,"value":408},"CVE-2023-41051 1",{"type":20,"tag":86,"props":410,"children":414},{":type":200,"cve":411,"to":412,":cwe":413},"CVE-2023-51051","https://nvd.nist.gov/vuln/detail/cve-2023-41051","125",[415],{"type":20,"tag":34,"props":416,"children":417},{},[418],{"type":38,"value":419},"越界访问（out-of-bounds）: 访问了本不属于该内存区域的数据。",{"type":20,"tag":34,"props":421,"children":422},{},[423,430,432,438],{"type":20,"tag":104,"props":424,"children":427},{"href":425,"rel":426},"https://github.com/rust-vmm/vm-memory",[108],[428],{"type":38,"value":429},"vm-memory",{"type":38,"value":431}," 的 ",{"type":20,"tag":124,"props":433,"children":435},{"className":434},[],[436],{"type":38,"value":437},"VolatileMemory",{"type":38,"value":439}," 实现未对边界进行严格校验，导致有可能读取到非法的内存区域：",{"type":20,"tag":441,"props":442,"children":443},"ol",{},[444,456],{"type":20,"tag":445,"props":446,"children":447},"li",{},[448,454],{"type":20,"tag":124,"props":449,"children":451},{"className":450},[],[452],{"type":38,"value":453},"VolatileMemory::get_slice",{"type":38,"value":455},": 返回一段“易失性切片”（VolatileSlice），用于后续的底层操作",{"type":20,"tag":445,"props":457,"children":458},{},[459,465],{"type":20,"tag":124,"props":460,"children":462},{"className":461},[],[463],{"type":38,"value":464},"VolatileMemory::read/write",{"type":38,"value":466},": 直接从这块内存读/写数据，保证每次都实际发生内存访问",{"type":20,"tag":34,"props":468,"children":469},{},[470],{"type":38,"value":471},"VolatileMemory trait 就是定义了一套访问“虚拟机物理内存”或“特殊硬件内存区域”的低层接口，保证每次读写都真实发生，且不被编译器优化。它让不同的底层实现都能用统一的 trait 操作。",{"type":20,"tag":34,"props":473,"children":474},{},[475,477,483,485,491],{"type":38,"value":476},"但问题来了，这个通告并不涉及 ",{"type":20,"tag":124,"props":478,"children":480},{"className":479},[],[481],{"type":38,"value":482},"read/write",{"type":38,"value":484},"，更多的是 ",{"type":20,"tag":124,"props":486,"children":488},{"className":487},[],[489],{"type":38,"value":490},"get_slice",{"type":38,"value":492}," 方法，例如：",{"type":20,"tag":441,"props":494,"children":495},{},[496,505,514,523,532],{"type":20,"tag":445,"props":497,"children":498},{},[499],{"type":20,"tag":124,"props":500,"children":502},{"className":501},[],[503],{"type":38,"value":504},"get_atomic_ref",{"type":20,"tag":445,"props":506,"children":507},{},[508],{"type":20,"tag":124,"props":509,"children":511},{"className":510},[],[512],{"type":38,"value":513},"aligned_as_ref",{"type":20,"tag":445,"props":515,"children":516},{},[517],{"type":20,"tag":124,"props":518,"children":520},{"className":519},[],[521],{"type":38,"value":522},"aligned_as_mut",{"type":20,"tag":445,"props":524,"children":525},{},[526],{"type":20,"tag":124,"props":527,"children":529},{"className":528},[],[530],{"type":38,"value":531},"get_ref",{"type":20,"tag":445,"props":533,"children":534},{},[535],{"type":20,"tag":124,"props":536,"children":538},{"className":537},[],[539],{"type":38,"value":540},"get_array_ref",{"type":20,"tag":34,"props":542,"children":543},{},[544,546,552,554,560],{"type":38,"value":545},"上述方法有个共同点，都是利用 ",{"type":20,"tag":124,"props":547,"children":549},{"className":548},[],[550],{"type":38,"value":551},"ref",{"type":38,"value":553}," 类方法引起的。它们都尝试返回指向底层内存的 Rust 类型引用（如 &T、",{"type":20,"tag":124,"props":555,"children":557},{"className":556},[],[558],{"type":38,"value":559},"&[T]",{"type":38,"value":561}," 等），而不是直接读写原始字节数据。它们的实现通常会调用 get_slice，假设返回的内存区域长度足够大。",{"type":20,"tag":34,"props":563,"children":564},{},[565],{"type":38,"value":566},"如果自定义实现的 get_slice 返回的切片长度不足，就会导致这些 ref 方法产生越界引用，造成内存安全风险。例如：",{"type":20,"tag":441,"props":568,"children":569},{},[570,575,580],{"type":20,"tag":445,"props":571,"children":572},{},[573],{"type":38,"value":574},"这些方法假设 get_slice 返回的 VolatileSlice 长度是你要求的大小（比如 T 是 u32，就要 4 字节）。",{"type":20,"tag":445,"props":576,"children":577},{},[578],{"type":38,"value":579},"如果自定义实现的 get_slice 返回的 VolatileSlice 比你要求的短（比如只返回了2字节）",{"type":20,"tag":445,"props":581,"children":582},{},[583],{"type":38,"value":584},"这些方法还是会照常把这块内存强转成 &T，这时你访问 &T 时就可能会读到超出实际内存范围以外的内容",{"type":20,"tag":34,"props":586,"children":587},{},[588,590,596],{"type":38,"value":589},"仔细欣赏 ",{"type":20,"tag":104,"props":591,"children":594},{"href":592,"rel":593},"https://github.com/rust-vmm/vm-memory/commit/aff1dd4a5259f7deba56692840f7a2d9ca34c9c8#diff-0870facad91de878abbdf4dc43212b8de558021cf0971f62148c2cab381bd150R109-R275",[108],[595],{"type":38,"value":308},{"type":38,"value":597}," 你会发现：",{"type":20,"tag":34,"props":599,"children":600},{},[601,603,609,611,616,618,624],{"type":38,"value":602},"这些方法内部，都会调用 ",{"type":20,"tag":124,"props":604,"children":606},{"className":605},[],[607],{"type":38,"value":608},"get_slice(offset, count)",{"type":38,"value":610}," 拿到一块内存切片，然后把它 reinterpret_cast 成你要的类型引用。因此给 ",{"type":20,"tag":124,"props":612,"children":614},{"className":613},[],[615],{"type":38,"value":490},{"type":38,"value":617}," 加上 ",{"type":20,"tag":124,"props":619,"children":621},{"className":620},[],[622],{"type":38,"value":623},"assert_eq!",{"type":38,"value":625}," 就意味着：",{"type":20,"tag":34,"props":627,"children":628},{},[629],{"type":38,"value":630},"“如果你要 8 字节引用，必须实际拿到 8 字节的内存切片，否则直接 panic，不做 unsafe 操作！”",{"type":20,"tag":61,"props":632,"children":633},{},[],{"type":20,"tag":79,"props":635,"children":637},{"id":636},"cve-2023-38497-1",[638],{"type":38,"value":639},"CVE-2023-38497 1",{"type":20,"tag":86,"props":641,"children":646},{":type":642,"cve":643,"to":644,"cwe":645},"3","CVE-2023-38497","https://nvd.nist.gov/vuln/detail/cve-2023-38497","278,732",[647,655],{"type":20,"tag":34,"props":648,"children":649},{},[650,652],{"type":38,"value":651},"278: 不安全的保留继承权限",{"type":20,"tag":211,"props":653,"children":654},{},[],{"type":20,"tag":656,"props":657,"children":658},"ul",{},[659],{"type":20,"tag":445,"props":660,"children":661},{},[662],{"type":38,"value":663},"732: 关键资源的权限分配错误",{"type":20,"tag":34,"props":665,"children":666},{},[667,669,676,678,684,686,691,693,700,702,708,710,716],{"type":38,"value":668},"CWE-278 还是较为冷门的，毕竟只有一个参考，既 ",{"type":20,"tag":104,"props":670,"children":673},{"href":671,"rel":672},"https://www.cve.org/CVERecord?id=CVE-2005-1724",[108],[674],{"type":38,"value":675},"CVE-2005-1724",{"type":38,"value":677},"。CWE-278 这个类的漏洞常见表现之一就是 ",{"type":20,"tag":679,"props":680,"children":681},"strong",{},[682],{"type":38,"value":683},"权限限制”",{"type":38,"value":685},"。总的来说 umask 是 ",{"type":20,"tag":679,"props":687,"children":688},{},[689],{"type":38,"value":690},"限制新建文件或目录默认权限的一个机制。",{"type":38,"value":692},"，可以看看 ",{"type":20,"tag":104,"props":694,"children":697},{"href":695,"rel":696},"https://langzi989.github.io/2017/09/13/Linux%E4%B8%ADumash%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/",[108],[698],{"type":38,"value":699},"Linux中umask深入理解\n",{"type":38,"value":701},"，我清晰记得有时候需要执行什么 ",{"type":20,"tag":124,"props":703,"children":705},{"className":704},[],[706],{"type":38,"value":707},"bash",{"type":38,"value":709}," 脚本的时候，会使用 ",{"type":20,"tag":124,"props":711,"children":713},{"className":712},[],[714],{"type":38,"value":715},"chmod 777",{"type":38,"value":717},", 要不然运行不了。",{"type":20,"tag":274,"props":719,"children":720},{"type":276},[721,731,736,757,765],{"type":20,"tag":34,"props":722,"children":723},{},[724,726],{"type":38,"value":725},"CVE-2005-1724 是一个典型的“配置安全限制无效”型漏洞，使得 NFS 导出的目录被所有人都能访问，造成权限绕过和潜在的数据泄露/篡改风险。其归类于 CWE-278 ",{"type":20,"tag":679,"props":727,"children":728},{},[729],{"type":38,"value":730},"属于权限/访问控制失效问题。",{"type":20,"tag":34,"props":732,"children":733},{},[734],{"type":38,"value":735},"而 CWE-732 又是 CWE-278 的子类，因此会有两个 CWE 的分配。",{"type":20,"tag":34,"props":737,"children":738},{},[739,741,747,749,755],{"type":38,"value":740},"比如 CVE-2005-1724 在正常情况下，在导出（export）NFS 文件系统时，通常会用 ",{"type":20,"tag":124,"props":742,"children":744},{"className":743},[],[745],{"type":38,"value":746},"-network",{"type":38,"value":748}," 和 ",{"type":20,"tag":124,"props":750,"children":752},{"className":751},[],[753],{"type":38,"value":754},"-mask",{"type":38,"value":756},"：",{"type":20,"tag":156,"props":758,"children":760},{"code":759},"/some/dir -network 192.168.1.0 -mask 255.255.255.0\n",[761],{"type":20,"tag":124,"props":762,"children":763},{"__ignoreMap":7},[764],{"type":38,"value":759},{"type":20,"tag":34,"props":766,"children":767},{},[768],{"type":38,"value":769},"这样本应只有 192.168.1.0/24 网络内的主机可以访问该目录。但在 Mac OS X 10.4.x 的 NFS 服务实现没有正确处理/生效这些参数。因此构成了 CWE-278",{"type":20,"tag":34,"props":771,"children":772},{},[773,775,780,782,788],{"type":38,"value":774},"要想理解本次的 CVE，我们首先需要理解标题 ",{"type":20,"tag":679,"props":776,"children":777},{},[778],{"type":38,"value":779},"Cargo 在解压 crate 包时未按照 umask 限制文件权限",{"type":38,"value":781},"。而 ",{"type":20,"tag":124,"props":783,"children":785},{"className":784},[],[786],{"type":38,"value":787},"umask",{"type":38,"value":789}," 是默认权限，翻译成人话就是：",{"type":20,"tag":791,"props":792,"children":794},"text-tip",{"type":793},"big",[795],{"type":20,"tag":34,"props":796,"children":797},{},[798,800,806,808,811],{"type":38,"value":799},"Cargo 在解压 crate 包时，没有按照 umask 分个默认的权限。攻击者可以利用这一点也就是 ",{"type":20,"tag":124,"props":801,"children":803},{"className":802},[],[804],{"type":38,"value":805},"777",{"type":38,"value":807}," 权限构建攻击脚本。",{"type":20,"tag":211,"props":809,"children":810},{},[],{"type":38,"value":812},"\n↑ 可能不是很严谨",{"type":20,"tag":34,"props":814,"children":815},{},[816,818],{"type":38,"value":817},"过去 Cargo 解压 .crate 包时，直接采用了压缩包内的文件权限（比如 777/666），",{"type":20,"tag":679,"props":819,"children":820},{},[821],{"type":38,"value":822},"没有结合操作系统的 umask，导致解压后的文件权限过宽，其他本地用户可能能写入、篡改这些源码文件。",{"type":20,"tag":34,"props":824,"children":825},{},[826,828,834,836,842,844,849],{"type":38,"value":827},"在 ",{"type":20,"tag":124,"props":829,"children":831},{"className":830},[],[832],{"type":38,"value":833},"src/cargo/util/mod.rs",{"type":38,"value":835}," 中新增了 ",{"type":20,"tag":124,"props":837,"children":839},{"className":838},[],[840],{"type":38,"value":841},"get_umask()",{"type":38,"value":843}," 函数。以在解压文件时，强制用 ",{"type":20,"tag":124,"props":845,"children":847},{"className":846},[],[848],{"type":38,"value":787},{"type":38,"value":850}," 限制新文件的权限。：",{"type":20,"tag":156,"props":852,"children":854},{"code":853},"#[cfg(unix)]\npub fn get_umask() -> u32 {\n    use std::sync::OnceLock;\n    static UMASK: OnceLock\u003Clibc::mode_t> = OnceLock::new();\n    // SAFETY: Syscalls are unsafe. Calling `umask` twice is even unsafer for\n    // multithreading program, since it doesn't provide a way to retrive the\n    // value without modifications. We use a static `OnceLock` here to ensure\n    // it only gets call once during the entire program lifetime.\n    *UMASK.get_or_init(|| unsafe {\n        let umask = libc::umask(0o022);\n        libc::umask(umask);\n        umask\n    }) as u32 // it is u16 on macos\n}\n",[855],{"type":20,"tag":124,"props":856,"children":857},{"__ignoreMap":7},[858],{"type":38,"value":853},{"type":20,"tag":34,"props":860,"children":861},{},[862],{"type":38,"value":863},"以及很有艺术性的一行 code:",{"type":20,"tag":156,"props":865,"children":867},{"code":866},"fs::set_permissions(path, Permissions::from_mode(final_mode)).unwrap();\n",[868],{"type":20,"tag":124,"props":869,"children":870},{"__ignoreMap":7},[871],{"type":38,"value":866},{"type":20,"tag":34,"props":873,"children":874},{},[875,877,883],{"type":38,"value":876},"解压 crate 时，读取每个文件的原始权限（如 0o777），实际写入磁盘时，会用 原始权限 & ",{"type":20,"tag":124,"props":878,"children":880},{"className":879},[],[881],{"type":38,"value":882},"!umask",{"type":38,"value":884}," 得到最终权限，再 chmod 到文件上:",{"type":20,"tag":156,"props":886,"children":888},{"code":887},"assert_eq!(metadata.mode() & 0o777, 0o644 & !umask);\n",[889],{"type":20,"tag":124,"props":890,"children":891},{"__ignoreMap":7},[892],{"type":38,"value":887},{"type":20,"tag":61,"props":894,"children":895},{},[],{"type":20,"tag":72,"props":897,"children":899},{"id":898},"polyduekes-3",[900],{"type":38,"value":901},"Polyduekes 3",{"type":20,"tag":29,"props":903,"children":905},{"t":904},"Polyduekes",[],{"type":20,"tag":34,"props":907,"children":908},{},[909,911,916],{"type":38,"value":910},"在 telegram 认识到的热心群 U，得知我的目标是 Rust CVE 之后回复我了一个他整理过的合集。很有大佬的风范，特别是那句 ",{"type":20,"tag":679,"props":912,"children":913},{},[914],{"type":38,"value":915},"the rust cve part is easy, just look at the stdlib",{"type":38,"value":917},"。据我视奸过后，确实是一位经验丰富的大佬，例如：",{"type":20,"tag":441,"props":919,"children":920},{},[921,930,939,948,957,966],{"type":20,"tag":445,"props":922,"children":923},{},[924],{"type":20,"tag":104,"props":925,"children":928},{"href":926,"rel":927},"https://aur.archlinux.org/packages/pldget",[108],[929],{"type":38,"value":926},{"type":20,"tag":445,"props":931,"children":932},{},[933],{"type":20,"tag":104,"props":934,"children":937},{"href":935,"rel":936},"https://git.sr.ht/~cdv/polydeukes",[108],[938],{"type":38,"value":935},{"type":20,"tag":445,"props":940,"children":941},{},[942],{"type":20,"tag":104,"props":943,"children":946},{"href":944,"rel":945},"https://github.com/chrisvittal",[108],[947],{"type":38,"value":944},{"type":20,"tag":445,"props":949,"children":950},{},[951],{"type":20,"tag":104,"props":952,"children":955},{"href":953,"rel":954},"https://git.sr.ht/~cdv/",[108],[956],{"type":38,"value":953},{"type":20,"tag":445,"props":958,"children":959},{},[960],{"type":20,"tag":104,"props":961,"children":964},{"href":962,"rel":963},"https://chris.vittal.dev/",[108],[965],{"type":38,"value":962},{"type":20,"tag":445,"props":967,"children":968},{},[969],{"type":20,"tag":104,"props":970,"children":973},{"href":971,"rel":972},"https://github.com/rust-lang/rust/commits?author=chrisvittal",[108],[974],{"type":38,"value":971},{"type":20,"tag":976,"props":977,"children":980},"img-tip",{"text":978,"url":979},"之所以能机缘巧合得到大佬的这句话，源自于我看到了频道中转发的这个表情包，然后想起了小学时想用它攻击学校官网让其瘫痪的那个上午。\u003Cbr>\u003Cbr>不过攻击并没有成功，只是返回了 503, 换一台设备还能继续访问，可能当时需要通过类似 https://spys.one/en/ 这样的 IP 池才行。\u003Cbr>\u003Cbr>我当时一度认为这个软件没什么用，但频道的另一位管理员回复我说在他们那个年代，他通过这个软件让其一个论坛瘫痪掉了。\u003Cbr>\u003Cbr>有一说一十多年过去了，当时的界面就算拿到现在来看也并不过时。","cve/1.jpg",[],{"type":20,"tag":156,"props":982,"children":984},{"code":983},"the rust cve part is easy, just look at the stdlib \nhttps://www.cve.org/CVERecord?id=CVE-2024-24576\nhttps://www.cve.org/CVERecord?id=CVE-2022-21658\nhttps://www.cve.org/CVERecord?id=CVE-2021-31162\nhttps://www.cve.org/CVERecord?id=CVE-2021-28879\nhttps://www.cve.org/CVERecord?id=CVE-2021-28878\nhttps://www.cve.org/CVERecord?id=CVE-2025-3416\n",[985],{"type":20,"tag":124,"props":986,"children":987},{"__ignoreMap":7},[988],{"type":38,"value":983},{"title":7,"searchDepth":990,"depth":990,"links":991},2,[992,999],{"id":74,"depth":990,"text":77,"children":993},[994,996,997,998],{"id":81,"depth":995,"text":84},3,{"id":194,"depth":995,"text":197},{"id":405,"depth":995,"text":408},{"id":636,"depth":995,"text":639},{"id":898,"depth":990,"text":901},"markdown","content:plan:security:cve-learn.md","content","plan/security/cve-learn.md","md",{"script":1006,"meta":1014},[1007],{"id":1008,"type":1009,"processTemplateParams":1010,"innerHTML":1011,"tagPosition":1012,"tagPriority":1013},"nuxt-og-image-overrides","application/json",true,"[{\"title\":1,\"excerpt\":-1,\"component\":2},\"CVE learn\",\"OgImageCustom\"]","bodyClose",30,[1015,1018,1021,1024,1027,1029,1032,1034,1036,1038],{"property":1016,"content":1017},"og:image","/__og-image__/static/plan/security/cve-learn/og.png",{"property":1019,"content":1020},"og:image:width",1200,{"property":1022,"content":1023},"og:image:height",600,{"property":1025,"content":1026},"og:image:type","image/png",{"property":1028},"og:image:alt",{"name":1030,"content":1031},"twitter:card","summary_large_image",{"name":1033,"content":1017},"twitter:image:src",{"name":1035,"content":1020},"twitter:image:width",{"name":1037,"content":1023},"twitter:image:height",{"name":1039},"twitter:image:alt",1759306458238]