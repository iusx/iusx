[{"data":1,"prerenderedAt":921},["Reactive",2],{"content-query-oWUEheo9Hm":3},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":7,"director":9,"img":10,"time":11,"plan":12,"target":13,"current":14,"displayType":15,"body":16,"_type":916,"_id":917,"_source":918,"_file":919,"_extension":920},"/plan/security/cve-learn","security",false,"","CVE learn","My","14/1.png","2025.06.29","100,100",100,1,"percent",{"type":17,"children":18,"toc":909},"root",[19],{"type":20,"tag":21,"props":22,"children":27},"element","book-content",{":by":23,":img":24,":plan":25,":title":26},"director","img","plan","title",[28,33,40,45,50,55,60,64,71,78,91,134,148,160,182,185,191,207,229,266,290,312,328,336,344,356,364,385,393,396,402,413,433,460,465,486,534,555,560,578,591,619,624,627,633,657,709,761,781,804,814,842,850,855,863,876,884],{"type":20,"tag":29,"props":30,"children":32},"text-title",{":t":31},"CVE is my dream.",[],{"type":20,"tag":34,"props":35,"children":36},"p",{},[37],{"type":38,"value":39},"text","早在我上小学时，就觉得 CVE 很帅。步入初中时，在初三那年我拿到了广东电信 IPTV 的通用漏洞。步入社会时，我拿到了 Github 的 Bug bounty。但我始终没有去拿一个 CVE 的编号。因为水是可以水的，但我已经水了 CNVD 和 Hackerone，我希望我的第一个 CVE 编号可以是不那么水的，有一点含金量的。",{"type":20,"tag":34,"props":41,"children":42},{},[43],{"type":38,"value":44},"虽然我并不是 Security 行业或领域的从业人员，只是一个爱好者。但我一直觉得 Security 很帅。同样的，虽然我不是 Design 行业的从业人员，但我觉得可以让自己做出来的 project 会好看，有个性。",{"type":20,"tag":34,"props":46,"children":47},{},[48],{"type":38,"value":49},"我并不是一个专精的人。很多时候我每项感兴趣的领域单拎出来都会被降维打击。虽然我单项领域无法媲美专业的从业者，但我感兴趣的领域都有点建树和作品。将 Security、Design、Animation、Computer 合在一起，与之能媲美的人可能会少那么一点。",{"type":20,"tag":34,"props":51,"children":52},{},[53],{"type":38,"value":54},"而现在，我只有 Design 的代表作，而 Security、Animation、Computer 还没有一个能拿得出手的作品。因此我希望会在未来三年，尽可能的补全这些我感兴趣领域的代表作。可能因为 Work 比较闲的缘故，我的时间总会多那么一点来放到我感兴趣的领域上。即使达不到也没有关系，至少也是努力过了，无论如何三年后的自己总会比现在的自己稍微厉害那么一点点。",{"type":20,"tag":34,"props":56,"children":57},{},[58],{"type":38,"value":59},"因此这个页面会记录一些我感兴趣的 CVE 和 CWE 的编号来让我学习，可能会获取到一些新的思路和对某个方面的理解。来帮助我实现这个目标，顺便看看冷门的 CWE 方向，毕竟 OWASP TOP 10 个人没有太大的兴趣。",{"type":20,"tag":61,"props":62,"children":63},"hr",{},[],{"type":20,"tag":65,"props":66,"children":68},"h1",{"id":67},"rust-3",[69],{"type":38,"value":70},"rust 3",{"type":20,"tag":72,"props":73,"children":75},"h2",{"id":74},"cve-2022-36114-1",[76],{"type":38,"value":77},"CVE-2022-36114 1",{"type":20,"tag":79,"props":80,"children":85},"cve-info",{":type":81,"cve":82,"to":83,":cwe":84},"2","CVE-2022-36114","https://nvd.nist.gov/vuln/detail/CVE-2022-36114","400",[86],{"type":20,"tag":34,"props":87,"children":88},{},[89],{"type":38,"value":90},"不受控制的资源消耗",{"type":20,"tag":34,"props":92,"children":93},{},[94,96,105,107,114,116,123,125,132],{"type":38,"value":95},"利用 Cargo 的 ",{"type":20,"tag":97,"props":98,"children":102},"a",{"href":99,"rel":100},"https://doc.rust-lang.org/cargo/reference/build-scripts.html",[101],"nofollow",[103],{"type":38,"value":104},"build script",{"type":38,"value":106}," 在构建阶段编译第三方的非 Rust code，同时结合 ",{"type":20,"tag":97,"props":108,"children":111},{"href":109,"rel":110},"https://doc.rust-lang.org/book/ch20-05-macros.html#how-to-write-a-custom-derive-macro",[101],[112],{"type":38,"value":113},"procedural macros",{"type":38,"value":115},"，在执行 ",{"type":20,"tag":117,"props":118,"children":120},"code",{"className":119},[],[121],{"type":38,"value":122},"cargo run",{"type":38,"value":124}," 的过程中触发了一个 ",{"type":20,"tag":97,"props":126,"children":129},{"href":127,"rel":128},"https://en.wikipedia.org/wiki/Zip_bomb",[101],[130],{"type":38,"value":131},"Zip Bomb",{"type":38,"value":133}," 行为。",{"type":20,"tag":34,"props":135,"children":136},{},[137,139,146],{"type":38,"value":138},"对于这个问题的修复，rust-lang 已经给出了一个 ",{"type":20,"tag":97,"props":140,"children":143},{"href":141,"rel":142},"https://github.com/rust-lang/wg-security-response/blob/4bbe734e6404ece6f4e85027564f8995d4ab70e0/patches/CVE-2022-36114/0001-CVE-2022-36114-limit-the-maximum-unpacked-size-of-a-.patch",[101],[144],{"type":38,"value":145},"补丁修复",{"type":38,"value":147}," Zip_bomb 的问题:",{"type":20,"tag":149,"props":150,"children":155},"pre",{"code":151,"language":152,"meta":7,"className":153},"// 在解压 .crate 文件（tar.gz）时，限制最多只能解压出 512MB 的内容。\n+const MAX_UNPACK_SIZE: u64 = 512 * 1024 * 1024;\n","c",[154],"language-c",[156],{"type":20,"tag":117,"props":157,"children":158},{"__ignoreMap":7},[159],{"type":38,"value":151},{"type":20,"tag":34,"props":161,"children":162},{},[163,165,171,173,180],{"type":38,"value":164},"同时引入了 ",{"type":20,"tag":117,"props":166,"children":168},{"className":167},[],[169],{"type":38,"value":170},"LimitErrorReader",{"type":38,"value":172},": 超过就抛出错误，避免资源被耗尽（比如磁盘写爆）。除此之外并没有对 macros、build 加以限制，只是建议尽可能的用 ",{"type":20,"tag":97,"props":174,"children":177},{"href":175,"rel":176},"https://crates.io/",[101],[178],{"type":38,"value":179},"crates",{"type":38,"value":181}," 上提交的 crate。",{"type":20,"tag":61,"props":183,"children":184},{},[],{"type":20,"tag":72,"props":186,"children":188},{"id":187},"cve-2023-40030-1",[189],{"type":38,"value":190},"CVE-2023-40030 1",{"type":20,"tag":79,"props":192,"children":197},{":type":193,"cve":194,"to":195,":cwe":196},"1","CVE-2023-40030","https://nvd.nist.gov/vuln/detail/cve-2023-40030","79",[198],{"type":20,"tag":34,"props":199,"children":200},{},[201,203],{"type":38,"value":202},"{OWASP TOP TEN}: 不恰当的网页生成输入中和 XSS",{"type":20,"tag":204,"props":205,"children":206},"br",{},[],{"type":20,"tag":34,"props":208,"children":209},{},[210,212,218,220,227],{"type":38,"value":211},"看到这篇通告的时候，我就回想起为什么我看 ",{"type":20,"tag":117,"props":213,"children":215},{"className":214},[],[216],{"type":38,"value":217},"cargo build --timings",{"type":38,"value":219}," 的时候肿么没想到会有 CWE-79。",{"type":20,"tag":97,"props":221,"children":224},{"href":222,"rel":223},"https://doc.rust-lang.org/cargo/reference/timings.html",[101],[225],{"type":38,"value":226},"--timings",{"type":38,"value":228}," 是一个生成 build 时间的 html 报告。",{"type":20,"tag":34,"props":230,"children":231},{},[232,234,240,242,248,250,256,258,264],{"type":38,"value":233},"可以通过在 ",{"type":20,"tag":117,"props":235,"children":237},{"className":236},[],[238],{"type":38,"value":239},"Cargo.toml",{"type":38,"value":241}," 中加入 ",{"type":20,"tag":117,"props":243,"children":245},{"className":244},[],[246],{"type":38,"value":247},"features = [\"\u003Cimg src='' onerror=alert(0)\"]",{"type":38,"value":249}," 来触发一个 CWE-79, 因此对这个问题的修复就是，将之前的 ",{"type":20,"tag":117,"props":251,"children":253},{"className":252},[],[254],{"type":38,"value":255},"Warning",{"type":38,"value":257},", 换成了 ",{"type":20,"tag":117,"props":259,"children":261},{"className":260},[],[262],{"type":38,"value":263},"bail!",{"type":38,"value":265}," 机制。",{"type":20,"tag":267,"props":268,"children":270},"text-space",{"type":269},"tip",[271],{"type":20,"tag":34,"props":272,"children":273},{},[274,279,281,288],{"type":20,"tag":117,"props":275,"children":277},{"className":276},[],[278],{"type":38,"value":263},{"type":38,"value":280}," 宏来自 ",{"type":20,"tag":97,"props":282,"children":285},{"href":283,"rel":284},"https://docs.rs/anyhow/latest/anyhow/macro.bail.html",[101],[286],{"type":38,"value":287},"anyhow",{"type":38,"value":289}," 用于方便地提前返回错误。",{"type":20,"tag":34,"props":291,"children":292},{},[293,295,302,304,310],{"type":38,"value":294},"可以看一下 ",{"type":20,"tag":97,"props":296,"children":299},{"href":297,"rel":298},"https://github.com/rust-lang/cargo/commit/9835622853f08be9a4b58ebe29dcec8f43b64b33#diff-99a8f4b284589e7db1aec698aa8f9ef9390f3ee3ecddc399dd6be1aa9ee00388L440-L446",[101],[300],{"type":38,"value":301},"fix pr",{"type":38,"value":303},"，非常有意思，比如 ",{"type":20,"tag":117,"props":305,"children":307},{"className":306},[],[308],{"type":38,"value":309},"validate_feature_name",{"type":38,"value":311}," 函数。",{"type":20,"tag":34,"props":313,"children":314},{},[315,317,323,325],{"type":38,"value":316},"原来：遇到非法 feature name，只输出 ",{"type":20,"tag":117,"props":318,"children":320},{"className":319},[],[321],{"type":38,"value":322},"warning",{"type":38,"value":324},"，流程继续。",{"type":20,"tag":204,"props":326,"children":327},{},[],{"type":20,"tag":149,"props":329,"children":331},{"code":330},"if let Some(ch) = chars.next() {Add commentMore actions\n        if !(unicode_xid::UnicodeXID::is_xid_start(ch) || ch == '_' || ch.is_digit(10)) {\n            config.shell().warn(&format!(\n                \"invalid character `{}` in feature `{}` in package {}, \\\n                the first character must be a Unicode XID start character or digit \\\n                (most letters or `_` or `0` to `9`)\\n\\\n                {}\",\n                ch, name, pkg_id, FUTURE\n            ))?;\n\n        }\n    }\n",[332],{"type":20,"tag":117,"props":333,"children":334},{"__ignoreMap":7},[335],{"type":38,"value":330},{"type":20,"tag":267,"props":337,"children":338},{"type":269},[339],{"type":20,"tag":34,"props":340,"children":341},{},[342],{"type":38,"value":343},"我本来想看看 2025-6-27 的 src/cargo/core/summary.rs 这个 fix pr 的区别。但我发现了一个流量密码，那就是 Rc → Arc, 问就是 Thread Safety！",{"type":20,"tag":34,"props":345,"children":346},{},[347,349,354],{"type":38,"value":348},"现在：遇到非法 feature name，直接 ",{"type":20,"tag":117,"props":350,"children":352},{"className":351},[],[353],{"type":38,"value":263},{"type":38,"value":355},"，构建中止，用户必须修正。",{"type":20,"tag":149,"props":357,"children":359},{"code":358}," if let Some(ch) = chars.next() {Add commentMore actions\n        if !(unicode_xid::UnicodeXID::is_xid_start(ch) || ch == '_' || ch.is_digit(10)) {\n            bail!(\n                \"invalid character `{}` in feature `{}` in package {}, \\\n                the first character must be a Unicode XID start character or digit \\\n                (most letters or `_` or `0` to `9`)\",\n                ch,\n                name,\n                pkg_id\n            );\n        }\n    }\n",[360],{"type":20,"tag":117,"props":361,"children":362},{"__ignoreMap":7},[363],{"type":38,"value":358},{"type":20,"tag":34,"props":365,"children":366},{},[367,369,375,377,383],{"type":38,"value":368},"在单元测试中，来验证 feature name 是否合法，例如只有 ",{"type":20,"tag":117,"props":370,"children":372},{"className":371},[],[373],{"type":38,"value":374},"is_ok()",{"type":38,"value":376}," 是合法的，而 ",{"type":20,"tag":117,"props":378,"children":380},{"className":379},[],[381],{"type":38,"value":382},"is_err()",{"type":38,"value":384}," 是不合法的：",{"type":20,"tag":149,"props":386,"children":388},{"code":387}," #[test]Add commentMore actions\n    fn valid_feature_names() {\n        let loc = CRATES_IO_INDEX.into_url().unwrap();\n        let source_id = SourceId::for_registry(&loc).unwrap();\n        let pkg_id = PackageId::new(\"foo\", \"1.0.0\", source_id).unwrap();\n\n        assert!(validate_feature_name(pkg_id, \"c++17\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"128bit\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"_foo\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"feat-name\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"feat_name\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"foo.bar\").is_ok());\n\n        assert!(validate_feature_name(pkg_id, \"+foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"-foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \".foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"foo:bar\").is_err());\n        assert!(validate_feature_name(pkg_id, \"foo?\").is_err());\n        assert!(validate_feature_name(pkg_id, \"?foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"ⒶⒷⒸ\").is_err());\n        assert!(validate_feature_name(pkg_id, \"a¼\").is_err());\n    }\n",[389],{"type":20,"tag":117,"props":390,"children":391},{"__ignoreMap":7},[392],{"type":38,"value":387},{"type":20,"tag":61,"props":394,"children":395},{},[],{"type":20,"tag":72,"props":397,"children":399},{"id":398},"cve-2023-41051-1",[400],{"type":38,"value":401},"CVE-2023-41051 1",{"type":20,"tag":79,"props":403,"children":407},{":type":193,"cve":404,"to":405,":cwe":406},"CVE-2023-51051","https://nvd.nist.gov/vuln/detail/cve-2023-41051","125",[408],{"type":20,"tag":34,"props":409,"children":410},{},[411],{"type":38,"value":412},"越界访问（out-of-bounds）: 访问了本不属于该内存区域的数据。",{"type":20,"tag":34,"props":414,"children":415},{},[416,423,425,431],{"type":20,"tag":97,"props":417,"children":420},{"href":418,"rel":419},"https://github.com/rust-vmm/vm-memory",[101],[421],{"type":38,"value":422},"vm-memory",{"type":38,"value":424}," 的 ",{"type":20,"tag":117,"props":426,"children":428},{"className":427},[],[429],{"type":38,"value":430},"VolatileMemory",{"type":38,"value":432}," 实现未对边界进行严格校验，导致有可能读取到非法的内存区域：",{"type":20,"tag":434,"props":435,"children":436},"ol",{},[437,449],{"type":20,"tag":438,"props":439,"children":440},"li",{},[441,447],{"type":20,"tag":117,"props":442,"children":444},{"className":443},[],[445],{"type":38,"value":446},"VolatileMemory::get_slice",{"type":38,"value":448},": 返回一段“易失性切片”（VolatileSlice），用于后续的底层操作",{"type":20,"tag":438,"props":450,"children":451},{},[452,458],{"type":20,"tag":117,"props":453,"children":455},{"className":454},[],[456],{"type":38,"value":457},"VolatileMemory::read/write",{"type":38,"value":459},": 直接从这块内存读/写数据，保证每次都实际发生内存访问",{"type":20,"tag":34,"props":461,"children":462},{},[463],{"type":38,"value":464},"VolatileMemory trait 就是定义了一套访问“虚拟机物理内存”或“特殊硬件内存区域”的低层接口，保证每次读写都真实发生，且不被编译器优化。它让不同的底层实现都能用统一的 trait 操作。",{"type":20,"tag":34,"props":466,"children":467},{},[468,470,476,478,484],{"type":38,"value":469},"但问题来了，这个通告并不涉及 ",{"type":20,"tag":117,"props":471,"children":473},{"className":472},[],[474],{"type":38,"value":475},"read/write",{"type":38,"value":477},"，更多的是 ",{"type":20,"tag":117,"props":479,"children":481},{"className":480},[],[482],{"type":38,"value":483},"get_slice",{"type":38,"value":485}," 方法，例如：",{"type":20,"tag":434,"props":487,"children":488},{},[489,498,507,516,525],{"type":20,"tag":438,"props":490,"children":491},{},[492],{"type":20,"tag":117,"props":493,"children":495},{"className":494},[],[496],{"type":38,"value":497},"get_atomic_ref",{"type":20,"tag":438,"props":499,"children":500},{},[501],{"type":20,"tag":117,"props":502,"children":504},{"className":503},[],[505],{"type":38,"value":506},"aligned_as_ref",{"type":20,"tag":438,"props":508,"children":509},{},[510],{"type":20,"tag":117,"props":511,"children":513},{"className":512},[],[514],{"type":38,"value":515},"aligned_as_mut",{"type":20,"tag":438,"props":517,"children":518},{},[519],{"type":20,"tag":117,"props":520,"children":522},{"className":521},[],[523],{"type":38,"value":524},"get_ref",{"type":20,"tag":438,"props":526,"children":527},{},[528],{"type":20,"tag":117,"props":529,"children":531},{"className":530},[],[532],{"type":38,"value":533},"get_array_ref",{"type":20,"tag":34,"props":535,"children":536},{},[537,539,545,547,553],{"type":38,"value":538},"上述方法有个共同点，都是利用 ",{"type":20,"tag":117,"props":540,"children":542},{"className":541},[],[543],{"type":38,"value":544},"ref",{"type":38,"value":546}," 类方法引起的。它们都尝试返回指向底层内存的 Rust 类型引用（如 &T、",{"type":20,"tag":117,"props":548,"children":550},{"className":549},[],[551],{"type":38,"value":552},"&[T]",{"type":38,"value":554}," 等），而不是直接读写原始字节数据。它们的实现通常会调用 get_slice，假设返回的内存区域长度足够大。",{"type":20,"tag":34,"props":556,"children":557},{},[558],{"type":38,"value":559},"如果自定义实现的 get_slice 返回的切片长度不足，就会导致这些 ref 方法产生越界引用，造成内存安全风险。例如：",{"type":20,"tag":434,"props":561,"children":562},{},[563,568,573],{"type":20,"tag":438,"props":564,"children":565},{},[566],{"type":38,"value":567},"这些方法假设 get_slice 返回的 VolatileSlice 长度是你要求的大小（比如 T 是 u32，就要 4 字节）。",{"type":20,"tag":438,"props":569,"children":570},{},[571],{"type":38,"value":572},"如果自定义实现的 get_slice 返回的 VolatileSlice 比你要求的短（比如只返回了2字节）",{"type":20,"tag":438,"props":574,"children":575},{},[576],{"type":38,"value":577},"这些方法还是会照常把这块内存强转成 &T，这时你访问 &T 时就可能会读到超出实际内存范围以外的内容",{"type":20,"tag":34,"props":579,"children":580},{},[581,583,589],{"type":38,"value":582},"仔细欣赏 ",{"type":20,"tag":97,"props":584,"children":587},{"href":585,"rel":586},"https://github.com/rust-vmm/vm-memory/commit/aff1dd4a5259f7deba56692840f7a2d9ca34c9c8#diff-0870facad91de878abbdf4dc43212b8de558021cf0971f62148c2cab381bd150R109-R275",[101],[588],{"type":38,"value":301},{"type":38,"value":590}," 你会发现：",{"type":20,"tag":34,"props":592,"children":593},{},[594,596,602,604,609,611,617],{"type":38,"value":595},"这些方法内部，都会调用 ",{"type":20,"tag":117,"props":597,"children":599},{"className":598},[],[600],{"type":38,"value":601},"get_slice(offset, count)",{"type":38,"value":603}," 拿到一块内存切片，然后把它 reinterpret_cast 成你要的类型引用。因此给 ",{"type":20,"tag":117,"props":605,"children":607},{"className":606},[],[608],{"type":38,"value":483},{"type":38,"value":610}," 加上 ",{"type":20,"tag":117,"props":612,"children":614},{"className":613},[],[615],{"type":38,"value":616},"assert_eq!",{"type":38,"value":618}," 就意味着：",{"type":20,"tag":34,"props":620,"children":621},{},[622],{"type":38,"value":623},"“如果你要 8 字节引用，必须实际拿到 8 字节的内存切片，否则直接 panic，不做 unsafe 操作！”",{"type":20,"tag":61,"props":625,"children":626},{},[],{"type":20,"tag":72,"props":628,"children":630},{"id":629},"cve-2023-38497-1",[631],{"type":38,"value":632},"CVE-2023-38497 1",{"type":20,"tag":79,"props":634,"children":639},{":type":635,"cve":636,"to":637,"cwe":638},"3","CVE-2023-38497","https://nvd.nist.gov/vuln/detail/cve-2023-38497","278,732",[640,648],{"type":20,"tag":34,"props":641,"children":642},{},[643,645],{"type":38,"value":644},"278: 不安全的保留继承权限",{"type":20,"tag":204,"props":646,"children":647},{},[],{"type":20,"tag":649,"props":650,"children":651},"ul",{},[652],{"type":20,"tag":438,"props":653,"children":654},{},[655],{"type":38,"value":656},"732: 关键资源的权限分配错误",{"type":20,"tag":34,"props":658,"children":659},{},[660,662,669,671,677,679,684,686,691,693,699,701,707],{"type":38,"value":661},"CWE-278 还是较为冷门的，毕竟只有一个参考，既 ",{"type":20,"tag":97,"props":663,"children":666},{"href":664,"rel":665},"https://www.cve.org/CVERecord?id=CVE-2005-1724",[101],[667],{"type":38,"value":668},"CVE-2005-1724",{"type":38,"value":670},"。CWE-278 这个类的漏洞常见表现之一就是 ",{"type":20,"tag":672,"props":673,"children":674},"strong",{},[675],{"type":38,"value":676},"权限限制”",{"type":38,"value":678},"。总的来说 umask 是 ",{"type":20,"tag":672,"props":680,"children":681},{},[682],{"type":38,"value":683},"限制新建文件或目录默认权限的一个机制。",{"type":38,"value":685},"，可以看看 ",{"type":20,"tag":687,"props":688,"children":689},"sup",{},[690],{"type":38,"value":193},{"type":38,"value":692},"，我清晰记得有时候需要执行什么 ",{"type":20,"tag":117,"props":694,"children":696},{"className":695},[],[697],{"type":38,"value":698},"bash",{"type":38,"value":700}," 脚本的时候，会使用 ",{"type":20,"tag":117,"props":702,"children":704},{"className":703},[],[705],{"type":38,"value":706},"chmod 777",{"type":38,"value":708},", 要不然运行不了。",{"type":20,"tag":267,"props":710,"children":711},{"type":269},[712,722,727,748,756],{"type":20,"tag":34,"props":713,"children":714},{},[715,717],{"type":38,"value":716},"CVE-2005-1724 是一个典型的“配置安全限制无效”型漏洞，使得 NFS 导出的目录被所有人都能访问，造成权限绕过和潜在的数据泄露/篡改风险。其归类于 CWE-278 ",{"type":20,"tag":672,"props":718,"children":719},{},[720],{"type":38,"value":721},"属于权限/访问控制失效问题。",{"type":20,"tag":34,"props":723,"children":724},{},[725],{"type":38,"value":726},"而 CWE-732 又是 CWE-278 的子类，因此会有两个 CWE 的分配。",{"type":20,"tag":34,"props":728,"children":729},{},[730,732,738,740,746],{"type":38,"value":731},"比如 CVE-2005-1724 在正常情况下，在导出（export）NFS 文件系统时，通常会用 ",{"type":20,"tag":117,"props":733,"children":735},{"className":734},[],[736],{"type":38,"value":737},"-network",{"type":38,"value":739}," 和 ",{"type":20,"tag":117,"props":741,"children":743},{"className":742},[],[744],{"type":38,"value":745},"-mask",{"type":38,"value":747},"：",{"type":20,"tag":149,"props":749,"children":751},{"code":750},"/some/dir -network 192.168.1.0 -mask 255.255.255.0\n",[752],{"type":20,"tag":117,"props":753,"children":754},{"__ignoreMap":7},[755],{"type":38,"value":750},{"type":20,"tag":34,"props":757,"children":758},{},[759],{"type":38,"value":760},"这样本应只有 192.168.1.0/24 网络内的主机可以访问该目录。但在 Mac OS X 10.4.x 的 NFS 服务实现没有正确处理/生效这些参数。因此构成了 CWE-278",{"type":20,"tag":34,"props":762,"children":763},{},[764,766,771,773,779],{"type":38,"value":765},"要想理解本次的 CVE，我们首先需要理解标题 ",{"type":20,"tag":672,"props":767,"children":768},{},[769],{"type":38,"value":770},"Cargo 在解压 crate 包时未按照 umask 限制文件权限",{"type":38,"value":772},"。而 ",{"type":20,"tag":117,"props":774,"children":776},{"className":775},[],[777],{"type":38,"value":778},"umask",{"type":38,"value":780}," 是默认权限，翻译成人话就是：",{"type":20,"tag":782,"props":783,"children":785},"text-tip",{"type":784},"big",[786],{"type":20,"tag":34,"props":787,"children":788},{},[789,791,797,799,802],{"type":38,"value":790},"Cargo 在解压 crate 包时，没有按照 umask 分个默认的权限。攻击者可以利用这一点也就是 ",{"type":20,"tag":117,"props":792,"children":794},{"className":793},[],[795],{"type":38,"value":796},"777",{"type":38,"value":798}," 权限构建攻击脚本。",{"type":20,"tag":204,"props":800,"children":801},{},[],{"type":38,"value":803},"\n↑ 可能不是很严谨",{"type":20,"tag":34,"props":805,"children":806},{},[807,809],{"type":38,"value":808},"过去 Cargo 解压 .crate 包时，直接采用了压缩包内的文件权限（比如 777/666），",{"type":20,"tag":672,"props":810,"children":811},{},[812],{"type":38,"value":813},"没有结合操作系统的 umask，导致解压后的文件权限过宽，其他本地用户可能能写入、篡改这些源码文件。",{"type":20,"tag":34,"props":815,"children":816},{},[817,819,825,827,833,835,840],{"type":38,"value":818},"在 ",{"type":20,"tag":117,"props":820,"children":822},{"className":821},[],[823],{"type":38,"value":824},"src/cargo/util/mod.rs",{"type":38,"value":826}," 中新增了 ",{"type":20,"tag":117,"props":828,"children":830},{"className":829},[],[831],{"type":38,"value":832},"get_umask()",{"type":38,"value":834}," 函数。以在解压文件时，强制用 ",{"type":20,"tag":117,"props":836,"children":838},{"className":837},[],[839],{"type":38,"value":778},{"type":38,"value":841}," 限制新文件的权限。：",{"type":20,"tag":149,"props":843,"children":845},{"code":844},"#[cfg(unix)]\npub fn get_umask() -> u32 {\n    use std::sync::OnceLock;\n    static UMASK: OnceLock\u003Clibc::mode_t> = OnceLock::new();\n    // SAFETY: Syscalls are unsafe. Calling `umask` twice is even unsafer for\n    // multithreading program, since it doesn't provide a way to retrive the\n    // value without modifications. We use a static `OnceLock` here to ensure\n    // it only gets call once during the entire program lifetime.\n    *UMASK.get_or_init(|| unsafe {\n        let umask = libc::umask(0o022);\n        libc::umask(umask);\n        umask\n    }) as u32 // it is u16 on macos\n}\n",[846],{"type":20,"tag":117,"props":847,"children":848},{"__ignoreMap":7},[849],{"type":38,"value":844},{"type":20,"tag":34,"props":851,"children":852},{},[853],{"type":38,"value":854},"以及很有艺术性的一行 code:",{"type":20,"tag":149,"props":856,"children":858},{"code":857},"fs::set_permissions(path, Permissions::from_mode(final_mode)).unwrap();\n",[859],{"type":20,"tag":117,"props":860,"children":861},{"__ignoreMap":7},[862],{"type":38,"value":857},{"type":20,"tag":34,"props":864,"children":865},{},[866,868,874],{"type":38,"value":867},"解压 crate 时，读取每个文件的原始权限（如 0o777），实际写入磁盘时，会用 原始权限 & ",{"type":20,"tag":117,"props":869,"children":871},{"className":870},[],[872],{"type":38,"value":873},"!umask",{"type":38,"value":875}," 得到最终权限，再 chmod 到文件上:",{"type":20,"tag":149,"props":877,"children":879},{"code":878},"assert_eq!(metadata.mode() & 0o777, 0o644 & !umask);\n",[880],{"type":20,"tag":117,"props":881,"children":882},{"__ignoreMap":7},[883],{"type":38,"value":878},{"type":20,"tag":885,"props":886,"children":889},"div",{"id":887,"className":888},"refer-anchor-1",[544],[890],{"type":20,"tag":649,"props":891,"children":892},{},[893],{"type":20,"tag":438,"props":894,"children":895},{},[896,901,903],{"type":20,"tag":897,"props":898,"children":899},"span",{},[900],{"type":38,"value":193},{"type":38,"value":902}," ",{"type":20,"tag":97,"props":904,"children":907},{"href":905,"rel":906},"https://langzi989.github.io/2017/09/13/Linux%E4%B8%ADumash%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/",[101],[908],{"type":38,"value":905},{"title":7,"searchDepth":910,"depth":910,"links":911},2,[912,913,914,915],{"id":74,"depth":910,"text":77},{"id":187,"depth":910,"text":190},{"id":398,"depth":910,"text":401},{"id":629,"depth":910,"text":632},"markdown","content:plan:security:cve-learn.md","content","plan/security/cve-learn.md","md",1756915222923]