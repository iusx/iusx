[{"data":1,"prerenderedAt":1457},["Reactive",2],{"equalLink":3},[4,119,143,306,563],{"_path":5,"_dir":6,"_draft":7,"_partial":7,"_locale":8,"title":9,"description":10,"director":11,"time":12,"types":13,"img":14,"info":15,"client":16,"target":17,"current":18,"displayType":19,"body":20,"_type":114,"_id":115,"_source":116,"_file":117,"_extension":118},"/plan/life/pay-hongkong-style-room","life",false,"","Hongkong style room","作者2023年逃离深圳到惠州，住父母养老房。两年间主要靠不定期的大佬项目救济，年收入约410851.49日元。这一年远程工作后日子渐好，解决了吃饭问题。作者意识到自身不足，想攒钱买房，预算10万左右，还总结出捞钱所需因素，但自认有所欠缺。","ritsu","2025.08.20","cc","life/plan/room/1.jpg","封面：正在安装 Arch linux","My",13926.8,-529.22,"usd",{"type":21,"children":22,"toc":111},"root",[23],{"type":24,"tag":25,"props":26,"children":33},"element","main-content",{":client":27,":img":28,":info":29,":time":30,":title":31,":types":32},"client","img","info","time","title","types",[34,39,46,51,56,60,65,70,75,80,85,90,95,106],{"type":24,"tag":35,"props":36,"children":38},"text-sum",{":desc":37},"description",[],{"type":24,"tag":40,"props":41,"children":42},"p",{},[43],{"type":44,"value":45},"text","自从 2023 年逃离深圳来到惠州，已经过了两年，住的是父母准备养老的房子？反正空了很多年了。在这两年中唯一的焦虑就是带宽和吃饭的生活费，大概每年靠大佬项目救济能年入 ≈ 410851.49 JPY。也就是一个月大概能有 1666.67 CNY，不过也不是每个月都有。经常的是这个月 200，下个月 500，下下个月 1000 CNY 的样子。",{"type":24,"tag":40,"props":47,"children":48},{},[49],{"type":44,"value":50},"有钱的时候会添置家用电器，例如冰箱、洗衣机、电视(貌似自己只会待在自己房间，几乎很少去客厅活动，导致电视只有探亲的时候才会打开看）",{"type":24,"tag":40,"props":52,"children":53},{},[54],{"type":44,"value":55},"难得的是，在这两年中我得到了很多的成长。清晰的了解自己的不足，很长时间处在自嗨阶段。如果和科班的比，基础不是很扎实，Code 薄弱。UI 和 Design 也缺少很多体系化的学习，例如版式设计、色彩\\排版、等缺乏合理运用，导致做出来的项目只是看起来 niubbity，但很多大佬看一眼就知不是能落地的。",{"type":24,"tag":57,"props":58,"children":59},"hr",{},[],{"type":24,"tag":40,"props":61,"children":62},{},[63],{"type":44,"value":64},"日子也是最近一年才好起来的（混到了 Remote work），至少不需要提心吊胆的过日子。美团优选+京东弥补了吃饭的问题。摆脱了拼多多的多多买菜，虽然价格便宜一点点，但经常会收到和海鲜放在一起的苹果、橙子导致连带这些水果都有很大的海鲜异味（甚至在多多买菜买到过臭的黄瓜）",{"type":24,"tag":40,"props":66,"children":67},{},[68],{"type":44,"value":69},"惠州的菜市场真的很贵，同样的买苹果、橙子需要 70 CNY。而多多买菜和美团优选可能 20~30 CNY 解决。作为一个非常宅的，我可能一周、两周才会出门一次例如丢垃圾、拿菜等。考虑到家庭和睦，我决定攒点钱买个房子，可能预算 10W? 6w 买房其他的用来装修。",{"type":24,"tag":40,"props":71,"children":72},{},[73],{"type":44,"value":74},"曾经看了 The Brutalist 这部电影。我觉得水泥风也是挺好的，水泥风 + loft 非常不错！ 可能还有地方放椭圆机（每天都要有氧）我对空间的要求不是特别大，20~15 平米有卫浴间都能接受。（由于经常吃预制菜的原因，几乎不需要厨房，有一个电饭煲、微波炉就以解决我的饮食了）",{"type":24,"tag":40,"props":76,"children":77},{},[78],{"type":44,"value":79},"唯一需要考虑的是洗衣机、烘干机、椭圆机、冰箱（因为我觉得这些还挺占位置的）比较幸运的是赶上了房价暴跌，所以我几乎大概是买二手房捡漏的。有一说一我还是比较喜欢惠州这个城市的，毕竟有 “深圳后花园” 的美誉，Address 还可写 Shenzhen，做公交一个小时就到了。",{"type":24,"tag":40,"props":81,"children":82},{},[83],{"type":44,"value":84},"我的要求还比较低，比如外卖、网购送货上门方便即可。这两年在旅游区域待着真的是怕了，生活成本很高，只能依靠京东和线上买菜解决吃饭问题。即使是外卖都很贵，甚至没有拼好饭。",{"type":24,"tag":40,"props":86,"children":87},{},[88],{"type":44,"value":89},"如果按照一个月存 3000 的话，那么 10w 大概需要 34 个月。但很多时候都会有意外，例如 Team 倒闭了、破产了、散伙了等一系列不可控因素，还有一个因素就是好不容易攒了 7k。立马想着配一个主机去学 UE，就会 -7k 归零。",{"type":24,"tag":40,"props":91,"children":92},{},[93],{"type":44,"value":94},"考虑到父母还有大概 5 年退休，或许慢慢朝着 10W 这个目标努力比较好。当然可能 10W 买套 10~20 平米的房子很像老鼠窝。不如努力捞钱在后面加个 0 。经历过这两年的历练。我总结出了捞钱的必要因素，即：",{"type":24,"tag":96,"props":97,"children":100},"wise-info",{"by":98,"topic":99},"马卡姆","捞钱的必要因素",[101],{"type":24,"tag":40,"props":102,"children":103},{},[104],{"type":44,"value":105},"莫名其妙的勇气 + 无论见过任何做得比自己好的项目/作品，都觉得自己做的最好 + 放下道德枷锁",{"type":24,"tag":40,"props":107,"children":108},{},[109],{"type":44,"value":110},"这是我总结出来的共同特点，或许是环境因素导致的，目前我还缺少这三种必要的捞钱因素。经常处在 “看到大佬的作品就开始 emo” 的阶段。时不时有学习的动力，同时也间接性摆烂。",{"title":8,"searchDepth":112,"depth":112,"links":113},2,[],"markdown","content:plan:life:pay-hongkong-style-room.md","content","plan/life/pay-hongkong-style-room.md","md",{"_path":120,"_dir":121,"_draft":7,"_partial":7,"_locale":8,"title":122,"description":8,"director":11,"time":123,"types":13,"img":124,"info":125,"client":16,"target":126,"current":127,"displayType":128,"body":129,"_type":114,"_id":141,"_source":116,"_file":142,"_extension":118},"/plan/programming/cds","programming","cds","2025.08.22","des/01/hide.jpg","封面：command-hide.vscode version",100,1,"percent",{"type":21,"children":130,"toc":139},[131],{"type":24,"tag":25,"props":132,"children":133},{":client":27,":img":28,":info":29,":time":30,":title":31,":types":32},[134],{"type":24,"tag":135,"props":136,"children":138},"git-info",{"url":137},"https://github.com/iusx/cdx",[],{"title":8,"searchDepth":112,"depth":112,"links":140},[],"content:plan:programming:cds.md","plan/programming/cds.md",{"_path":144,"_dir":121,"_draft":7,"_partial":7,"_locale":8,"title":145,"description":8,"director":11,"time":146,"types":13,"img":124,"info":125,"client":16,"target":126,"current":147,"displayType":128,"body":148,"_type":114,"_id":304,"_source":116,"_file":305,"_extension":118},"/plan/programming/command-hide","command-hide","2025.03.31",99.99,{"type":21,"children":149,"toc":302},[150],{"type":24,"tag":25,"props":151,"children":152},{":client":27,":img":28,":info":29,":time":30,":title":31,":types":32},[153,157,162,178,192,206,209,214,236,249,258],{"type":24,"tag":135,"props":154,"children":156},{"url":155},"https://github.com/jiangxue-analysis/vscode-comment-hide",[],{"type":24,"tag":135,"props":158,"children":161},{"url":159,"type":160},"https://github.com/jiangxue-analysis/nvim.comment-hide","iss",[],{"type":24,"tag":40,"props":163,"children":164},{},[165,167,176],{"type":44,"value":166},"我写了差不多一篇小软文，题目为 ",{"type":24,"tag":168,"props":169,"children":173},"a",{"href":170,"rel":171},"https://dev.to/brights/why-doesnt-anyone-want-to-write-code-comments-anymore-40jf",[172],"nofollow",[174],{"type":44,"value":175},"VSCode plugin comment-hide: Dare to write comments!",{"type":44,"value":177}," 这篇文章打算投稿到 chokcoco 的 icss 前端趣闻的，但貌似大佬比较忙没时间审稿了（确信！）只好翻译成 English 发到 dev.to 上。如你所见我写了两个版本，一个是 VScode 另一个是 Neovim plugin。",{"type":24,"tag":40,"props":179,"children":180},{},[181,183,190],{"type":44,"value":182},"之所以有两个版本是我中途切换到 neovim 了。因为在项目中 VScode 经常崩溃，甚至是闪退？Lsp 动不动就不起作用。只好换成了 neovim，前期用的是 Lazyvim。但用的时候发现动不动就给我报错，fzf 也一些子就各种 warnning 很烦。于是只好把 Lazyvim 删了换成了 ",{"type":24,"tag":168,"props":184,"children":187},{"href":185,"rel":186},"https://github.com/folke/lazy.nvim",[172],[188],{"type":44,"value":189},"lazy.nvim",{"type":44,"value":191},"。",{"type":24,"tag":40,"props":193,"children":194},{},[195,197,204],{"type":44,"value":196},"需要什么我自己配什么，有一说一和搭积木一样，仿佛时间过得很快。参考了 ",{"type":24,"tag":168,"props":198,"children":201},{"href":199,"rel":200},"https://github.com/dragove/dotfiles/tree/master/nvim/.config/nvim",[172],[202],{"type":44,"value":203},"dragove/nvim/.config/nvim",{"type":44,"value":205}," 的结构，看起来就很专业，自己配的话确实很舒服，完全按照自己的需求来搭配。解决了很多 Lazyvim 会遇到的问题，如果遇到了问题还可以调试下是那个 plugin 出现的，来进行点对点的解决，不会手忙脚乱。",{"type":24,"tag":57,"props":207,"children":208},{},[],{"type":24,"tag":40,"props":210,"children":211},{},[212],{"type":44,"value":213},"由于我自己长时间用的都是 neovim，所以 vscode 的版本被我 archive 掉了。基本上逻辑用的都是正则来进行匹配，因此移植到 neovim 上比较简单。至于为什么写这个插件，可能是抱着长时间接触 Code 做准备吧。因为 code 有注释确实能方便阅读并理解。但如果作为公开的话，雀实会发生一些问题，例如：“怎么这么简单的逻辑还要写注释！”",{"type":24,"tag":40,"props":215,"children":216},{},[217,219,226,228,234],{"type":44,"value":218},"因此我觉得如果要公开的话，或者说每个人都能看到的话，我更希望将注释删掉。这样就可以装作很腻害的样子，注释只能自己看到。不过经历了我自己的长期使用，如果遇到类似 vue 这种一个文件有 html、css、js 的，只能处理简单的注释，比如如果在 ",{"type":24,"tag":220,"props":221,"children":223},"code",{"className":222},[],[224],{"type":44,"value":225},"\u003Ctemplate>\u003C/template>",{"type":44,"value":227}," 中出现了 ",{"type":24,"tag":220,"props":229,"children":231},{"className":230},[],[232],{"type":44,"value":233},"\u003Cp>//\u003C/p>",{"type":44,"value":235}," 就也会被认定是注释去除。",{"type":24,"tag":40,"props":237,"children":238},{},[239,241,247],{"type":44,"value":240},"要解决这个问题的话可能需要重构逻辑，例如对这种文件进行单独匹配，比如 vue 就需要单独调用 ",{"type":24,"tag":220,"props":242,"children":244},{"className":243},[],[245],{"type":44,"value":246},"js\\html\\css",{"type":44,"value":248}," 三个注释逻辑，而不是目前的这种：",{"type":24,"tag":250,"props":251,"children":253},"pre",{"code":252},"vue = { multi_patterns.html, single_patterns.slash, multi_patterns.c },\n",[254],{"type":24,"tag":220,"props":255,"children":256},{"__ignoreMap":8},[257],{"type":44,"value":252},{"type":24,"tag":40,"props":259,"children":260},{},[261,263,269,271,277,279,285,287,293,294,300],{"type":44,"value":262},"也就是说需要 ",{"type":24,"tag":220,"props":264,"children":266},{"className":265},[],[267],{"type":44,"value":268},"\u003Cscript>",{"type":44,"value":270}," 用 js 的注释, ",{"type":24,"tag":220,"props":272,"children":274},{"className":273},[],[275],{"type":44,"value":276},"\u003Ctemplate>",{"type":44,"value":278}," 用 ",{"type":24,"tag":220,"props":280,"children":282},{"className":281},[],[283],{"type":44,"value":284},"html",{"type":44,"value":286}," 的注释，",{"type":24,"tag":220,"props":288,"children":290},{"className":289},[],[291],{"type":44,"value":292},"style",{"type":44,"value":278},{"type":24,"tag":220,"props":295,"children":297},{"className":296},[],[298],{"type":44,"value":299},"css",{"type":44,"value":301}," 的注释，不过我目前就只遇到过一次，如果遇到四五次的话，可能会修复这个问题（毕竟改动貌似挺大的（",{"title":8,"searchDepth":112,"depth":112,"links":303},[],"content:plan:programming:command-hide.md","plan/programming/command-hide.md",{"_path":307,"_dir":121,"_draft":7,"_partial":7,"_locale":8,"title":308,"description":309,"director":11,"time":310,"types":13,"img":311,"info":312,"client":16,"target":126,"current":313,"displayType":128,"body":314,"_type":114,"_id":561,"_source":116,"_file":562,"_extension":118},"/plan/programming/new-blog-theme-plan","NEW BLOG THEME PLAN","回顾了 Blog 的设计历程，从最初简单的布局到使用 D3.js 实现动态效果，再到探索 Spine 动画技术的可能性。作者反思了过去的“自嗨”心态，意识到技术能力的不足，但也找到了新的方向——借鉴 Pinterest 上的风格，结合手绘或约稿，利用 Spine 实现更专业的交互效果。虽然计划可能耗时较长（甚至跨年），但希望通过学习提升，最终打造一个兼具科技感和美术风格的博客，以此增强自信并摆脱“loser”心态。","2025.07.06","life/plan/new-blog/1.png","封面：构造 SMTP 协议发送信息",5,{"type":21,"children":315,"toc":559},[316],{"type":24,"tag":25,"props":317,"children":318},{":client":27,":img":28,":info":29,":time":30,":title":31,":types":32},[319,322,327,333,338,343,348,353,358,363,366,380,388,393,409,414,428,474,479,484,489,499,504,509,518,523,532,546,554],{"type":24,"tag":35,"props":320,"children":321},{":desc":37},[],{"type":24,"tag":40,"props":323,"children":324},{},[325],{"type":44,"value":326},"目前这个 BLOG 大概是在去年的七月份开始筹备的。总共设计了两次，第一版是一个很简单的布局，而第二版是通过 D3.JS 实现了一个类似 “心脏跳动” 的效果。但还是很制式风格，并没有什么特点。在此之前，我沉浸在自嗨的喜悦中，即使知道自己是个 loser，但依然不愿意承认自己是个 loser，每当觉得自己很 loser 的时候。",{"type":24,"tag":328,"props":329,"children":332},"text-space",{"img":330,"info":331},"life/plan/new-blog/2.png","图 1 ｜ 第一版和第二版的 BLOG 设计（感觉第一版还挺好看的，第二版就显得沉默寡闻了",[],{"type":24,"tag":40,"props":334,"children":335},{},[336],{"type":44,"value":337},"就会打开 Figma 开始幻想自己是多么腻害，多么 niubbity。沉浸在自己幻想的世界里无法自拔，直到我开始不那么故步自封。在 loser 的这个时间段中，我知道了自己在哪些地方的不足，以及了解了新的知识，例如 spine。",{"type":24,"tag":40,"props":339,"children":340},{},[341],{"type":44,"value":342},"spine 给我带来了一个无限可能。我可以利用 spine runtime 来实现我以前高攀不起的效果甚至是交互。主要还是自己基础不是很牢固，如果基础牢固，就不会有上面沉浸自嗨的环境中麻痹自己。",{"type":24,"tag":40,"props":344,"children":345},{},[346],{"type":44,"value":347},"如果自己很腻害，给 apache 开 20 个 pr 就能混进 apache。给 rust-lang 开 50 个 pr 也能混进 rust。这些 pr 都不是水一个很小的问题，更多事提供 “价值”。归根结底还是自己太菜，庆幸的是自己有很多时间学习。",{"type":24,"tag":328,"props":349,"children":352},{"img":350,"info":351},"life/plan/new-blog/3.png","图 2 ｜ 在 pinterest 上发现的 style，很个性，并且布局很合理。是我喜欢的类型，有 tech 的感觉。",[],{"type":24,"tag":40,"props":354,"children":355},{},[356],{"type":44,"value":357},"新的 style 会增加些许自信，在觉得自己是 loser 的时候可以看看自己的 blog 安慰下自己，起码美术很好不是吗？风格我已经确定好了，就是类似 图2 的那种。可能是我自己手绘？然后自己拆分下，在放到 spine 上做动画，之后利用下 spine runtime 实现交互。",{"type":24,"tag":40,"props":359,"children":360},{},[361],{"type":44,"value":362},"在这个过程中我可以学习到特别想学的特效。不过自己画难免会有很多问题，或许我会选择花个 1k 的预算约一个画师帮我画三视图，之后自己拆分下。总之可能需要很久才能开始这个 plan，要学的太多了，可能会在今年？明年？完成这个 PLAN？",{"type":24,"tag":57,"props":364,"children":365},{},[],{"type":24,"tag":40,"props":367,"children":368},{},[369,371,378],{"type":44,"value":370},"最近学习到了一个新的词汇，叫 ",{"type":24,"tag":168,"props":372,"children":375},{"href":373,"rel":374},"https://en.wikipedia.org/wiki/CSS_hack",[172],[376],{"type":44,"value":377},"CSS Hack",{"type":44,"value":379}," 是水 AOSC 的时候在 group 上有一个大佬指出来的（很严谨，学到很多:",{"type":24,"tag":250,"props":381,"children":383},{"code":382},"table {\n  margin: 1em 0;\n+ display: block;\n+ overflow-x: auto;\n}\n",[384],{"type":24,"tag":220,"props":385,"children":386},{"__ignoreMap":8},[387],{"type":44,"value":382},{"type":24,"tag":40,"props":389,"children":390},{},[391],{"type":44,"value":392},"其大概含义就是可能这么写不会生效，例如（Invalid or non-compliant CSS/Unsupported CSS）不过我 firefox 和 chrome 以及 safari 都看了一遍，确实解决了 overflow 的问题，所以我就没继续开 pr 去水（感觉老是水这种没什么意思，但又不敢水大的，一点一点水也很不错啦！毕竟 Linus 说过:",{"type":24,"tag":96,"props":394,"children":397},{"by":395,"topic":396},"Linus Benedict Torvalds","The mind behind Linux | Linus Torvalds | TED",[398],{"type":24,"tag":40,"props":399,"children":400},{},[401,403,407],{"type":44,"value":402},"Some of those people dont't do a lot",{"type":24,"tag":404,"props":405,"children":406},"br",{},[],{"type":44,"value":408},"\nThere's a lot of people who make small,small changes,",{"type":24,"tag":40,"props":410,"children":411},{},[412],{"type":44,"value":413},"在视奸其他大佬之后发现有的大佬是向往无 CSS 、无 JavaScrip 这种追求的。很明显我不是，我想要的是最终效果达到且好看和设计时一样就好了。大概率是我还停留在应用，没有深入 V8,渲染、编译这一阶段。",{"type":24,"tag":40,"props":415,"children":416},{},[417,419,426],{"type":44,"value":418},"最近在玩 ",{"type":24,"tag":168,"props":420,"children":423},{"href":421,"rel":422},"https://store.steampowered.com/app/2585110/_/",[172],[424],{"type":44,"value":425},"《我在疗养院送人上西天》",{"type":44,"value":427}," 是一个推箱子玩法，据说是二消？根据我的游玩体验发现是需要用到 math 的。比如通过计算实现最小步数过关，而我没这个追求，我只想过关而已。",{"type":24,"tag":96,"props":429,"children":432},{"by":430,"topic":431},"linus benedict torvalds","the mind behind linux | linus torvalds | ted",[433],{"type":24,"tag":40,"props":434,"children":435},{},[436,438,441,443,446,448,451,453,456,459,461,464,466,469,471],{"type":44,"value":437},"but that's not everybody,",{"type":24,"tag":404,"props":439,"children":440},{},[],{"type":44,"value":442},"\ni care about the thechnology",{"type":24,"tag":404,"props":444,"children":445},{},[],{"type":44,"value":447},"\nthere are people who care about the ui",{"type":24,"tag":404,"props":449,"children":450},{},[],{"type":44,"value":452},"\ni can't do ui to save my life.",{"type":24,"tag":404,"props":454,"children":455},{},[],{"type":24,"tag":404,"props":457,"children":458},{},[],{"type":44,"value":460},"\ni mean, if i was stranded on an island,",{"type":24,"tag":404,"props":462,"children":463},{},[],{"type":44,"value":465},"\nand the only way to get off that island was the make a pretty ui,",{"type":24,"tag":404,"props":467,"children":468},{},[],{"type":44,"value":470},"\ni'd die there.",{"type":24,"tag":404,"props":472,"children":473},{},[],{"type":24,"tag":40,"props":475,"children":476},{},[477],{"type":44,"value":478},"(根据我视奸群u萌得出的一个暴论就是：前端可有可无，需要的时候直接拷打 AI)",{"type":24,"tag":40,"props":480,"children":481},{},[482],{"type":44,"value":483},"很明显我是 \"There are people who care about the UI\" 的那个人。但我又有那么一点点追求，你可以说我 code ,design, security 都是 🗑 但我都有那么一点点的小成就。这又回到了我初中时纠结的一点，是走 security 还是走 code，我选择的是后者。",{"type":24,"tag":40,"props":485,"children":486},{},[487],{"type":44,"value":488},"因为我当初梳理的结论是 design > code > security > ui 因为 security 和 ui 都是建立在 code 之下的。没有 code 怎么实现，没有实现怎么 security test。之所以没有 desing，是因为 desing 无处不在，code 也需要精心 design 否则就会难以维护。design 决定了 code 的上限与下限，同样也决定了前端的上限与下限。",{"type":24,"tag":96,"props":490,"children":493},{"by":491,"topic":492},"Wikipedia","Frontend and backend",[494],{"type":24,"tag":40,"props":495,"children":496},{},[497],{"type":44,"value":498},"In software development, frontend refers to the presentation layer that users interact with, while backend involves the data management and processing behind the scenes, and full-stack development refers to mastering both. In the client–server model, the client is usually considered the frontend, handling user-facing tasks, and the server is the backend, managing data and logic. Some presentation tasks may also be performed by the server.",{"type":24,"tag":40,"props":500,"children":501},{},[502],{"type":44,"value":503},"前端下限低上限高——比如你写 HTML/JS/CSS 也是前端，混进了 Node.js/W3C/TC39/LWJGL 也是前端，会套个 UI 组件库用个框架也是前端；从工具链来看，有人用记事本写 jQuery，有人参与构建 Babel/Webpack；从图形技术看，有人只会 CSS 画方块，有人用 WebGL/WebGPU 开发 3D 引擎；从标准化角度看，有人只会查 MDN，有人参与 W3C 标准制定。",{"type":24,"tag":40,"props":505,"children":506},{},[507],{"type":44,"value":508},"同样的，design 也是下限低上限高——你 Figma 套个现成的也叫 UI design，拿了各种 IF、RED、IDEA、Core77 也叫 design；从交互设计看，有人拼凑现成组件，有人发明全新交互范式（如滑动解锁）；从设计系统看，有人用 Ant Design，有人打造 Material Design 这样的行业标准；从动态设计看，有人用 Canva 做动效，有人开发 Rive 这样的专业工具。",{"type":24,"tag":328,"props":510,"children":512},{"type":511},"tip",[513],{"type":24,"tag":40,"props":514,"children":515},{},[516],{"type":44,"value":517},"肯定会有人觉得我是从事前端、design 的既得利益者，很可惜我并不从事这些行业，我只是当个消磨时间的爱好罢了。",{"type":24,"tag":40,"props":519,"children":520},{},[521],{"type":44,"value":522},"很讨厌那些 AI 魔怔人（不过有点背后蛐蛐人的意思，但还好以后都不会遇到了），什么都 AI，真希望 AI 早点淘汰掉这些人，希望他们公司 Leader 早点意识到让 AI 取代下他们工作，再原有的基础上加个 10% 倍 KPI，狠狠替代。",{"type":24,"tag":40,"props":524,"children":525},{},[526],{"type":24,"tag":527,"props":528,"children":529},"del",{},[530],{"type":44,"value":531},"一想到这些人会面临失业淘汰跑众包心里就舒服多了（可能有点阴暗角落老鼠思维，但好在没人看我 blog",{"type":24,"tag":40,"props":533,"children":534},{},[535,537,544],{"type":44,"value":536},"可能这个现象可以用 ",{"type":24,"tag":168,"props":538,"children":541},{"href":539,"rel":540},"https://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect",[172],[542],{"type":44,"value":543},"Dunning–Kruger effect",{"type":44,"value":545}," 来解释，很爽。有时候在想，比我 niubbity 的自然会有比他 niubbity 的当球踢，比我 niubbity 没什么大不了的反正真正的大佬又不会在 Public Group 刷新，都是 LV2、LV3、LV4 的 NPC 再强不过 Top 10%,在弱不过 LV2。",{"type":24,"tag":96,"props":547,"children":548},{"by":491,"topic":543},[549],{"type":24,"tag":40,"props":550,"children":551},{},[552],{"type":44,"value":553},"The Dunning–Kruger effect is defined as the tendency of people with low ability in a specific area to give overly positive assessments of this ability",{"type":24,"tag":40,"props":555,"children":556},{},[557],{"type":44,"value":558},"其实有时候在想。当一只井底之蛙没什么不好的，眼界高了，看的大佬们的作品之后难免会妄自菲薄？然后陷入学习循环，导致没有迈出去做的那一步，一直在学习，一直在吹毛求疵。但环境，家庭，运气和性格都是决定一个人走向的因素之一，每个人都是不同的（起码在基因上是这样）",{"title":8,"searchDepth":112,"depth":112,"links":560},[],"content:plan:programming:new-blog-theme-plan.md","plan/programming/new-blog-theme-plan.md",{"_path":564,"_dir":565,"_draft":7,"_partial":7,"_locale":8,"title":566,"description":8,"director":16,"img":567,"time":568,"plan":569,"target":126,"current":127,"displayType":128,"body":570,"_type":114,"_id":1455,"_source":116,"_file":1456,"_extension":118},"/plan/security/cve-learn","security","CVE learn","14/1.png","2025.06.29","100,100",{"type":21,"children":571,"toc":1449},[572],{"type":24,"tag":573,"props":574,"children":577},"book-content",{":by":575,":img":28,":plan":576,":title":31},"director","plan",[578,583,588,593,598,603,608,611,618,625,638,678,692,703,725,728,734,749,771,808,830,852,868,876,884,896,904,925,933,936,942,953,973,1000,1005,1026,1074,1095,1100,1118,1131,1159,1164,1167,1173,1197,1249,1301,1321,1344,1354,1382,1390,1395,1403,1416,1424],{"type":24,"tag":579,"props":580,"children":582},"text-title",{":t":581},"CVE is my dream.",[],{"type":24,"tag":40,"props":584,"children":585},{},[586],{"type":44,"value":587},"早在我上小学时，就觉得 CVE 很帅。步入初中时，在初三那年我拿到了广东电信 IPTV 的通用漏洞。步入社会时，我拿到了 Github 的 Bug bounty。但我始终没有去拿一个 CVE 的编号。因为水是可以水的，但我已经水了 CNVD 和 Hackerone，我希望我的第一个 CVE 编号可以是不那么水的，有一点含金量的。",{"type":24,"tag":40,"props":589,"children":590},{},[591],{"type":44,"value":592},"虽然我并不是 Security 行业或领域的从业人员，只是一个爱好者。但我一直觉得 Security 很帅。同样的，虽然我不是 Design 行业的从业人员，但我觉得可以让自己做出来的 project 会好看，有个性。",{"type":24,"tag":40,"props":594,"children":595},{},[596],{"type":44,"value":597},"我并不是一个专精的人。很多时候我每项感兴趣的领域单拎出来都会被降维打击。虽然我单项领域无法媲美专业的从业者，但我感兴趣的领域都有点建树和作品。将 Security、Design、Animation、Computer 合在一起，与之能媲美的人可能会少那么一点。",{"type":24,"tag":40,"props":599,"children":600},{},[601],{"type":44,"value":602},"而现在，我只有 Design 的代表作，而 Security、Animation、Computer 还没有一个能拿得出手的作品。因此我希望会在未来三年，尽可能的补全这些我感兴趣领域的代表作。可能因为 Work 比较闲的缘故，我的时间总会多那么一点来放到我感兴趣的领域上。即使达不到也没有关系，至少也是努力过了，无论如何三年后的自己总会比现在的自己稍微厉害那么一点点。",{"type":24,"tag":40,"props":604,"children":605},{},[606],{"type":44,"value":607},"因此这个页面会记录一些我感兴趣的 CVE 和 CWE 的编号来让我学习，可能会获取到一些新的思路和对某个方面的理解。来帮助我实现这个目标，顺便看看冷门的 CWE 方向，毕竟 OWASP TOP 10 个人没有太大的兴趣。",{"type":24,"tag":57,"props":609,"children":610},{},[],{"type":24,"tag":612,"props":613,"children":615},"h1",{"id":614},"rust-3",[616],{"type":44,"value":617},"rust 3",{"type":24,"tag":619,"props":620,"children":622},"h2",{"id":621},"cve-2022-36114-1",[623],{"type":44,"value":624},"CVE-2022-36114 1",{"type":24,"tag":626,"props":627,"children":632},"cve-info",{":type":628,"cve":629,"to":630,":cwe":631},"2","CVE-2022-36114","https://nvd.nist.gov/vuln/detail/CVE-2022-36114","400",[633],{"type":24,"tag":40,"props":634,"children":635},{},[636],{"type":44,"value":637},"不受控制的资源消耗",{"type":24,"tag":40,"props":639,"children":640},{},[641,643,650,652,659,661,667,669,676],{"type":44,"value":642},"利用 Cargo 的 ",{"type":24,"tag":168,"props":644,"children":647},{"href":645,"rel":646},"https://doc.rust-lang.org/cargo/reference/build-scripts.html",[172],[648],{"type":44,"value":649},"build script",{"type":44,"value":651}," 在构建阶段编译第三方的非 Rust code，同时结合 ",{"type":24,"tag":168,"props":653,"children":656},{"href":654,"rel":655},"https://doc.rust-lang.org/book/ch20-05-macros.html#how-to-write-a-custom-derive-macro",[172],[657],{"type":44,"value":658},"procedural macros",{"type":44,"value":660},"，在执行 ",{"type":24,"tag":220,"props":662,"children":664},{"className":663},[],[665],{"type":44,"value":666},"cargo run",{"type":44,"value":668}," 的过程中触发了一个 ",{"type":24,"tag":168,"props":670,"children":673},{"href":671,"rel":672},"https://en.wikipedia.org/wiki/Zip_bomb",[172],[674],{"type":44,"value":675},"Zip Bomb",{"type":44,"value":677}," 行为。",{"type":24,"tag":40,"props":679,"children":680},{},[681,683,690],{"type":44,"value":682},"对于这个问题的修复，rust-lang 已经给出了一个 ",{"type":24,"tag":168,"props":684,"children":687},{"href":685,"rel":686},"https://github.com/rust-lang/wg-security-response/blob/4bbe734e6404ece6f4e85027564f8995d4ab70e0/patches/CVE-2022-36114/0001-CVE-2022-36114-limit-the-maximum-unpacked-size-of-a-.patch",[172],[688],{"type":44,"value":689},"补丁修复",{"type":44,"value":691}," Zip_bomb 的问题:",{"type":24,"tag":250,"props":693,"children":698},{"code":694,"language":695,"meta":8,"className":696},"// 在解压 .crate 文件（tar.gz）时，限制最多只能解压出 512MB 的内容。\n+const MAX_UNPACK_SIZE: u64 = 512 * 1024 * 1024;\n","c",[697],"language-c",[699],{"type":24,"tag":220,"props":700,"children":701},{"__ignoreMap":8},[702],{"type":44,"value":694},{"type":24,"tag":40,"props":704,"children":705},{},[706,708,714,716,723],{"type":44,"value":707},"同时引入了 ",{"type":24,"tag":220,"props":709,"children":711},{"className":710},[],[712],{"type":44,"value":713},"LimitErrorReader",{"type":44,"value":715},": 超过就抛出错误，避免资源被耗尽（比如磁盘写爆）。除此之外并没有对 macros、build 加以限制，只是建议尽可能的用 ",{"type":24,"tag":168,"props":717,"children":720},{"href":718,"rel":719},"https://crates.io/",[172],[721],{"type":44,"value":722},"crates",{"type":44,"value":724}," 上提交的 crate。",{"type":24,"tag":57,"props":726,"children":727},{},[],{"type":24,"tag":619,"props":729,"children":731},{"id":730},"cve-2023-40030-1",[732],{"type":44,"value":733},"CVE-2023-40030 1",{"type":24,"tag":626,"props":735,"children":740},{":type":736,"cve":737,"to":738,":cwe":739},"1","CVE-2023-40030","https://nvd.nist.gov/vuln/detail/cve-2023-40030","79",[741],{"type":24,"tag":40,"props":742,"children":743},{},[744,746],{"type":44,"value":745},"{OWASP TOP TEN}: 不恰当的网页生成输入中和 XSS",{"type":24,"tag":404,"props":747,"children":748},{},[],{"type":24,"tag":40,"props":750,"children":751},{},[752,754,760,762,769],{"type":44,"value":753},"看到这篇通告的时候，我就回想起为什么我看 ",{"type":24,"tag":220,"props":755,"children":757},{"className":756},[],[758],{"type":44,"value":759},"cargo build --timings",{"type":44,"value":761}," 的时候肿么没想到会有 CWE-79。",{"type":24,"tag":168,"props":763,"children":766},{"href":764,"rel":765},"https://doc.rust-lang.org/cargo/reference/timings.html",[172],[767],{"type":44,"value":768},"--timings",{"type":44,"value":770}," 是一个生成 build 时间的 html 报告。",{"type":24,"tag":40,"props":772,"children":773},{},[774,776,782,784,790,792,798,800,806],{"type":44,"value":775},"可以通过在 ",{"type":24,"tag":220,"props":777,"children":779},{"className":778},[],[780],{"type":44,"value":781},"Cargo.toml",{"type":44,"value":783}," 中加入 ",{"type":24,"tag":220,"props":785,"children":787},{"className":786},[],[788],{"type":44,"value":789},"features = [\"\u003Cimg src='' onerror=alert(0)\"]",{"type":44,"value":791}," 来触发一个 CWE-79, 因此对这个问题的修复就是，将之前的 ",{"type":24,"tag":220,"props":793,"children":795},{"className":794},[],[796],{"type":44,"value":797},"Warning",{"type":44,"value":799},", 换成了 ",{"type":24,"tag":220,"props":801,"children":803},{"className":802},[],[804],{"type":44,"value":805},"bail!",{"type":44,"value":807}," 机制。",{"type":24,"tag":328,"props":809,"children":810},{"type":511},[811],{"type":24,"tag":40,"props":812,"children":813},{},[814,819,821,828],{"type":24,"tag":220,"props":815,"children":817},{"className":816},[],[818],{"type":44,"value":805},{"type":44,"value":820}," 宏来自 ",{"type":24,"tag":168,"props":822,"children":825},{"href":823,"rel":824},"https://docs.rs/anyhow/latest/anyhow/macro.bail.html",[172],[826],{"type":44,"value":827},"anyhow",{"type":44,"value":829}," 用于方便地提前返回错误。",{"type":24,"tag":40,"props":831,"children":832},{},[833,835,842,844,850],{"type":44,"value":834},"可以看一下 ",{"type":24,"tag":168,"props":836,"children":839},{"href":837,"rel":838},"https://github.com/rust-lang/cargo/commit/9835622853f08be9a4b58ebe29dcec8f43b64b33#diff-99a8f4b284589e7db1aec698aa8f9ef9390f3ee3ecddc399dd6be1aa9ee00388L440-L446",[172],[840],{"type":44,"value":841},"fix pr",{"type":44,"value":843},"，非常有意思，比如 ",{"type":24,"tag":220,"props":845,"children":847},{"className":846},[],[848],{"type":44,"value":849},"validate_feature_name",{"type":44,"value":851}," 函数。",{"type":24,"tag":40,"props":853,"children":854},{},[855,857,863,865],{"type":44,"value":856},"原来：遇到非法 feature name，只输出 ",{"type":24,"tag":220,"props":858,"children":860},{"className":859},[],[861],{"type":44,"value":862},"warning",{"type":44,"value":864},"，流程继续。",{"type":24,"tag":404,"props":866,"children":867},{},[],{"type":24,"tag":250,"props":869,"children":871},{"code":870},"if let Some(ch) = chars.next() {Add commentMore actions\n        if !(unicode_xid::UnicodeXID::is_xid_start(ch) || ch == '_' || ch.is_digit(10)) {\n            config.shell().warn(&format!(\n                \"invalid character `{}` in feature `{}` in package {}, \\\n                the first character must be a Unicode XID start character or digit \\\n                (most letters or `_` or `0` to `9`)\\n\\\n                {}\",\n                ch, name, pkg_id, FUTURE\n            ))?;\n\n        }\n    }\n",[872],{"type":24,"tag":220,"props":873,"children":874},{"__ignoreMap":8},[875],{"type":44,"value":870},{"type":24,"tag":328,"props":877,"children":878},{"type":511},[879],{"type":24,"tag":40,"props":880,"children":881},{},[882],{"type":44,"value":883},"我本来想看看 2025-6-27 的 src/cargo/core/summary.rs 这个 fix pr 的区别。但我发现了一个流量密码，那就是 Rc → Arc, 问就是 Thread Safety！",{"type":24,"tag":40,"props":885,"children":886},{},[887,889,894],{"type":44,"value":888},"现在：遇到非法 feature name，直接 ",{"type":24,"tag":220,"props":890,"children":892},{"className":891},[],[893],{"type":44,"value":805},{"type":44,"value":895},"，构建中止，用户必须修正。",{"type":24,"tag":250,"props":897,"children":899},{"code":898}," if let Some(ch) = chars.next() {Add commentMore actions\n        if !(unicode_xid::UnicodeXID::is_xid_start(ch) || ch == '_' || ch.is_digit(10)) {\n            bail!(\n                \"invalid character `{}` in feature `{}` in package {}, \\\n                the first character must be a Unicode XID start character or digit \\\n                (most letters or `_` or `0` to `9`)\",\n                ch,\n                name,\n                pkg_id\n            );\n        }\n    }\n",[900],{"type":24,"tag":220,"props":901,"children":902},{"__ignoreMap":8},[903],{"type":44,"value":898},{"type":24,"tag":40,"props":905,"children":906},{},[907,909,915,917,923],{"type":44,"value":908},"在单元测试中，来验证 feature name 是否合法，例如只有 ",{"type":24,"tag":220,"props":910,"children":912},{"className":911},[],[913],{"type":44,"value":914},"is_ok()",{"type":44,"value":916}," 是合法的，而 ",{"type":24,"tag":220,"props":918,"children":920},{"className":919},[],[921],{"type":44,"value":922},"is_err()",{"type":44,"value":924}," 是不合法的：",{"type":24,"tag":250,"props":926,"children":928},{"code":927}," #[test]Add commentMore actions\n    fn valid_feature_names() {\n        let loc = CRATES_IO_INDEX.into_url().unwrap();\n        let source_id = SourceId::for_registry(&loc).unwrap();\n        let pkg_id = PackageId::new(\"foo\", \"1.0.0\", source_id).unwrap();\n\n        assert!(validate_feature_name(pkg_id, \"c++17\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"128bit\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"_foo\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"feat-name\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"feat_name\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"foo.bar\").is_ok());\n\n        assert!(validate_feature_name(pkg_id, \"+foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"-foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \".foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"foo:bar\").is_err());\n        assert!(validate_feature_name(pkg_id, \"foo?\").is_err());\n        assert!(validate_feature_name(pkg_id, \"?foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"ⒶⒷⒸ\").is_err());\n        assert!(validate_feature_name(pkg_id, \"a¼\").is_err());\n    }\n",[929],{"type":24,"tag":220,"props":930,"children":931},{"__ignoreMap":8},[932],{"type":44,"value":927},{"type":24,"tag":57,"props":934,"children":935},{},[],{"type":24,"tag":619,"props":937,"children":939},{"id":938},"cve-2023-41051-1",[940],{"type":44,"value":941},"CVE-2023-41051 1",{"type":24,"tag":626,"props":943,"children":947},{":type":736,"cve":944,"to":945,":cwe":946},"CVE-2023-51051","https://nvd.nist.gov/vuln/detail/cve-2023-41051","125",[948],{"type":24,"tag":40,"props":949,"children":950},{},[951],{"type":44,"value":952},"越界访问（out-of-bounds）: 访问了本不属于该内存区域的数据。",{"type":24,"tag":40,"props":954,"children":955},{},[956,963,965,971],{"type":24,"tag":168,"props":957,"children":960},{"href":958,"rel":959},"https://github.com/rust-vmm/vm-memory",[172],[961],{"type":44,"value":962},"vm-memory",{"type":44,"value":964}," 的 ",{"type":24,"tag":220,"props":966,"children":968},{"className":967},[],[969],{"type":44,"value":970},"VolatileMemory",{"type":44,"value":972}," 实现未对边界进行严格校验，导致有可能读取到非法的内存区域：",{"type":24,"tag":974,"props":975,"children":976},"ol",{},[977,989],{"type":24,"tag":978,"props":979,"children":980},"li",{},[981,987],{"type":24,"tag":220,"props":982,"children":984},{"className":983},[],[985],{"type":44,"value":986},"VolatileMemory::get_slice",{"type":44,"value":988},": 返回一段“易失性切片”（VolatileSlice），用于后续的底层操作",{"type":24,"tag":978,"props":990,"children":991},{},[992,998],{"type":24,"tag":220,"props":993,"children":995},{"className":994},[],[996],{"type":44,"value":997},"VolatileMemory::read/write",{"type":44,"value":999},": 直接从这块内存读/写数据，保证每次都实际发生内存访问",{"type":24,"tag":40,"props":1001,"children":1002},{},[1003],{"type":44,"value":1004},"VolatileMemory trait 就是定义了一套访问“虚拟机物理内存”或“特殊硬件内存区域”的低层接口，保证每次读写都真实发生，且不被编译器优化。它让不同的底层实现都能用统一的 trait 操作。",{"type":24,"tag":40,"props":1006,"children":1007},{},[1008,1010,1016,1018,1024],{"type":44,"value":1009},"但问题来了，这个通告并不涉及 ",{"type":24,"tag":220,"props":1011,"children":1013},{"className":1012},[],[1014],{"type":44,"value":1015},"read/write",{"type":44,"value":1017},"，更多的是 ",{"type":24,"tag":220,"props":1019,"children":1021},{"className":1020},[],[1022],{"type":44,"value":1023},"get_slice",{"type":44,"value":1025}," 方法，例如：",{"type":24,"tag":974,"props":1027,"children":1028},{},[1029,1038,1047,1056,1065],{"type":24,"tag":978,"props":1030,"children":1031},{},[1032],{"type":24,"tag":220,"props":1033,"children":1035},{"className":1034},[],[1036],{"type":44,"value":1037},"get_atomic_ref",{"type":24,"tag":978,"props":1039,"children":1040},{},[1041],{"type":24,"tag":220,"props":1042,"children":1044},{"className":1043},[],[1045],{"type":44,"value":1046},"aligned_as_ref",{"type":24,"tag":978,"props":1048,"children":1049},{},[1050],{"type":24,"tag":220,"props":1051,"children":1053},{"className":1052},[],[1054],{"type":44,"value":1055},"aligned_as_mut",{"type":24,"tag":978,"props":1057,"children":1058},{},[1059],{"type":24,"tag":220,"props":1060,"children":1062},{"className":1061},[],[1063],{"type":44,"value":1064},"get_ref",{"type":24,"tag":978,"props":1066,"children":1067},{},[1068],{"type":24,"tag":220,"props":1069,"children":1071},{"className":1070},[],[1072],{"type":44,"value":1073},"get_array_ref",{"type":24,"tag":40,"props":1075,"children":1076},{},[1077,1079,1085,1087,1093],{"type":44,"value":1078},"上述方法有个共同点，都是利用 ",{"type":24,"tag":220,"props":1080,"children":1082},{"className":1081},[],[1083],{"type":44,"value":1084},"ref",{"type":44,"value":1086}," 类方法引起的。它们都尝试返回指向底层内存的 Rust 类型引用（如 &T、",{"type":24,"tag":220,"props":1088,"children":1090},{"className":1089},[],[1091],{"type":44,"value":1092},"&[T]",{"type":44,"value":1094}," 等），而不是直接读写原始字节数据。它们的实现通常会调用 get_slice，假设返回的内存区域长度足够大。",{"type":24,"tag":40,"props":1096,"children":1097},{},[1098],{"type":44,"value":1099},"如果自定义实现的 get_slice 返回的切片长度不足，就会导致这些 ref 方法产生越界引用，造成内存安全风险。例如：",{"type":24,"tag":974,"props":1101,"children":1102},{},[1103,1108,1113],{"type":24,"tag":978,"props":1104,"children":1105},{},[1106],{"type":44,"value":1107},"这些方法假设 get_slice 返回的 VolatileSlice 长度是你要求的大小（比如 T 是 u32，就要 4 字节）。",{"type":24,"tag":978,"props":1109,"children":1110},{},[1111],{"type":44,"value":1112},"如果自定义实现的 get_slice 返回的 VolatileSlice 比你要求的短（比如只返回了2字节）",{"type":24,"tag":978,"props":1114,"children":1115},{},[1116],{"type":44,"value":1117},"这些方法还是会照常把这块内存强转成 &T，这时你访问 &T 时就可能会读到超出实际内存范围以外的内容",{"type":24,"tag":40,"props":1119,"children":1120},{},[1121,1123,1129],{"type":44,"value":1122},"仔细欣赏 ",{"type":24,"tag":168,"props":1124,"children":1127},{"href":1125,"rel":1126},"https://github.com/rust-vmm/vm-memory/commit/aff1dd4a5259f7deba56692840f7a2d9ca34c9c8#diff-0870facad91de878abbdf4dc43212b8de558021cf0971f62148c2cab381bd150R109-R275",[172],[1128],{"type":44,"value":841},{"type":44,"value":1130}," 你会发现：",{"type":24,"tag":40,"props":1132,"children":1133},{},[1134,1136,1142,1144,1149,1151,1157],{"type":44,"value":1135},"这些方法内部，都会调用 ",{"type":24,"tag":220,"props":1137,"children":1139},{"className":1138},[],[1140],{"type":44,"value":1141},"get_slice(offset, count)",{"type":44,"value":1143}," 拿到一块内存切片，然后把它 reinterpret_cast 成你要的类型引用。因此给 ",{"type":24,"tag":220,"props":1145,"children":1147},{"className":1146},[],[1148],{"type":44,"value":1023},{"type":44,"value":1150}," 加上 ",{"type":24,"tag":220,"props":1152,"children":1154},{"className":1153},[],[1155],{"type":44,"value":1156},"assert_eq!",{"type":44,"value":1158}," 就意味着：",{"type":24,"tag":40,"props":1160,"children":1161},{},[1162],{"type":44,"value":1163},"“如果你要 8 字节引用，必须实际拿到 8 字节的内存切片，否则直接 panic，不做 unsafe 操作！”",{"type":24,"tag":57,"props":1165,"children":1166},{},[],{"type":24,"tag":619,"props":1168,"children":1170},{"id":1169},"cve-2023-38497-1",[1171],{"type":44,"value":1172},"CVE-2023-38497 1",{"type":24,"tag":626,"props":1174,"children":1179},{":type":1175,"cve":1176,"to":1177,"cwe":1178},"3","CVE-2023-38497","https://nvd.nist.gov/vuln/detail/cve-2023-38497","278,732",[1180,1188],{"type":24,"tag":40,"props":1181,"children":1182},{},[1183,1185],{"type":44,"value":1184},"278: 不安全的保留继承权限",{"type":24,"tag":404,"props":1186,"children":1187},{},[],{"type":24,"tag":1189,"props":1190,"children":1191},"ul",{},[1192],{"type":24,"tag":978,"props":1193,"children":1194},{},[1195],{"type":44,"value":1196},"732: 关键资源的权限分配错误",{"type":24,"tag":40,"props":1198,"children":1199},{},[1200,1202,1209,1211,1217,1219,1224,1226,1231,1233,1239,1241,1247],{"type":44,"value":1201},"CWE-278 还是较为冷门的，毕竟只有一个参考，既 ",{"type":24,"tag":168,"props":1203,"children":1206},{"href":1204,"rel":1205},"https://www.cve.org/CVERecord?id=CVE-2005-1724",[172],[1207],{"type":44,"value":1208},"CVE-2005-1724",{"type":44,"value":1210},"。CWE-278 这个类的漏洞常见表现之一就是 ",{"type":24,"tag":1212,"props":1213,"children":1214},"strong",{},[1215],{"type":44,"value":1216},"权限限制”",{"type":44,"value":1218},"。总的来说 umask 是 ",{"type":24,"tag":1212,"props":1220,"children":1221},{},[1222],{"type":44,"value":1223},"限制新建文件或目录默认权限的一个机制。",{"type":44,"value":1225},"，可以看看 ",{"type":24,"tag":1227,"props":1228,"children":1229},"sup",{},[1230],{"type":44,"value":736},{"type":44,"value":1232},"，我清晰记得有时候需要执行什么 ",{"type":24,"tag":220,"props":1234,"children":1236},{"className":1235},[],[1237],{"type":44,"value":1238},"bash",{"type":44,"value":1240}," 脚本的时候，会使用 ",{"type":24,"tag":220,"props":1242,"children":1244},{"className":1243},[],[1245],{"type":44,"value":1246},"chmod 777",{"type":44,"value":1248},", 要不然运行不了。",{"type":24,"tag":328,"props":1250,"children":1251},{"type":511},[1252,1262,1267,1288,1296],{"type":24,"tag":40,"props":1253,"children":1254},{},[1255,1257],{"type":44,"value":1256},"CVE-2005-1724 是一个典型的“配置安全限制无效”型漏洞，使得 NFS 导出的目录被所有人都能访问，造成权限绕过和潜在的数据泄露/篡改风险。其归类于 CWE-278 ",{"type":24,"tag":1212,"props":1258,"children":1259},{},[1260],{"type":44,"value":1261},"属于权限/访问控制失效问题。",{"type":24,"tag":40,"props":1263,"children":1264},{},[1265],{"type":44,"value":1266},"而 CWE-732 又是 CWE-278 的子类，因此会有两个 CWE 的分配。",{"type":24,"tag":40,"props":1268,"children":1269},{},[1270,1272,1278,1280,1286],{"type":44,"value":1271},"比如 CVE-2005-1724 在正常情况下，在导出（export）NFS 文件系统时，通常会用 ",{"type":24,"tag":220,"props":1273,"children":1275},{"className":1274},[],[1276],{"type":44,"value":1277},"-network",{"type":44,"value":1279}," 和 ",{"type":24,"tag":220,"props":1281,"children":1283},{"className":1282},[],[1284],{"type":44,"value":1285},"-mask",{"type":44,"value":1287},"：",{"type":24,"tag":250,"props":1289,"children":1291},{"code":1290},"/some/dir -network 192.168.1.0 -mask 255.255.255.0\n",[1292],{"type":24,"tag":220,"props":1293,"children":1294},{"__ignoreMap":8},[1295],{"type":44,"value":1290},{"type":24,"tag":40,"props":1297,"children":1298},{},[1299],{"type":44,"value":1300},"这样本应只有 192.168.1.0/24 网络内的主机可以访问该目录。但在 Mac OS X 10.4.x 的 NFS 服务实现没有正确处理/生效这些参数。因此构成了 CWE-278",{"type":24,"tag":40,"props":1302,"children":1303},{},[1304,1306,1311,1313,1319],{"type":44,"value":1305},"要想理解本次的 CVE，我们首先需要理解标题 ",{"type":24,"tag":1212,"props":1307,"children":1308},{},[1309],{"type":44,"value":1310},"Cargo 在解压 crate 包时未按照 umask 限制文件权限",{"type":44,"value":1312},"。而 ",{"type":24,"tag":220,"props":1314,"children":1316},{"className":1315},[],[1317],{"type":44,"value":1318},"umask",{"type":44,"value":1320}," 是默认权限，翻译成人话就是：",{"type":24,"tag":1322,"props":1323,"children":1325},"text-tip",{"type":1324},"big",[1326],{"type":24,"tag":40,"props":1327,"children":1328},{},[1329,1331,1337,1339,1342],{"type":44,"value":1330},"Cargo 在解压 crate 包时，没有按照 umask 分个默认的权限。攻击者可以利用这一点也就是 ",{"type":24,"tag":220,"props":1332,"children":1334},{"className":1333},[],[1335],{"type":44,"value":1336},"777",{"type":44,"value":1338}," 权限构建攻击脚本。",{"type":24,"tag":404,"props":1340,"children":1341},{},[],{"type":44,"value":1343},"\n↑ 可能不是很严谨",{"type":24,"tag":40,"props":1345,"children":1346},{},[1347,1349],{"type":44,"value":1348},"过去 Cargo 解压 .crate 包时，直接采用了压缩包内的文件权限（比如 777/666），",{"type":24,"tag":1212,"props":1350,"children":1351},{},[1352],{"type":44,"value":1353},"没有结合操作系统的 umask，导致解压后的文件权限过宽，其他本地用户可能能写入、篡改这些源码文件。",{"type":24,"tag":40,"props":1355,"children":1356},{},[1357,1359,1365,1367,1373,1375,1380],{"type":44,"value":1358},"在 ",{"type":24,"tag":220,"props":1360,"children":1362},{"className":1361},[],[1363],{"type":44,"value":1364},"src/cargo/util/mod.rs",{"type":44,"value":1366}," 中新增了 ",{"type":24,"tag":220,"props":1368,"children":1370},{"className":1369},[],[1371],{"type":44,"value":1372},"get_umask()",{"type":44,"value":1374}," 函数。以在解压文件时，强制用 ",{"type":24,"tag":220,"props":1376,"children":1378},{"className":1377},[],[1379],{"type":44,"value":1318},{"type":44,"value":1381}," 限制新文件的权限。：",{"type":24,"tag":250,"props":1383,"children":1385},{"code":1384},"#[cfg(unix)]\npub fn get_umask() -> u32 {\n    use std::sync::OnceLock;\n    static UMASK: OnceLock\u003Clibc::mode_t> = OnceLock::new();\n    // SAFETY: Syscalls are unsafe. Calling `umask` twice is even unsafer for\n    // multithreading program, since it doesn't provide a way to retrive the\n    // value without modifications. We use a static `OnceLock` here to ensure\n    // it only gets call once during the entire program lifetime.\n    *UMASK.get_or_init(|| unsafe {\n        let umask = libc::umask(0o022);\n        libc::umask(umask);\n        umask\n    }) as u32 // it is u16 on macos\n}\n",[1386],{"type":24,"tag":220,"props":1387,"children":1388},{"__ignoreMap":8},[1389],{"type":44,"value":1384},{"type":24,"tag":40,"props":1391,"children":1392},{},[1393],{"type":44,"value":1394},"以及很有艺术性的一行 code:",{"type":24,"tag":250,"props":1396,"children":1398},{"code":1397},"fs::set_permissions(path, Permissions::from_mode(final_mode)).unwrap();\n",[1399],{"type":24,"tag":220,"props":1400,"children":1401},{"__ignoreMap":8},[1402],{"type":44,"value":1397},{"type":24,"tag":40,"props":1404,"children":1405},{},[1406,1408,1414],{"type":44,"value":1407},"解压 crate 时，读取每个文件的原始权限（如 0o777），实际写入磁盘时，会用 原始权限 & ",{"type":24,"tag":220,"props":1409,"children":1411},{"className":1410},[],[1412],{"type":44,"value":1413},"!umask",{"type":44,"value":1415}," 得到最终权限，再 chmod 到文件上:",{"type":24,"tag":250,"props":1417,"children":1419},{"code":1418},"assert_eq!(metadata.mode() & 0o777, 0o644 & !umask);\n",[1420],{"type":24,"tag":220,"props":1421,"children":1422},{"__ignoreMap":8},[1423],{"type":44,"value":1418},{"type":24,"tag":1425,"props":1426,"children":1429},"div",{"id":1427,"className":1428},"refer-anchor-1",[1084],[1430],{"type":24,"tag":1189,"props":1431,"children":1432},{},[1433],{"type":24,"tag":978,"props":1434,"children":1435},{},[1436,1441,1443],{"type":24,"tag":1437,"props":1438,"children":1439},"span",{},[1440],{"type":44,"value":736},{"type":44,"value":1442}," ",{"type":24,"tag":168,"props":1444,"children":1447},{"href":1445,"rel":1446},"https://langzi989.github.io/2017/09/13/Linux%E4%B8%ADumash%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/",[172],[1448],{"type":44,"value":1445},{"title":8,"searchDepth":112,"depth":112,"links":1450},[1451,1452,1453,1454],{"id":621,"depth":112,"text":624},{"id":730,"depth":112,"text":733},{"id":938,"depth":112,"text":941},{"id":1169,"depth":112,"text":1172},"content:plan:security:cve-learn.md","plan/security/cve-learn.md",1755869942539]