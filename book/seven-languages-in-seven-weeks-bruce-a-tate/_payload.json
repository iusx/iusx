[{"data":1,"prerenderedAt":1007},["Reactive",2],{"content-query-EF220RG78d":3},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":7,"director":9,"time":10,"img":11,"plan":12,"body":13,"_type":1002,"_id":1003,"_source":1004,"_file":1005,"_extension":1006},"/book/seven-languages-in-seven-weeks-bruce-a-tate","book",false,"","Seven Languages in Seven Weeks","Bruce A. Tate","2025.01.08","08/1.png","01",{"type":14,"children":15,"toc":999},"root",[16],{"type":17,"tag":18,"props":19,"children":24},"element","book-content",{":by":20,":img":21,":plan":22,":title":23},"director","img","plan","title",[25,30,38,44,49,54,59,64,69,85,90,94,98,104,109,114,119,132,141,146,151,156,161,169,174,177,181,186,194,265,270,280,293,307,310,315,349,354,359,367,372,380,385,387,493,496,510,518,541,594,599,602,607,615,651,654,677,691,699,718,726,744,757,765,783,788,796,824,859,862,903,911,916,924,929,937],{"type":17,"tag":26,"props":27,"children":29},"text-title",{":t":28},"回顾下自己的十年经历",[],{"type":17,"tag":31,"props":32,"children":34},"h1",{"id":33},"总结自己-0",[35],{"type":36,"value":37},"text","总结自己 0",{"type":17,"tag":39,"props":40,"children":41},"p",{},[42],{"type":36,"value":43},"如果从 2015 那个对计算机懵懂的我来说，到 2025 年已经过了十年。可以说对计算机方面拥有了十年的兴趣。假如从 2018 我第一个漏洞算起，至今已经过了七年。再从 2020 我打算学习设计开始，已经过了五年。",{"type":17,"tag":39,"props":45,"children":46},{},[47],{"type":36,"value":48},"我觉得自己有很大的缺陷，基础不是特别牢固。之前做全栈的时候就有朋友指出我的基础不是特别好，最常说的话就是：“基础不牢，地动山摇”。做出的项目只是看起来很不错，但如果深挖细节，性能的处理就有一小部分的问题。虽然我总以 \"安全爱好者\" 作为 title，但我貌似并没有发现过比较知名且威胁较大的漏洞。",{"type":17,"tag":39,"props":50,"children":51},{},[52],{"type":36,"value":53},"更不用说什么 EDUSRC、MSRC、TSRC 这些了，仅仅是公益 SRC 和 CNVD 以及 Hackerone 这些，我所发现到的或提交的更多是大佬吃剩的边角料，甚至是不屑一顾的。但我之前缺奉为瑰宝，以筑起我那脆弱且不堪一击的自信。",{"type":17,"tag":39,"props":55,"children":56},{},[57],{"type":36,"value":58},"我还是比较庆幸自己无论做什么起码都能有一点成就的。虽然这个成就不高，但足以出去找个班上不至于饿死。做设计会有很多朋友支援下我;做安全拿到了漏洞赏金（虽然不多）;做全栈起码能混到小公司 offer；做舆情分析的时候，能被专业的人发现，引导我继续做下去。所以我还是比较幸运的，起码有点东西，虽然不多。",{"type":17,"tag":39,"props":60,"children":61},{},[62],{"type":36,"value":63},"看完这本书后，我觉得是时候筹备下我的代表作了。因为之前很多人觉得我是臭做设计的，甚至还有人说我是个臭美工！完全无视掉了我全栈和安全架构方面的才华。所以在这之后，我会筹备一个全栈的代表作；另一个是安全架构的代表作。至于设计的代表作已经有了，再往后无非是作品。我觉得代表作这个东西首先是能给人用的，其次才是给人看的；这样说服力大一点。",{"type":17,"tag":39,"props":65,"children":66},{},[67],{"type":36,"value":68},"之所以看这本书。首先是我觉得自己 Code 方面还是比较有问题，写 Code 总是很磨叽，和那种一写 code 就是写一天的有很大的差距。其次是我承认是被这本书的标题所吸引，作者懂不懂语言不重要，但他一定懂营销。我还不知道这本书有没有被 Percipio 收入，反正我 ACM 会员资格是到期了。这里我想吐槽下 ACM 的续费规则，我有钱的时候是想提前续费的，但 ACM 只能是快过期的时候才能续费。等真快过期的时候，我反而没钱续费了。",{"type":17,"tag":39,"props":70,"children":71},{},[72,74,83],{"type":36,"value":73},"无奈只能找盗版 PDF 来看。这里强烈推荐 ",{"type":17,"tag":75,"props":76,"children":80},"a",{"href":77,"rel":78},"https://skim-app.sourceforge.io/",[79],"nofollow",[81],{"type":36,"value":82},"Skip",{"type":36,"value":84}," 我觉得作为一款 PDF 阅读器来说，做到了快、文字能复制、复制的文字和 PDF 内容是一样的这种难度比较高的水准。甚至还是开源的，简直真的是太伟大了。我用过比较多的 PDF 阅读器，比如 Adobe Acrobat、PDF Expert。甚至是 福昕 PDF ，WPS PDF，给我的感觉都是卡顿还有比较大的复制问题，就是复制的文字和 PDF 里面的文字不一样。",{"type":17,"tag":39,"props":86,"children":87},{},[88],{"type":36,"value":89},"和 Chrome 等浏览器自带的 PDF 阅读器比我认为无非是多了个签名和画线、笔记类的扩充。忘记了阅读的这第一要素，特别是像我这种 English 比较差需要 Copy 文字翻译的，比较不由好。所以对于 Skip 我是强烈推荐的。",{"type":17,"tag":91,"props":92,"children":93},"hr",{},[],{"type":17,"tag":26,"props":95,"children":97},{":t":96},"作者致谢",[],{"type":17,"tag":31,"props":99,"children":101},{"id":100},"致谢-2",[102],{"type":36,"value":103},"致谢 2",{"type":17,"tag":39,"props":105,"children":106},{},[107],{"type":36,"value":108},"又到了一个非常具有代表性的篇幅，也就是：“What Readers Are Saying About Seven Languages in Seven Weeks” 你会看到国内那种类似 xxx 专家，xxx 公司 xxx 总监 xxx 团队 xxx 实验室对某本书的友情肯定和推荐。你别说你还真别说，如果这本书讲的是思维逻辑和拆解，那确实是很不错的。但如果是技术性的，那可能从 2010 年发售至今 2025 年历经十多年的发展，技术也可能会淘汰，语法可能会变，但逻辑和思维，依然是那套惯式。",{"type":17,"tag":39,"props":110,"children":111},{},[112],{"type":36,"value":113},"在这本书的前言中，作者透露出在 2009~2010 的时间段经历了很多人生的体验。例如他那 40 多岁的弟弟经历了心脏搭桥手术；三月底，他的妹妹确诊的乳腺癌；同月，他的母亲确诊晚期癌症。短短几天就去世了。",{"type":17,"tag":39,"props":115,"children":116},{},[117],{"type":36,"value":118},"在这期间内，作者虽然伤心欲绝。但他回想起母亲的点点滴滴，与母亲的每次相处，特别是在作者离家前上了母亲的几节美术课，虽然作者的画很糟糕。但母亲总能将破碎不堪的画幅玩就回来成为一件精美的艺术作品。这需要天赋和经验才能将一副处在崩溃边缘的画作挽救回来。",{"type":17,"tag":39,"props":120,"children":121},{},[122,124,130],{"type":36,"value":123},"不知你是否接触过绘画、美术。在我初中最后一年时，我因成绩垫底转到了美术班，我比较遗憾没有接触到绘画的全过程。绘画这门艺术，你需要经历过前期的 ",{"type":17,"tag":125,"props":126,"children":127},"strong",{},[128],{"type":36,"value":129},"构图、草稿、描边、上色、光影",{"type":36,"value":131}," 如果你是素描类的作品，还需要经历前期的封边到最后将美纹纸胶带撕下的过程。在作画前期，你需要构思好要画什么，然后通过一些技巧完成构图。比如透视、人体结构等。然后就是用铅笔打草稿，打草稿的过程要求一笔带过，如果不能一笔，那就需要勤加练习。所以在美术课中你会看到一开始要求画线，无论板绘还是素描都是这样。",{"type":17,"tag":133,"props":134,"children":135},"text-tip",{},[136],{"type":17,"tag":39,"props":137,"children":138},{},[139],{"type":36,"value":140},"美术一般讲究人较多，水彩纸要用 Arches、素描纸要用 Canson、铅笔要用 Marie's，高级点的铅笔还有 Derwent。水彩颜料要用 Winsor & Newton、白夜，一张不起眼的纸每张也许都是几块钱的。",{"type":17,"tag":39,"props":142,"children":143},{},[144],{"type":36,"value":145},"学会画线后，就需要学会光影。光的照射范围和影子，在素描中，只有黑色和白色，因此需要用到擦纸笔甚至可塑橡皮来实现。当然有些功力比较深的喜欢用手进行擦来延续黑色。",{"type":17,"tag":39,"props":147,"children":148},{},[149],{"type":36,"value":150},"如果你是走那种水彩、或者板绘，数字传媒的。可能会经历构图、草稿、描边的这个过程。然后就是上色、光影的应用。所以这个阶段，就和开发很类似。前期实现一个功能，然后用一个简陋的 GUi 进行交互。后期再将 GUi 进行美化和布局的排列。那么恭喜你，你已经成为了一个优秀的 Web 开发工程师，俗称前端。",{"type":17,"tag":39,"props":152,"children":153},{},[154],{"type":36,"value":155},"但对于后端，更多的是 code 和 code 之间功能的划分，每个 code 负责不同的功能，最后连点成线，打通 API 和 GUI 之间的联系。组成一个能跑的 base 或 GUI 程序，或者输出一个接口作为 API。那么恭喜你，你成为了软件开发工程师或后端工程师。",{"type":17,"tag":39,"props":157,"children":158},{},[159],{"type":36,"value":160},"一个简简单单的前言，就透露出作者对于软件设计和软件工程的功底。即使过了十多年，这套逻辑和拆解也亦然可以套在现代软件工程中，如果读者理解过 MVC 架构，那简直就是异曲同工。",{"type":17,"tag":133,"props":162,"children":163},{},[164],{"type":17,"tag":39,"props":165,"children":166},{},[167],{"type":36,"value":168},"When I told my mother that I would dedicate this book to her, she\nsaid that she would like that, but she had nothing to do with com-\nputers. That is true enough. The very thought of Windows would leave\nher helpless. But Mom, you have had everything to do with me. Your\nwell-timed words of encouragement inspired me, your love of creativity\nshaped me, and your enthusiasm and love of life guide me even now.\nAs I think about these experiences, I can’t help but feel a little better\nand a little stronger because I, too, am a canvas shaped by the master.\nThis book is dedicated with love to Lynda Lyle Tate, 1936–2010.",{"type":17,"tag":39,"props":170,"children":171},{},[172],{"type":36,"value":173},"所以在前沿的结尾，作者说母亲对作者的影响很大。这无关他的目前连 Windows 都不会用，而是传授给了儿子拆解的艺术。看一个产品如果从成品看肯定是高攀不起的，但如果一步一步的拆解，一个一个的功能实现，就会发现也不是那么的特别高攀不起。",{"type":17,"tag":91,"props":175,"children":176},{},[],{"type":17,"tag":26,"props":178,"children":180},{":t":179},"作者的致谢",[],{"type":17,"tag":39,"props":182,"children":183},{},[184],{"type":36,"value":185},"在致谢阶段，作者展示出了这本书的含金量，甚至比开篇那几位挂名推荐的还重量级。首先映入眼帘的是 Ruby community：",{"type":17,"tag":133,"props":187,"children":188},{},[189],{"type":17,"tag":39,"props":190,"children":191},{},[192],{"type":36,"value":193},"*相信能在 Wikipedia 中留名的实力。",{"type":17,"tag":195,"props":196,"children":197},"ol",{},[198,211,232,253],{"type":17,"tag":199,"props":200,"children":201},"li",{},[202,209],{"type":17,"tag":75,"props":203,"children":206},{"href":204,"rel":205},"https://ja.wikipedia.org/wiki/%E3%81%BE%E3%81%A4%E3%82%82%E3%81%A8%E3%82%86%E3%81%8D%E3%81%B2%E3%82%8D",[79],[207],{"type":36,"value":208},"松本行弘(Matz)",{"type":36,"value":210}," 他最著名的是 Ruby 编程语言及其原始参考实现 Matz 的 Ruby 解释器的首席设计师；",{"type":17,"tag":199,"props":212,"children":213},{},[214,221,223,230],{"type":17,"tag":75,"props":215,"children":218},{"href":216,"rel":217},"https://github.com/headius",[79],[219],{"type":36,"value":220},"Charles Nutter",{"type":36,"value":222},": ",{"type":17,"tag":75,"props":224,"children":227},{"href":225,"rel":226},"https://en.wikipedia.org/wiki/JRuby",[79],[228],{"type":36,"value":229},"Jruby",{"type":36,"value":231}," 的作者之一，能在 Java 和 Ruby 代码之间进行完全双向访问（类似于 Python 语言的 Jython ）。",{"type":17,"tag":199,"props":233,"children":234},{},[235,242,244,251],{"type":17,"tag":75,"props":236,"children":239},{"href":237,"rel":238},"https://github.com/evanphx",[79],[240],{"type":36,"value":241},"Evan Phoenix",{"type":36,"value":243}," : ",{"type":17,"tag":75,"props":245,"children":248},{"href":246,"rel":247},"https://en.wikipedia.org/wiki/Rubinius",[79],[249],{"type":36,"value":250},"Rubinius",{"type":36,"value":252}," 的作者；旨在 “为运行 Ruby 代码提供丰富、高性能的环境”",{"type":17,"tag":199,"props":254,"children":255},{},[256,263],{"type":17,"tag":75,"props":257,"children":260},{"href":258,"rel":259},"https://en.wikipedia.org/wiki/Tim_Bray",[79],[261],{"type":36,"value":262},"Tim Bray",{"type":36,"value":264},": 原始 XML 规范的共同作者之一;",{"type":17,"tag":39,"props":266,"children":267},{},[268],{"type":36,"value":269},"Ruby 以完全面向对象、可读性和简洁性、灵活性而知名。例如灵活的语法与动态特性：",{"type":17,"tag":271,"props":272,"children":274},"pre",{"code":273},"class Greeter\n  def initialize(name)\n    @name = name.capitalize\n  end\nend\n\n# 动态添加方法\nGreeter.define_method(:greet) do\n  \"Hello, #{@name}!\"\nend\n\ng = Greeter.new(\"ruby\")\nputs g.greet\n# 输出：Hello, Ruby!\n",[275],{"type":17,"tag":276,"props":277,"children":278},"code",{"__ignoreMap":7},[279],{"type":36,"value":273},{"type":17,"tag":39,"props":281,"children":282},{},[283,285,291],{"type":36,"value":284},"但看输出 ",{"type":17,"tag":276,"props":286,"children":288},{"className":287},[],[289],{"type":36,"value":290},"Hello, Ruby!",{"type":36,"value":292}," 的这个过程就感觉元编程也是 ruby 的特点之一。",{"type":17,"tag":39,"props":294,"children":295},{},[296,298,305],{"type":36,"value":297},"我之前浏览过 ",{"type":17,"tag":75,"props":299,"children":302},{"href":300,"rel":301},"https://ruby-china.org/",[79],[303],{"type":36,"value":304},"Ruby China",{"type":36,"value":306},"，那时候我有一个对 Ruby 的问题。但 Ruby China community 有一个会员限制。注册完需要三个月后才能发帖或发消息，结果就是一天后我的问题被我自己解决了，之后我就再也没有浏览过这个社区。",{"type":17,"tag":91,"props":308,"children":309},{},[],{"type":17,"tag":39,"props":311,"children":312},{},[313],{"type":36,"value":314},"接下来的就是 Io community, 并不是信息学奥林匹克竞赛 (英语：Olympiad in Informatics，简称：OI) 的那个 IO。而是 Io Programming Language：",{"type":17,"tag":195,"props":316,"children":317},{},[318,337],{"type":17,"tag":199,"props":319,"children":320},{},[321,328,329,335],{"type":17,"tag":75,"props":322,"children":325},{"href":323,"rel":324},"https://github.com/jeremytregunna",[79],[326],{"type":36,"value":327},"Jeremy Tregunna",{"type":36,"value":222},{"type":17,"tag":75,"props":330,"children":332},{"href":323,"rel":331},[79],[333],{"type":36,"value":334},"ioLang",{"type":36,"value":336}," 的作者之一;Io 的目标是探索概念统一和动态语言，因此权衡往往倾向于简单性和灵活性而不是性能。",{"type":17,"tag":199,"props":338,"children":339},{},[340,347],{"type":17,"tag":75,"props":341,"children":344},{"href":342,"rel":343},"https://github.com/stevedekorte",[79],[345],{"type":36,"value":346},"Steve Dekorte",{"type":36,"value":348},": Iolang 的作者之一；Iolang 于 2002 年创建，当时他试图用他的语言 Cel 来帮助朋友 Dru Nelson。他发现自己确实不太了解语言的工作原理，并开始编写一种小型语言来更好地理解问题。(ps: 我什么时候才能拥有这样的好朋友)",{"type":17,"tag":39,"props":350,"children":351},{},[352],{"type":36,"value":353},"光从描述，我已经对 Iolang 开始有兴趣了，特别句尾处的: \"You captured the imagination of the beta readers and cre-\nated the favorite language of many of them.(你激发并测试了读者的想象力，同时创造了许多人最喜欢的语言。)\"",{"type":17,"tag":39,"props":355,"children":356},{},[357],{"type":36,"value":358},"Iolang 作为动态语言，在类型阶段就比较宽松，比较灵活，例如:",{"type":17,"tag":271,"props":360,"children":362},{"code":361},"x = 42        # 整数\nx = \"Hello\"   # 重新赋值为字符串\n",[363],{"type":17,"tag":276,"props":364,"children":365},{"__ignoreMap":7},[366],{"type":36,"value":361},{"type":17,"tag":39,"props":368,"children":369},{},[370],{"type":36,"value":371},"而静态语言呢，类似 Typescript 这种类型比较强硬的：",{"type":17,"tag":271,"props":373,"children":375},{"code":374},"let x: number = 42;\nx = \"Hello\"; // 编译错误：类型不匹配\n",[376],{"type":17,"tag":276,"props":377,"children":378},{"__ignoreMap":7},[379],{"type":36,"value":374},{"type":17,"tag":39,"props":381,"children":382},{},[383],{"type":36,"value":384},"当然他们各具特点，灵活性、性能各有千秋，适应的项目需求也不同，有的适合大型的，多人合作开发，有的适合写个脚本或前期功能论证阶段的原型设计。动态语言的刻板印象就是 易上手、Code 简洁、类型宽松、快速开发、运行时发现等作为优点。我们列举几个常见的静态和动态语言：",{"type":36,"value":386},"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",{"type":17,"tag":388,"props":389,"children":390},"table",{},[391,410],{"type":17,"tag":392,"props":393,"children":394},"thead",{},[395],{"type":17,"tag":396,"props":397,"children":398},"tr",{},[399,405],{"type":17,"tag":400,"props":401,"children":402},"th",{},[403],{"type":36,"value":404},"动态语言",{"type":17,"tag":400,"props":406,"children":407},{},[408],{"type":36,"value":409},"静态语言",{"type":17,"tag":411,"props":412,"children":413},"tbody",{},[414,428,441,454,467,480],{"type":17,"tag":396,"props":415,"children":416},{},[417,423],{"type":17,"tag":418,"props":419,"children":420},"td",{},[421],{"type":36,"value":422},"Python",{"type":17,"tag":418,"props":424,"children":425},{},[426],{"type":36,"value":427},"C/C++",{"type":17,"tag":396,"props":429,"children":430},{},[431,436],{"type":17,"tag":418,"props":432,"children":433},{},[434],{"type":36,"value":435},"Ruby",{"type":17,"tag":418,"props":437,"children":438},{},[439],{"type":36,"value":440},"Java",{"type":17,"tag":396,"props":442,"children":443},{},[444,449],{"type":17,"tag":418,"props":445,"children":446},{},[447],{"type":36,"value":448},"JavaScript",{"type":17,"tag":418,"props":450,"children":451},{},[452],{"type":36,"value":453},"Go",{"type":17,"tag":396,"props":455,"children":456},{},[457,462],{"type":17,"tag":418,"props":458,"children":459},{},[460],{"type":36,"value":461},"PHP",{"type":17,"tag":418,"props":463,"children":464},{},[465],{"type":36,"value":466},"TypeScript",{"type":17,"tag":396,"props":468,"children":469},{},[470,475],{"type":17,"tag":418,"props":471,"children":472},{},[473],{"type":36,"value":474},"Lua",{"type":17,"tag":418,"props":476,"children":477},{},[478],{"type":36,"value":479},"Rust",{"type":17,"tag":396,"props":481,"children":482},{},[483,488],{"type":17,"tag":418,"props":484,"children":485},{},[486],{"type":36,"value":487},"Io",{"type":17,"tag":418,"props":489,"children":490},{},[491],{"type":36,"value":492},"Swift",{"type":17,"tag":91,"props":494,"children":495},{},[],{"type":17,"tag":39,"props":497,"children":498},{},[499,501,508],{"type":36,"value":500},"再然后就是 ",{"type":17,"tag":75,"props":502,"children":505},{"href":503,"rel":504},"https://en.wikipedia.org/wiki/Prolog",[79],[506],{"type":36,"value":507},"Prolog community(Programming in Logic community)",{"type":36,"value":509},"，这是一种逻辑编程语言。这种类型的我还没有接触过，他更像是数学中的逻辑推理。他的基础是一阶逻辑(First-order logic) 其核心的写法和经常接触到的语言有很大的不同。他的语法例如：",{"type":17,"tag":271,"props":511,"children":513},{"code":512},"grandparent(X, Z) :- parent(X, Y), parent(Y, Z).\n父母关系：如果 X 是 Y 的父母，且 Y 是 Z 的父母，则 X 是 Z 的祖父母。\n",[514],{"type":17,"tag":276,"props":515,"children":516},{"__ignoreMap":7},[517],{"type":36,"value":512},{"type":17,"tag":39,"props":519,"children":520},{},[521,523,530,532,539],{"type":36,"value":522},"在一些大学中，会将 Prolog 放到",{"type":17,"tag":75,"props":524,"children":527},{"href":525,"rel":526},"https://en.wikipedia.org/wiki/Logic_programming",[79],[528],{"type":36,"value":529},"逻辑编程课",{"type":36,"value":531}," 中。如果很不幸你没有上过（ps: 我也没上过）那可以蹭一下 The University of Texas at Dallas(德克萨斯大学达拉斯分校) 的课件 ",{"type":17,"tag":75,"props":533,"children":536},{"href":534,"rel":535},"https://personal.utdallas.edu/~hamlen/cs6371sp14/lecture21.pdf",[79],[537],{"type":36,"value":538},"Logic Programming:CS 6371: Advanced Programming Languages",{"type":36,"value":540},"；如果要介绍 Prolong 那就需要介绍一阶逻辑和逻辑连接词、谓词逻辑、量词等。所以我会将这部分的介绍放到 Prolog 那一章节中，这里我们就介绍作者致谢的大佬。",{"type":17,"tag":195,"props":542,"children":543},{},[544,565],{"type":17,"tag":199,"props":545,"children":546},{},[547,554,556,563],{"type":17,"tag":75,"props":548,"children":551},{"href":549,"rel":550},"https://aws.amazon.com/cn/developer/community/heroes/brian-tarbox/",[79],[552],{"type":36,"value":553},"Brian Tarbox",{"type":36,"value":555},": 通过 Prolong 进行建模，用于模拟和分析海豚在实验中的思维模式，非常有趣。可以前往他的个人 ",{"type":17,"tag":75,"props":557,"children":560},{"href":558,"rel":559},"https://briantarbox.com/",[79],[561],{"type":36,"value":562},"blog",{"type":36,"value":564}," 了解更多",{"type":17,"tag":199,"props":566,"children":567},{},[568,575,576,583,585,592],{"type":17,"tag":75,"props":569,"children":572},{"href":570,"rel":571},"https://en.wikipedia.org/wiki/Joe_Armstrong_(programmer)",[79],[573],{"type":36,"value":574},"Joe Armstrong",{"type":36,"value":222},{"type":17,"tag":75,"props":577,"children":580},{"href":578,"rel":579},"https://en.wikipedia.org/wiki/Erlang_(programming_language)",[79],[581],{"type":36,"value":582},"Erlang",{"type":36,"value":584}," 设计者之一。这是一种并发、分布式、容错的编程语言，",{"type":17,"tag":75,"props":586,"children":589},{"href":587,"rel":588},"https://en.wikipedia.org/wiki/Elixir_(programming_language)",[79],[590],{"type":36,"value":591},"Elixir",{"type":36,"value":593}," 就是构建在 Erlang 之上。",{"type":17,"tag":39,"props":595,"children":596},{},[597],{"type":36,"value":598},"作为以分布式、多线程而闻名的语言。“Let it crash（让它崩溃）” 是 Erlang 语言的一种设计哲学。当一个进程发生错误或异常时，不必尝试捕获和处理错误，而是让该进程崩溃，然后通过其他机制（如重启或恢复）来恢复系统的正常运行。",{"type":17,"tag":91,"props":600,"children":601},{},[],{"type":17,"tag":39,"props":603,"children":604},{},[605],{"type":36,"value":606},"接下来轮到了 Scala community 登场。该语言旨在解决 对 Java 的批评，一句话就以证明其含金量。他是一种 强大的静态类型高级通用编程语言，支持面向对象编程和函数式编程。",{"type":17,"tag":271,"props":608,"children":610},{"code":609},"import java.time.LocalDate as Date\nimport Payment.*\n\nval name = \"Bib Fortuna\"\nval digits = 1983_0525_0000_0000L\nval expires = Date.of(1983, 5, 25)\n\nenum Payment:\n  case Card(name: String, digits: Long, expires: Date)\n  case PayPal(email: String)\n\ndef process(kind: Payment) = kind match\n  case Card(name, digits, expires) =>\n    s\"Processing credit card $name, $digits, $expires\"\n  case PayPal(email) =>\n    s\"Processing PayPal account $email\"\n\nprocess(Card(name, digits, expires))\n",[611],{"type":17,"tag":276,"props":612,"children":613},{"__ignoreMap":7},[614],{"type":36,"value":609},{"type":17,"tag":195,"props":616,"children":617},{},[618,639],{"type":17,"tag":199,"props":619,"children":620},{},[621,628,630,637],{"type":17,"tag":75,"props":622,"children":625},{"href":623,"rel":624},"https://dev.java/author/VenkatSubramaniam/",[79],[626],{"type":36,"value":627},"Venkat Subramaniam ",{"type":36,"value":629},": ACM 高级会员，",{"type":17,"tag":75,"props":631,"children":634},{"href":632,"rel":633},"https://pragprog.com/titles/vsscala2/pragmatic-scala/",[79],[635],{"type":36,"value":636},"Programming Scala",{"type":36,"value":638}," 一书作者。",{"type":17,"tag":199,"props":640,"children":641},{},[642,649],{"type":17,"tag":75,"props":643,"children":646},{"href":644,"rel":645},"https://en.wikipedia.org/wiki/Martin_Odersky",[79],[647],{"type":36,"value":648},"Martin Odersky",{"type":36,"value":650},": 他设计了 Scala。",{"type":17,"tag":91,"props":652,"children":653},{},[],{"type":17,"tag":39,"props":655,"children":656},{},[657,659,666,668,675],{"type":36,"value":658},"还有 ",{"type":17,"tag":75,"props":660,"children":663},{"href":661,"rel":662},"https://en.wikipedia.org/wiki/Clojure",[79],[664],{"type":36,"value":665},"Clojure community",{"type":36,"value":667},"。Clojure 是 ",{"type":17,"tag":75,"props":669,"children":672},{"href":670,"rel":671},"https://en.wikipedia.org/wiki/Lisp_(programming_language)",[79],[673],{"type":36,"value":674},"lisp",{"type":36,"value":676}," 家族的一部分，或者说他是 Lisp 的现代化变体。他继承了 lisp 的特性。同时在并在并发和不变数据结构上做出了优化（Lisp 是可变的）",{"type":17,"tag":39,"props":678,"children":679},{},[680,682,689],{"type":36,"value":681},"Lisp 发明和推广的 ",{"type":17,"tag":75,"props":683,"children":686},{"href":684,"rel":685},"https://en.wikipedia.org/wiki/S-expression",[79],[687],{"type":36,"value":688},"S 表达式(S-expression)",{"type":36,"value":690}," 还是很有特点的，例如一个计算式子：",{"type":17,"tag":271,"props":692,"children":694},{"code":693},"(* (+ 1 2) (+ 3 4))\n\n  + 1 2：表示加法操作，等于 3。\n  + 3 4：表示加法操作，等于 7。\n  *：表示乘法操作，将 3 和 7 相乘，结果是 21。\n  \n  如果是 Python 式子就是：\n\nresult = (1 + 2) * (3 + 4)\nprint(result)\n",[695],{"type":17,"tag":276,"props":696,"children":697},{"__ignoreMap":7},[698],{"type":36,"value":693},{"type":17,"tag":39,"props":700,"children":701},{},[702,704,711,713],{"type":36,"value":703},"到这里可能 Python 的式子比 S-expression 更接近传统的数学表达式。如果看到这那就可能认为 Lisp 还是不行，不如去学 Python。但 Lisp 还有一个特点是 ",{"type":17,"tag":75,"props":705,"children":708},{"href":706,"rel":707},"https://en.wikipedia.org/wiki/Metaprogramming#:~:text=Metaprogramming%20is%20a%20computer%20programming,even%20modify%20itself%2C%20while%20running.",[79],[709],{"type":36,"value":710},"元编程（Metaprogramming）能力",{"type":36,"value":712}," 指编写可以操作、生成、或修改程序代码的程序的能力。也就是 ",{"type":17,"tag":125,"props":714,"children":715},{},[716],{"type":36,"value":717},"——把代码当作数据来处理，从而实现动态的行为和更高的灵活性。",{"type":17,"tag":271,"props":719,"children":721},{"code":720},";; 定义一个宏，用来生成“加法函数”\n(defmacro make-adder (n)\n  `(lambda (x) (+ x ,n)))\n\n;; 使用宏生成一个加法函数\n(defparameter add-five (make-adder 5))\n\n;; 测试生成的函数\n(format t \"Result: ~A~%\" (funcall add-five 10))  ; 输出 \"Result: 15\"\n",[722],{"type":17,"tag":276,"props":723,"children":724},{"__ignoreMap":7},[725],{"type":36,"value":720},{"type":17,"tag":195,"props":727,"children":728},{},[729,734,739],{"type":17,"tag":199,"props":730,"children":731},{},[732],{"type":36,"value":733},"make-adder 是一个宏，它接收参数 n，并返回一个 新的函数代码：(lambda (x) (+ x ,n))。注意，这里返回的是代码，而不是一个值。",{"type":17,"tag":199,"props":735,"children":736},{},[737],{"type":36,"value":738},"宏的作用是在 编译时生成或修改代码，而不是像 Python 闭包那样只是生成行为。",{"type":17,"tag":199,"props":740,"children":741},{},[742],{"type":36,"value":743},"宏展开时，(make-adder 5) 会变成 (lambda (x) (+ x 5))，并且这个生成的函数将在运行时执行。",{"type":17,"tag":39,"props":745,"children":746},{},[747,749,755],{"type":36,"value":748},"在上面这个例子中，",{"type":17,"tag":276,"props":750,"children":752},{"className":751},[],[753],{"type":36,"value":754},"宏的定义实际上是操作代码的模板，生成新的 Code。",{"type":36,"value":756}," 如果是 Python，那么可以通过函数来生成一个加法函数：",{"type":17,"tag":271,"props":758,"children":760},{"code":759},"def make_adder(n):\n    return lambda x: x + n\n\n# 使用函数生成一个加法函数\nadd_five = make_adder(5)\n\n# 测试生成的函数\nprint(f\"Result: {add_five(10)}\")  # 输出 \"Result: 15\"\n",[761],{"type":17,"tag":276,"props":762,"children":763},{"__ignoreMap":7},[764],{"type":36,"value":759},{"type":17,"tag":195,"props":766,"children":767},{},[768,773,778],{"type":17,"tag":199,"props":769,"children":770},{},[771],{"type":36,"value":772},"make_adder 函数返回了一个新的函数（lambda x: x + n）。",{"type":17,"tag":199,"props":774,"children":775},{},[776],{"type":36,"value":777},"n 被捕获在闭包中，生成了一个 “动态的行为”：返回的函数始终会把输入值 x 加上 n。",{"type":17,"tag":199,"props":779,"children":780},{},[781],{"type":36,"value":782},"这只是动态生成了一个函数，而 没有生成或修改代码。我们只是定义了一个行为，而不是在代码层面进行操作。",{"type":17,"tag":39,"props":784,"children":785},{},[786],{"type":36,"value":787},"Lisp、Clojure、Scheme 等语言通过其 S-expression 和宏系统提供强大的元编程能力。特点是代码即数据（homoiconicity），天然支持元编程；而 Python 通过反射和动态代码生成支持元编程，他的运行时动态性强，支持动态类型，如果要展示不可变结构，那下面的例子就很贴合：",{"type":17,"tag":271,"props":789,"children":791},{"code":790},"(defn transform [person]\n   (update (assoc person :hair-color :gray) :age inc))\n\n(transform {:name \"Socrates\", :age 39})\n;; => {:name \"Socrates\", :age 40, :hair-color :gray}\n",[792],{"type":17,"tag":276,"props":793,"children":794},{"__ignoreMap":7},[795],{"type":36,"value":790},{"type":17,"tag":39,"props":797,"children":798},{},[799,801,807,809,815,817,822],{"type":36,"value":800},"最后输出的还是 40，因为在这个过程中 ",{"type":17,"tag":276,"props":802,"children":804},{"className":803},[],[805],{"type":36,"value":806},"age",{"type":36,"value":808}," 通过 ",{"type":17,"tag":276,"props":810,"children":812},{"className":811},[],[813],{"type":36,"value":814},"inc",{"type":36,"value":816}," 函数进行了递增操作，所以是 40 而不是 39。这展示了 Clojure 的不可变结构的特性。所以，我们花了几个部分了解 Lisp 和 Clojure，不仅是处于了解，而是对 ",{"type":17,"tag":125,"props":818,"children":819},{},[820],{"type":36,"value":821},"一个具有悠久历史和独特的、完全括号的前缀表示法的编程语言家族。",{"type":36,"value":823}," 的敬意。",{"type":17,"tag":195,"props":825,"children":826},{},[827,847],{"type":17,"tag":199,"props":828,"children":829},{},[830,837,839,846],{"type":17,"tag":75,"props":831,"children":834},{"href":832,"rel":833},"https://github.com/stuarthalloway",[79],[835],{"type":36,"value":836},"Stuart Halloway",{"type":36,"value":838},": Clojure 协作者; ",{"type":17,"tag":75,"props":840,"children":843},{"href":841,"rel":842},"https://pragprog.com/titles/shcloj3/programming-clojure-third-edition/",[79],[844],{"type":36,"value":845},"Programming Clojure",{"type":36,"value":638},{"type":17,"tag":199,"props":848,"children":849},{},[850,857],{"type":17,"tag":75,"props":851,"children":854},{"href":852,"rel":853},"https://en.wikipedia.org/wiki/Rich_Hickey",[79],[855],{"type":36,"value":856},"Rich Hickey ",{"type":36,"value":858},": Clojure 创建者。",{"type":17,"tag":91,"props":860,"children":861},{},[],{"type":17,"tag":39,"props":863,"children":864},{},[865,867,874,876,883,885,892,894,901],{"type":36,"value":866},"还还还有 ",{"type":17,"tag":75,"props":868,"children":871},{"href":869,"rel":870},"https://en.wikipedia.org/wiki/Haskell",[79],[872],{"type":36,"value":873},"Haskell community",{"type":36,"value":875},"，Haskell 专为教学、研究和工业应用而设计。以逻辑学家",{"type":17,"tag":75,"props":877,"children":880},{"href":878,"rel":879},"https://en.wikipedia.org/wiki/Haskell_Curry",[79],[881],{"type":36,"value":882},"哈斯克尔・柯里 (Haskell Curry) ",{"type":36,"value":884}," 的名字命名，他的 ",{"type":17,"tag":75,"props":886,"children":889},{"href":887,"rel":888},"https://en.wikipedia.org/wiki/Lambda_calculus",[79],[890],{"type":36,"value":891},"Lambda 演算（Lambda Calculus）",{"type":36,"value":893}," 是函数式编程的基础，以及他对 ",{"type":17,"tag":75,"props":895,"children":898},{"href":896,"rel":897},"https://en.wikipedia.org/wiki/Currying",[79],[899],{"type":36,"value":900},"Currying",{"type":36,"value":902}," 的贡献。",{"type":17,"tag":271,"props":904,"children":906},{"code":905},"•   在 Haskell 诞生之前，函数式编程语言如 Lisp、ML 等已经存在，但它们没有完全基于纯函数式的理念。\n•   Haskell 作为一门“纯函数式编程语言”，其命名体现了其与数学逻辑和 Lambda 演算的深厚联系。\n",[907],{"type":17,"tag":276,"props":908,"children":909},{"__ignoreMap":7},[910],{"type":36,"value":905},{"type":17,"tag":39,"props":912,"children":913},{},[914],{"type":36,"value":915},"所以，作为一个纯函数式的编程语言，它的式子是这样的：",{"type":17,"tag":271,"props":917,"children":919},{"code":918},"-- 纯函数：输入相同，输出总是相同\nadd :: Int -> Int -> Int\nadd x y = x + y\n\n-- 调用\nmain = print (add 3 5)  -- 输出 8\n",[920],{"type":17,"tag":276,"props":921,"children":922},{"__ignoreMap":7},[923],{"type":36,"value":918},{"type":17,"tag":39,"props":925,"children":926},{},[927],{"type":36,"value":928},"那么不是纯函数的是这样的：",{"type":17,"tag":271,"props":930,"children":932},{"code":931},"counter = 0\n\ndef increment():\n    global counter\n    counter += 1\n    return counter\n",[933],{"type":17,"tag":276,"props":934,"children":935},{"__ignoreMap":7},[936],{"type":36,"value":931},{"type":17,"tag":195,"props":938,"children":939},{},[940,961],{"type":17,"tag":199,"props":941,"children":942},{},[943,950,952,959],{"type":17,"tag":75,"props":944,"children":947},{"href":945,"rel":946},"https://en.wikipedia.org/wiki/Philip_Wadler",[79],[948],{"type":36,"value":949},"Phillip Wadler",{"type":36,"value":951},": 创造的 ",{"type":17,"tag":75,"props":953,"children":956},{"href":954,"rel":955},"https://en.wikipedia.org/wiki/Orwell_(programming_language)",[79],[957],{"type":36,"value":958},"Orwell",{"type":36,"value":960}," 被认为是 Haskell 的先驱; Haskell 设计者之一。推动了函数式编程从理论研究到实际应用的转变。",{"type":17,"tag":199,"props":962,"children":963},{},[964,971,972,979,981,988,990,997],{"type":17,"tag":75,"props":965,"children":968},{"href":966,"rel":967},"https://en.wikipedia.org/wiki/Simon_Peyton_Jones",[79],[969],{"type":36,"value":970},"Simon Peyton Jones",{"type":36,"value":222},{"type":17,"tag":75,"props":973,"children":976},{"href":974,"rel":975},"https://en.wikipedia.org/wiki/Glasgow_Haskell_Compiler",[79],[977],{"type":36,"value":978},"GHC(The Glasgow Haskell Compiler, Haskell 编译器) ",{"type":36,"value":980}," 开发者之一，他推动了 ",{"type":17,"tag":75,"props":982,"children":985},{"href":983,"rel":984},"https://en.wikipedia.org/wiki/Type_inference",[79],[986],{"type":36,"value":987},"类型推导",{"type":36,"value":989}," 和 ",{"type":17,"tag":75,"props":991,"children":994},{"href":992,"rel":993},"https://en.wikipedia.org/wiki/Type_safety",[79],[995],{"type":36,"value":996},"类型安全",{"type":36,"value":998}," 的概念",{"title":7,"searchDepth":1000,"depth":1000,"links":1001},2,[],"markdown","content:book:seven-languages-in-seven-weeks---bruce-a-tate.md","content","book/seven-languages-in-seven-weeks---bruce-a-tate.md","md",1736477102245]