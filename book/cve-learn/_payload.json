[{"data":1,"prerenderedAt":638},["Reactive",2],{"content-query-UW67z4wVLQ":3},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":7,"director":9,"time":10,"img":11,"plan":12,"body":13,"_type":633,"_id":634,"_source":635,"_file":636,"_extension":637},"/book/cve-learn","book",false,"","CVE learn","My","2025","14/1.png","100,100",{"type":14,"children":15,"toc":630},"root",[16],{"type":17,"tag":18,"props":19,"children":24},"element","book-content",{":by":20,":img":21,":plan":22,":title":23},"director","img","plan","title",[25,30,37,42,47,52,57,61,68,81,124,138,150,172,175,181,197,219,256,280,302,318,326,350,362,370,391,399,402,408,419,439,466,471,492,540,561,566,584,597,625],{"type":17,"tag":26,"props":27,"children":29},"text-title",{":t":28},"CVE is my dream.",[],{"type":17,"tag":31,"props":32,"children":33},"p",{},[34],{"type":35,"value":36},"text","早在我上小学时，就觉得 CVE 很帅。步入初中时，在初三那年我拿到了广东电信 IPTV 的通用漏洞。步入社会时，我拿到了 Github 的 Bug bounty。但我始终没有去拿一个 CVE 的编号。因为水是可以水的，但我已经水了 CNVD 和 Hackerone，我希望我的第一个 CVE 编号可以是不那么水的，有一点含金量的。",{"type":17,"tag":31,"props":38,"children":39},{},[40],{"type":35,"value":41},"虽然我并不是 Security 行业或领域的从业人员，只是一个爱好者。但我一直觉得 Security 很帅。同样的，虽然我不是 Design 行业的从业人员，但我觉得可以让自己做出来的 project 会好看，有个性。",{"type":17,"tag":31,"props":43,"children":44},{},[45],{"type":35,"value":46},"我并不是一个专精的人。很多时候我每项感兴趣的领域单拎出来都会被降维打击。虽然我单项领域无法媲美专业的从业者，但我感兴趣的领域都有点建树和作品。将 Security、Design、Animation、Computer 合在一起，与之能媲美的人可能会少那么一点。",{"type":17,"tag":31,"props":48,"children":49},{},[50],{"type":35,"value":51},"而现在，我只有 Design 的代表作，而 Security、Animation、Computer 还没有一个能拿得出手的作品。因此我希望会在未来三年，尽可能的补全这些我感兴趣领域的代表作。可能因为 Work 比较闲的缘故，我的时间总会多那么一点来放到我感兴趣的领域上。即使达不到也没有关系，至少也是努力过了，无论如何三年后的自己总会比现在的自己稍微厉害那么一点点。",{"type":17,"tag":31,"props":53,"children":54},{},[55],{"type":35,"value":56},"因此这个页面会记录一些我感兴趣的 CVE 和 CWE 的编号来让我学习，可能会获取到一些新的思路和对某个方面的理解。来帮助我实现这个目标，顺便看看冷门的 CWE 方向，毕竟 OWASP TOP 10 个人没有太大的兴趣。",{"type":17,"tag":58,"props":59,"children":60},"hr",{},[],{"type":17,"tag":62,"props":63,"children":65},"h1",{"id":64},"cve-2022-36114-1",[66],{"type":35,"value":67},"CVE-2022-36114 1",{"type":17,"tag":69,"props":70,"children":75},"cve-info",{":cwe":71,":type":72,"cve":73,"to":74},"400","2","CVE-2022-36114","https://nvd.nist.gov/vuln/detail/CVE-2022-36114",[76],{"type":17,"tag":31,"props":77,"children":78},{},[79],{"type":35,"value":80},"不受控制的资源消耗",{"type":17,"tag":31,"props":82,"children":83},{},[84,86,95,97,104,106,113,115,122],{"type":35,"value":85},"利用 Cargo 的 ",{"type":17,"tag":87,"props":88,"children":92},"a",{"href":89,"rel":90},"https://doc.rust-lang.org/cargo/reference/build-scripts.html",[91],"nofollow",[93],{"type":35,"value":94},"build script",{"type":35,"value":96}," 在构建阶段编译第三方的非 Rust code，同时结合 ",{"type":17,"tag":87,"props":98,"children":101},{"href":99,"rel":100},"https://doc.rust-lang.org/book/ch20-05-macros.html#how-to-write-a-custom-derive-macro",[91],[102],{"type":35,"value":103},"procedural macros",{"type":35,"value":105},"，在执行 ",{"type":17,"tag":107,"props":108,"children":110},"code",{"className":109},[],[111],{"type":35,"value":112},"cargo run",{"type":35,"value":114}," 的过程中触发了一个 ",{"type":17,"tag":87,"props":116,"children":119},{"href":117,"rel":118},"https://en.wikipedia.org/wiki/Zip_bomb",[91],[120],{"type":35,"value":121},"Zip Bomb",{"type":35,"value":123}," 行为。",{"type":17,"tag":31,"props":125,"children":126},{},[127,129,136],{"type":35,"value":128},"对于这个问题的修复，rust-lang 已经给出了一个 ",{"type":17,"tag":87,"props":130,"children":133},{"href":131,"rel":132},"https://github.com/rust-lang/wg-security-response/blob/4bbe734e6404ece6f4e85027564f8995d4ab70e0/patches/CVE-2022-36114/0001-CVE-2022-36114-limit-the-maximum-unpacked-size-of-a-.patch",[91],[134],{"type":35,"value":135},"补丁修复",{"type":35,"value":137}," Zip_bomb 的问题:",{"type":17,"tag":139,"props":140,"children":145},"pre",{"code":141,"language":142,"meta":7,"className":143},"// 在解压 .crate 文件（tar.gz）时，限制最多只能解压出 512MB 的内容。\n+const MAX_UNPACK_SIZE: u64 = 512 * 1024 * 1024;\n","c",[144],"language-c",[146],{"type":17,"tag":107,"props":147,"children":148},{"__ignoreMap":7},[149],{"type":35,"value":141},{"type":17,"tag":31,"props":151,"children":152},{},[153,155,161,163,170],{"type":35,"value":154},"同时引入了 ",{"type":17,"tag":107,"props":156,"children":158},{"className":157},[],[159],{"type":35,"value":160},"LimitErrorReader",{"type":35,"value":162},": 超过就抛出错误，避免资源被耗尽（比如磁盘写爆）。除此之外并没有对 macros、build 加以限制，只是建议尽可能的用 ",{"type":17,"tag":87,"props":164,"children":167},{"href":165,"rel":166},"https://crates.io/",[91],[168],{"type":35,"value":169},"crates",{"type":35,"value":171}," 上提交的 crate。",{"type":17,"tag":58,"props":173,"children":174},{},[],{"type":17,"tag":62,"props":176,"children":178},{"id":177},"cve-2023-40030-1",[179],{"type":35,"value":180},"CVE-2023-40030 1",{"type":17,"tag":69,"props":182,"children":187},{":cwe":183,":type":184,"cve":185,"to":186},"79","1","CVE-2023-40030","https://nvd.nist.gov/vuln/detail/cve-2023-40030",[188],{"type":17,"tag":31,"props":189,"children":190},{},[191,193],{"type":35,"value":192},"{OWASP TOP TEN}: 不恰当的网页生成输入中和 XSS",{"type":17,"tag":194,"props":195,"children":196},"br",{},[],{"type":17,"tag":31,"props":198,"children":199},{},[200,202,208,210,217],{"type":35,"value":201},"看到这篇通告的时候，我就回想起为什么我看 ",{"type":17,"tag":107,"props":203,"children":205},{"className":204},[],[206],{"type":35,"value":207},"cargo build --timings",{"type":35,"value":209}," 的时候肿么没想到会有 CWE-79。",{"type":17,"tag":87,"props":211,"children":214},{"href":212,"rel":213},"https://doc.rust-lang.org/cargo/reference/timings.html",[91],[215],{"type":35,"value":216},"--timings",{"type":35,"value":218}," 是一个生成 build 时间的 html 报告。",{"type":17,"tag":31,"props":220,"children":221},{},[222,224,230,232,238,240,246,248,254],{"type":35,"value":223},"可以通过在 ",{"type":17,"tag":107,"props":225,"children":227},{"className":226},[],[228],{"type":35,"value":229},"Cargo.toml",{"type":35,"value":231}," 中加入 ",{"type":17,"tag":107,"props":233,"children":235},{"className":234},[],[236],{"type":35,"value":237},"features = [\"\u003Cimg src='' onerror=alert(0)\"]",{"type":35,"value":239}," 来触发一个 CWE-79, 因此对这个问题的修复就是，将之前的 ",{"type":17,"tag":107,"props":241,"children":243},{"className":242},[],[244],{"type":35,"value":245},"Warning",{"type":35,"value":247},", 换成了 ",{"type":17,"tag":107,"props":249,"children":251},{"className":250},[],[252],{"type":35,"value":253},"bail!",{"type":35,"value":255}," 机制。",{"type":17,"tag":257,"props":258,"children":260},"text-space",{"type":259},"tip",[261],{"type":17,"tag":31,"props":262,"children":263},{},[264,269,271,278],{"type":17,"tag":107,"props":265,"children":267},{"className":266},[],[268],{"type":35,"value":253},{"type":35,"value":270}," 宏来自 ",{"type":17,"tag":87,"props":272,"children":275},{"href":273,"rel":274},"https://docs.rs/anyhow/latest/anyhow/macro.bail.html",[91],[276],{"type":35,"value":277},"anyhow",{"type":35,"value":279}," 用于方便地提前返回错误。",{"type":17,"tag":31,"props":281,"children":282},{},[283,285,292,294,300],{"type":35,"value":284},"可以看一下 ",{"type":17,"tag":87,"props":286,"children":289},{"href":287,"rel":288},"https://github.com/rust-lang/cargo/commit/9835622853f08be9a4b58ebe29dcec8f43b64b33#diff-99a8f4b284589e7db1aec698aa8f9ef9390f3ee3ecddc399dd6be1aa9ee00388L440-L446",[91],[290],{"type":35,"value":291},"fix pr",{"type":35,"value":293},"，非常有意思，比如 ",{"type":17,"tag":107,"props":295,"children":297},{"className":296},[],[298],{"type":35,"value":299},"validate_feature_name",{"type":35,"value":301}," 函数。",{"type":17,"tag":31,"props":303,"children":304},{},[305,307,313,315],{"type":35,"value":306},"原来：遇到非法 feature name，只输出 ",{"type":17,"tag":107,"props":308,"children":310},{"className":309},[],[311],{"type":35,"value":312},"warning",{"type":35,"value":314},"，流程继续。",{"type":17,"tag":194,"props":316,"children":317},{},[],{"type":17,"tag":139,"props":319,"children":321},{"code":320},"if let Some(ch) = chars.next() {Add commentMore actions\n        if !(unicode_xid::UnicodeXID::is_xid_start(ch) || ch == '_' || ch.is_digit(10)) {\n            config.shell().warn(&format!(\n                \"invalid character `{}` in feature `{}` in package {}, \\\n                the first character must be a Unicode XID start character or digit \\\n                (most letters or `_` or `0` to `9`)\\n\\\n                {}\",\n                ch, name, pkg_id, FUTURE\n            ))?;\n\n        }\n    }\n",[322],{"type":17,"tag":107,"props":323,"children":324},{"__ignoreMap":7},[325],{"type":35,"value":320},{"type":17,"tag":257,"props":327,"children":328},{"type":259},[329],{"type":17,"tag":31,"props":330,"children":331},{},[332,334,340,342,348],{"type":35,"value":333},"我本来想看看 2025-6-27 的 ",{"type":17,"tag":107,"props":335,"children":337},{"className":336},[],[338],{"type":35,"value":339},"src/cargo/core/summary.rs",{"type":35,"value":341}," 这个 fix pr 的区别。但我发现了一个流量密码，那就是 ",{"type":17,"tag":107,"props":343,"children":345},{"className":344},[],[346],{"type":35,"value":347},"Rc → Arc",{"type":35,"value":349},", 问就是 Thread Safety！",{"type":17,"tag":31,"props":351,"children":352},{},[353,355,360],{"type":35,"value":354},"现在：遇到非法 feature name，直接 ",{"type":17,"tag":107,"props":356,"children":358},{"className":357},[],[359],{"type":35,"value":253},{"type":35,"value":361},"，构建中止，用户必须修正。",{"type":17,"tag":139,"props":363,"children":365},{"code":364}," if let Some(ch) = chars.next() {Add commentMore actions\n        if !(unicode_xid::UnicodeXID::is_xid_start(ch) || ch == '_' || ch.is_digit(10)) {\n            bail!(\n                \"invalid character `{}` in feature `{}` in package {}, \\\n                the first character must be a Unicode XID start character or digit \\\n                (most letters or `_` or `0` to `9`)\",\n                ch,\n                name,\n                pkg_id\n            );\n        }\n    }\n",[366],{"type":17,"tag":107,"props":367,"children":368},{"__ignoreMap":7},[369],{"type":35,"value":364},{"type":17,"tag":31,"props":371,"children":372},{},[373,375,381,383,389],{"type":35,"value":374},"在单元测试中，来验证 feature name 是否合法，例如只有 ",{"type":17,"tag":107,"props":376,"children":378},{"className":377},[],[379],{"type":35,"value":380},"is_ok()",{"type":35,"value":382}," 是合法的，而 ",{"type":17,"tag":107,"props":384,"children":386},{"className":385},[],[387],{"type":35,"value":388},"is_err()",{"type":35,"value":390}," 是不合法的：",{"type":17,"tag":139,"props":392,"children":394},{"code":393}," #[test]Add commentMore actions\n    fn valid_feature_names() {\n        let loc = CRATES_IO_INDEX.into_url().unwrap();\n        let source_id = SourceId::for_registry(&loc).unwrap();\n        let pkg_id = PackageId::new(\"foo\", \"1.0.0\", source_id).unwrap();\n\n        assert!(validate_feature_name(pkg_id, \"c++17\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"128bit\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"_foo\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"feat-name\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"feat_name\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"foo.bar\").is_ok());\n\n        assert!(validate_feature_name(pkg_id, \"+foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"-foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \".foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"foo:bar\").is_err());\n        assert!(validate_feature_name(pkg_id, \"foo?\").is_err());\n        assert!(validate_feature_name(pkg_id, \"?foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"ⒶⒷⒸ\").is_err());\n        assert!(validate_feature_name(pkg_id, \"a¼\").is_err());\n    }\n",[395],{"type":17,"tag":107,"props":396,"children":397},{"__ignoreMap":7},[398],{"type":35,"value":393},{"type":17,"tag":58,"props":400,"children":401},{},[],{"type":17,"tag":62,"props":403,"children":405},{"id":404},"cve-2023-41051-1",[406],{"type":35,"value":407},"CVE-2023-41051 1",{"type":17,"tag":69,"props":409,"children":413},{":cwe":410,":type":184,"cve":411,"to":412},"125","CVE-2023-51051","https://nvd.nist.gov/vuln/detail/cve-2023-41051",[414],{"type":17,"tag":31,"props":415,"children":416},{},[417],{"type":35,"value":418},"越界访问（out-of-bounds）: 访问了本不属于该内存区域的数据。",{"type":17,"tag":31,"props":420,"children":421},{},[422,429,431,437],{"type":17,"tag":87,"props":423,"children":426},{"href":424,"rel":425},"https://github.com/rust-vmm/vm-memory",[91],[427],{"type":35,"value":428},"vm-memory",{"type":35,"value":430}," 的 ",{"type":17,"tag":107,"props":432,"children":434},{"className":433},[],[435],{"type":35,"value":436},"VolatileMemory",{"type":35,"value":438}," 实现未对边界进行严格校验，导致有可能读取到非法的内存区域：",{"type":17,"tag":440,"props":441,"children":442},"ol",{},[443,455],{"type":17,"tag":444,"props":445,"children":446},"li",{},[447,453],{"type":17,"tag":107,"props":448,"children":450},{"className":449},[],[451],{"type":35,"value":452},"VolatileMemory::get_slice",{"type":35,"value":454},": 返回一段“易失性切片”（VolatileSlice），用于后续的底层操作",{"type":17,"tag":444,"props":456,"children":457},{},[458,464],{"type":17,"tag":107,"props":459,"children":461},{"className":460},[],[462],{"type":35,"value":463},"VolatileMemory::read/write",{"type":35,"value":465},": 直接从这块内存读/写数据，保证每次都实际发生内存访问",{"type":17,"tag":31,"props":467,"children":468},{},[469],{"type":35,"value":470},"VolatileMemory trait 就是定义了一套访问“虚拟机物理内存”或“特殊硬件内存区域”的低层接口，保证每次读写都真实发生，且不被编译器优化。它让不同的底层实现都能用统一的 trait 操作。",{"type":17,"tag":31,"props":472,"children":473},{},[474,476,482,484,490],{"type":35,"value":475},"但问题来了，这个通告并不涉及 ",{"type":17,"tag":107,"props":477,"children":479},{"className":478},[],[480],{"type":35,"value":481},"read/write",{"type":35,"value":483},"，更多的是 ",{"type":17,"tag":107,"props":485,"children":487},{"className":486},[],[488],{"type":35,"value":489},"get_slice",{"type":35,"value":491}," 方法，例如：",{"type":17,"tag":440,"props":493,"children":494},{},[495,504,513,522,531],{"type":17,"tag":444,"props":496,"children":497},{},[498],{"type":17,"tag":107,"props":499,"children":501},{"className":500},[],[502],{"type":35,"value":503},"get_atomic_ref",{"type":17,"tag":444,"props":505,"children":506},{},[507],{"type":17,"tag":107,"props":508,"children":510},{"className":509},[],[511],{"type":35,"value":512},"aligned_as_ref",{"type":17,"tag":444,"props":514,"children":515},{},[516],{"type":17,"tag":107,"props":517,"children":519},{"className":518},[],[520],{"type":35,"value":521},"aligned_as_mut",{"type":17,"tag":444,"props":523,"children":524},{},[525],{"type":17,"tag":107,"props":526,"children":528},{"className":527},[],[529],{"type":35,"value":530},"get_ref",{"type":17,"tag":444,"props":532,"children":533},{},[534],{"type":17,"tag":107,"props":535,"children":537},{"className":536},[],[538],{"type":35,"value":539},"get_array_ref",{"type":17,"tag":31,"props":541,"children":542},{},[543,545,551,553,559],{"type":35,"value":544},"上述方法有个共同点，都是利用 ",{"type":17,"tag":107,"props":546,"children":548},{"className":547},[],[549],{"type":35,"value":550},"ref",{"type":35,"value":552}," 类方法引起的。它们都尝试返回指向底层内存的 Rust 类型引用（如 &T、",{"type":17,"tag":107,"props":554,"children":556},{"className":555},[],[557],{"type":35,"value":558},"&[T]",{"type":35,"value":560}," 等），而不是直接读写原始字节数据。它们的实现通常会调用 get_slice，假设返回的内存区域长度足够大。",{"type":17,"tag":31,"props":562,"children":563},{},[564],{"type":35,"value":565},"如果自定义实现的 get_slice 返回的切片长度不足，就会导致这些 ref 方法产生越界引用，造成内存安全风险。例如：",{"type":17,"tag":440,"props":567,"children":568},{},[569,574,579],{"type":17,"tag":444,"props":570,"children":571},{},[572],{"type":35,"value":573},"这些方法假设 get_slice 返回的 VolatileSlice 长度是你要求的大小（比如 T 是 u32，就要 4 字节）。",{"type":17,"tag":444,"props":575,"children":576},{},[577],{"type":35,"value":578},"如果自定义实现的 get_slice 返回的 VolatileSlice 比你要求的短（比如只返回了2字节）",{"type":17,"tag":444,"props":580,"children":581},{},[582],{"type":35,"value":583},"这些方法还是会照常把这块内存强转成 &T，这时你访问 &T 时就可能会读到超出实际内存范围以外的内容",{"type":17,"tag":31,"props":585,"children":586},{},[587,589,595],{"type":35,"value":588},"仔细欣赏 ",{"type":17,"tag":87,"props":590,"children":593},{"href":591,"rel":592},"https://github.com/rust-vmm/vm-memory/commit/aff1dd4a5259f7deba56692840f7a2d9ca34c9c8#diff-0870facad91de878abbdf4dc43212b8de558021cf0971f62148c2cab381bd150R109-R275",[91],[594],{"type":35,"value":291},{"type":35,"value":596}," 你会发现：",{"type":17,"tag":31,"props":598,"children":599},{},[600,602,608,610,615,617,623],{"type":35,"value":601},"这些方法内部，都会调用 ",{"type":17,"tag":107,"props":603,"children":605},{"className":604},[],[606],{"type":35,"value":607},"get_slice(offset, count)",{"type":35,"value":609}," 拿到一块内存切片，然后把它 reinterpret_cast 成你要的类型引用。因此给 ",{"type":17,"tag":107,"props":611,"children":613},{"className":612},[],[614],{"type":35,"value":489},{"type":35,"value":616}," 加上 ",{"type":17,"tag":107,"props":618,"children":620},{"className":619},[],[621],{"type":35,"value":622},"assert_eq!",{"type":35,"value":624}," 就意味着：",{"type":17,"tag":31,"props":626,"children":627},{},[628],{"type":35,"value":629},"“如果你要 8 字节引用，必须实际拿到 8 字节的内存切片，否则直接 panic，不做 unsafe 操作！”",{"title":7,"searchDepth":631,"depth":631,"links":632},2,[],"markdown","content:book:cve-learn.md","content","book/cve-learn.md","md",1750962051234]