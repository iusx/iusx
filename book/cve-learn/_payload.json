[{"data":1,"prerenderedAt":647},["Reactive",2],{"content-query-UW67z4wVLQ":3},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":7,"director":9,"time":10,"img":11,"plan":12,"body":13,"_type":642,"_id":643,"_source":644,"_file":645,"_extension":646},"/book/cve-learn","book",false,"","CVE learn","My","2025","14/1.png","100,100",{"type":14,"children":15,"toc":639},"root",[16],{"type":17,"tag":18,"props":19,"children":24},"element","book-content",{":by":20,":img":21,":plan":22,":title":23},"director","img","plan","title",[25,30,37,42,47,52,57,61,68,81,124,138,150,172,175,181,197,219,256,280,302,318,326,334,346,354,375,383,386,392,403,423,450,455,476,524,545,550,568,581,609,614,617,623],{"type":17,"tag":26,"props":27,"children":29},"text-title",{":t":28},"CVE is my dream.",[],{"type":17,"tag":31,"props":32,"children":33},"p",{},[34],{"type":35,"value":36},"text","早在我上小学时，就觉得 CVE 很帅。步入初中时，在初三那年我拿到了广东电信 IPTV 的通用漏洞。步入社会时，我拿到了 Github 的 Bug bounty。但我始终没有去拿一个 CVE 的编号。因为水是可以水的，但我已经水了 CNVD 和 Hackerone，我希望我的第一个 CVE 编号可以是不那么水的，有一点含金量的。",{"type":17,"tag":31,"props":38,"children":39},{},[40],{"type":35,"value":41},"虽然我并不是 Security 行业或领域的从业人员，只是一个爱好者。但我一直觉得 Security 很帅。同样的，虽然我不是 Design 行业的从业人员，但我觉得可以让自己做出来的 project 会好看，有个性。",{"type":17,"tag":31,"props":43,"children":44},{},[45],{"type":35,"value":46},"我并不是一个专精的人。很多时候我每项感兴趣的领域单拎出来都会被降维打击。虽然我单项领域无法媲美专业的从业者，但我感兴趣的领域都有点建树和作品。将 Security、Design、Animation、Computer 合在一起，与之能媲美的人可能会少那么一点。",{"type":17,"tag":31,"props":48,"children":49},{},[50],{"type":35,"value":51},"而现在，我只有 Design 的代表作，而 Security、Animation、Computer 还没有一个能拿得出手的作品。因此我希望会在未来三年，尽可能的补全这些我感兴趣领域的代表作。可能因为 Work 比较闲的缘故，我的时间总会多那么一点来放到我感兴趣的领域上。即使达不到也没有关系，至少也是努力过了，无论如何三年后的自己总会比现在的自己稍微厉害那么一点点。",{"type":17,"tag":31,"props":53,"children":54},{},[55],{"type":35,"value":56},"因此这个页面会记录一些我感兴趣的 CVE 和 CWE 的编号来让我学习，可能会获取到一些新的思路和对某个方面的理解。来帮助我实现这个目标，顺便看看冷门的 CWE 方向，毕竟 OWASP TOP 10 个人没有太大的兴趣。",{"type":17,"tag":58,"props":59,"children":60},"hr",{},[],{"type":17,"tag":62,"props":63,"children":65},"h1",{"id":64},"cve-2022-36114-1",[66],{"type":35,"value":67},"CVE-2022-36114 1",{"type":17,"tag":69,"props":70,"children":75},"cve-info",{":type":71,"cve":72,"to":73,":cwe":74},"2","CVE-2022-36114","https://nvd.nist.gov/vuln/detail/CVE-2022-36114","400",[76],{"type":17,"tag":31,"props":77,"children":78},{},[79],{"type":35,"value":80},"不受控制的资源消耗",{"type":17,"tag":31,"props":82,"children":83},{},[84,86,95,97,104,106,113,115,122],{"type":35,"value":85},"利用 Cargo 的 ",{"type":17,"tag":87,"props":88,"children":92},"a",{"href":89,"rel":90},"https://doc.rust-lang.org/cargo/reference/build-scripts.html",[91],"nofollow",[93],{"type":35,"value":94},"build script",{"type":35,"value":96}," 在构建阶段编译第三方的非 Rust code，同时结合 ",{"type":17,"tag":87,"props":98,"children":101},{"href":99,"rel":100},"https://doc.rust-lang.org/book/ch20-05-macros.html#how-to-write-a-custom-derive-macro",[91],[102],{"type":35,"value":103},"procedural macros",{"type":35,"value":105},"，在执行 ",{"type":17,"tag":107,"props":108,"children":110},"code",{"className":109},[],[111],{"type":35,"value":112},"cargo run",{"type":35,"value":114}," 的过程中触发了一个 ",{"type":17,"tag":87,"props":116,"children":119},{"href":117,"rel":118},"https://en.wikipedia.org/wiki/Zip_bomb",[91],[120],{"type":35,"value":121},"Zip Bomb",{"type":35,"value":123}," 行为。",{"type":17,"tag":31,"props":125,"children":126},{},[127,129,136],{"type":35,"value":128},"对于这个问题的修复，rust-lang 已经给出了一个 ",{"type":17,"tag":87,"props":130,"children":133},{"href":131,"rel":132},"https://github.com/rust-lang/wg-security-response/blob/4bbe734e6404ece6f4e85027564f8995d4ab70e0/patches/CVE-2022-36114/0001-CVE-2022-36114-limit-the-maximum-unpacked-size-of-a-.patch",[91],[134],{"type":35,"value":135},"补丁修复",{"type":35,"value":137}," Zip_bomb 的问题:",{"type":17,"tag":139,"props":140,"children":145},"pre",{"code":141,"language":142,"meta":7,"className":143},"// 在解压 .crate 文件（tar.gz）时，限制最多只能解压出 512MB 的内容。\n+const MAX_UNPACK_SIZE: u64 = 512 * 1024 * 1024;\n","c",[144],"language-c",[146],{"type":17,"tag":107,"props":147,"children":148},{"__ignoreMap":7},[149],{"type":35,"value":141},{"type":17,"tag":31,"props":151,"children":152},{},[153,155,161,163,170],{"type":35,"value":154},"同时引入了 ",{"type":17,"tag":107,"props":156,"children":158},{"className":157},[],[159],{"type":35,"value":160},"LimitErrorReader",{"type":35,"value":162},": 超过就抛出错误，避免资源被耗尽（比如磁盘写爆）。除此之外并没有对 macros、build 加以限制，只是建议尽可能的用 ",{"type":17,"tag":87,"props":164,"children":167},{"href":165,"rel":166},"https://crates.io/",[91],[168],{"type":35,"value":169},"crates",{"type":35,"value":171}," 上提交的 crate。",{"type":17,"tag":58,"props":173,"children":174},{},[],{"type":17,"tag":62,"props":176,"children":178},{"id":177},"cve-2023-40030-1",[179],{"type":35,"value":180},"CVE-2023-40030 1",{"type":17,"tag":69,"props":182,"children":187},{":type":183,"cve":184,"to":185,":cwe":186},"1","CVE-2023-40030","https://nvd.nist.gov/vuln/detail/cve-2023-40030","79",[188],{"type":17,"tag":31,"props":189,"children":190},{},[191,193],{"type":35,"value":192},"{OWASP TOP TEN}: 不恰当的网页生成输入中和 XSS",{"type":17,"tag":194,"props":195,"children":196},"br",{},[],{"type":17,"tag":31,"props":198,"children":199},{},[200,202,208,210,217],{"type":35,"value":201},"看到这篇通告的时候，我就回想起为什么我看 ",{"type":17,"tag":107,"props":203,"children":205},{"className":204},[],[206],{"type":35,"value":207},"cargo build --timings",{"type":35,"value":209}," 的时候肿么没想到会有 CWE-79。",{"type":17,"tag":87,"props":211,"children":214},{"href":212,"rel":213},"https://doc.rust-lang.org/cargo/reference/timings.html",[91],[215],{"type":35,"value":216},"--timings",{"type":35,"value":218}," 是一个生成 build 时间的 html 报告。",{"type":17,"tag":31,"props":220,"children":221},{},[222,224,230,232,238,240,246,248,254],{"type":35,"value":223},"可以通过在 ",{"type":17,"tag":107,"props":225,"children":227},{"className":226},[],[228],{"type":35,"value":229},"Cargo.toml",{"type":35,"value":231}," 中加入 ",{"type":17,"tag":107,"props":233,"children":235},{"className":234},[],[236],{"type":35,"value":237},"features = [\"\u003Cimg src='' onerror=alert(0)\"]",{"type":35,"value":239}," 来触发一个 CWE-79, 因此对这个问题的修复就是，将之前的 ",{"type":17,"tag":107,"props":241,"children":243},{"className":242},[],[244],{"type":35,"value":245},"Warning",{"type":35,"value":247},", 换成了 ",{"type":17,"tag":107,"props":249,"children":251},{"className":250},[],[252],{"type":35,"value":253},"bail!",{"type":35,"value":255}," 机制。",{"type":17,"tag":257,"props":258,"children":260},"text-space",{"type":259},"tip",[261],{"type":17,"tag":31,"props":262,"children":263},{},[264,269,271,278],{"type":17,"tag":107,"props":265,"children":267},{"className":266},[],[268],{"type":35,"value":253},{"type":35,"value":270}," 宏来自 ",{"type":17,"tag":87,"props":272,"children":275},{"href":273,"rel":274},"https://docs.rs/anyhow/latest/anyhow/macro.bail.html",[91],[276],{"type":35,"value":277},"anyhow",{"type":35,"value":279}," 用于方便地提前返回错误。",{"type":17,"tag":31,"props":281,"children":282},{},[283,285,292,294,300],{"type":35,"value":284},"可以看一下 ",{"type":17,"tag":87,"props":286,"children":289},{"href":287,"rel":288},"https://github.com/rust-lang/cargo/commit/9835622853f08be9a4b58ebe29dcec8f43b64b33#diff-99a8f4b284589e7db1aec698aa8f9ef9390f3ee3ecddc399dd6be1aa9ee00388L440-L446",[91],[290],{"type":35,"value":291},"fix pr",{"type":35,"value":293},"，非常有意思，比如 ",{"type":17,"tag":107,"props":295,"children":297},{"className":296},[],[298],{"type":35,"value":299},"validate_feature_name",{"type":35,"value":301}," 函数。",{"type":17,"tag":31,"props":303,"children":304},{},[305,307,313,315],{"type":35,"value":306},"原来：遇到非法 feature name，只输出 ",{"type":17,"tag":107,"props":308,"children":310},{"className":309},[],[311],{"type":35,"value":312},"warning",{"type":35,"value":314},"，流程继续。",{"type":17,"tag":194,"props":316,"children":317},{},[],{"type":17,"tag":139,"props":319,"children":321},{"code":320},"if let Some(ch) = chars.next() {Add commentMore actions\n        if !(unicode_xid::UnicodeXID::is_xid_start(ch) || ch == '_' || ch.is_digit(10)) {\n            config.shell().warn(&format!(\n                \"invalid character `{}` in feature `{}` in package {}, \\\n                the first character must be a Unicode XID start character or digit \\\n                (most letters or `_` or `0` to `9`)\\n\\\n                {}\",\n                ch, name, pkg_id, FUTURE\n            ))?;\n\n        }\n    }\n",[322],{"type":17,"tag":107,"props":323,"children":324},{"__ignoreMap":7},[325],{"type":35,"value":320},{"type":17,"tag":257,"props":327,"children":328},{"type":259},[329],{"type":17,"tag":31,"props":330,"children":331},{},[332],{"type":35,"value":333},"我本来想看看 2025-6-27 的 src/cargo/core/summary.rs 这个 fix pr 的区别。但我发现了一个流量密码，那就是 Rc → Arc, 问就是 Thread Safety！",{"type":17,"tag":31,"props":335,"children":336},{},[337,339,344],{"type":35,"value":338},"现在：遇到非法 feature name，直接 ",{"type":17,"tag":107,"props":340,"children":342},{"className":341},[],[343],{"type":35,"value":253},{"type":35,"value":345},"，构建中止，用户必须修正。",{"type":17,"tag":139,"props":347,"children":349},{"code":348}," if let Some(ch) = chars.next() {Add commentMore actions\n        if !(unicode_xid::UnicodeXID::is_xid_start(ch) || ch == '_' || ch.is_digit(10)) {\n            bail!(\n                \"invalid character `{}` in feature `{}` in package {}, \\\n                the first character must be a Unicode XID start character or digit \\\n                (most letters or `_` or `0` to `9`)\",\n                ch,\n                name,\n                pkg_id\n            );\n        }\n    }\n",[350],{"type":17,"tag":107,"props":351,"children":352},{"__ignoreMap":7},[353],{"type":35,"value":348},{"type":17,"tag":31,"props":355,"children":356},{},[357,359,365,367,373],{"type":35,"value":358},"在单元测试中，来验证 feature name 是否合法，例如只有 ",{"type":17,"tag":107,"props":360,"children":362},{"className":361},[],[363],{"type":35,"value":364},"is_ok()",{"type":35,"value":366}," 是合法的，而 ",{"type":17,"tag":107,"props":368,"children":370},{"className":369},[],[371],{"type":35,"value":372},"is_err()",{"type":35,"value":374}," 是不合法的：",{"type":17,"tag":139,"props":376,"children":378},{"code":377}," #[test]Add commentMore actions\n    fn valid_feature_names() {\n        let loc = CRATES_IO_INDEX.into_url().unwrap();\n        let source_id = SourceId::for_registry(&loc).unwrap();\n        let pkg_id = PackageId::new(\"foo\", \"1.0.0\", source_id).unwrap();\n\n        assert!(validate_feature_name(pkg_id, \"c++17\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"128bit\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"_foo\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"feat-name\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"feat_name\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"foo.bar\").is_ok());\n\n        assert!(validate_feature_name(pkg_id, \"+foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"-foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \".foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"foo:bar\").is_err());\n        assert!(validate_feature_name(pkg_id, \"foo?\").is_err());\n        assert!(validate_feature_name(pkg_id, \"?foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"ⒶⒷⒸ\").is_err());\n        assert!(validate_feature_name(pkg_id, \"a¼\").is_err());\n    }\n",[379],{"type":17,"tag":107,"props":380,"children":381},{"__ignoreMap":7},[382],{"type":35,"value":377},{"type":17,"tag":58,"props":384,"children":385},{},[],{"type":17,"tag":62,"props":387,"children":389},{"id":388},"cve-2023-41051-1",[390],{"type":35,"value":391},"CVE-2023-41051 1",{"type":17,"tag":69,"props":393,"children":397},{":type":183,"cve":394,"to":395,":cwe":396},"CVE-2023-51051","https://nvd.nist.gov/vuln/detail/cve-2023-41051","125",[398],{"type":17,"tag":31,"props":399,"children":400},{},[401],{"type":35,"value":402},"越界访问（out-of-bounds）: 访问了本不属于该内存区域的数据。",{"type":17,"tag":31,"props":404,"children":405},{},[406,413,415,421],{"type":17,"tag":87,"props":407,"children":410},{"href":408,"rel":409},"https://github.com/rust-vmm/vm-memory",[91],[411],{"type":35,"value":412},"vm-memory",{"type":35,"value":414}," 的 ",{"type":17,"tag":107,"props":416,"children":418},{"className":417},[],[419],{"type":35,"value":420},"VolatileMemory",{"type":35,"value":422}," 实现未对边界进行严格校验，导致有可能读取到非法的内存区域：",{"type":17,"tag":424,"props":425,"children":426},"ol",{},[427,439],{"type":17,"tag":428,"props":429,"children":430},"li",{},[431,437],{"type":17,"tag":107,"props":432,"children":434},{"className":433},[],[435],{"type":35,"value":436},"VolatileMemory::get_slice",{"type":35,"value":438},": 返回一段“易失性切片”（VolatileSlice），用于后续的底层操作",{"type":17,"tag":428,"props":440,"children":441},{},[442,448],{"type":17,"tag":107,"props":443,"children":445},{"className":444},[],[446],{"type":35,"value":447},"VolatileMemory::read/write",{"type":35,"value":449},": 直接从这块内存读/写数据，保证每次都实际发生内存访问",{"type":17,"tag":31,"props":451,"children":452},{},[453],{"type":35,"value":454},"VolatileMemory trait 就是定义了一套访问“虚拟机物理内存”或“特殊硬件内存区域”的低层接口，保证每次读写都真实发生，且不被编译器优化。它让不同的底层实现都能用统一的 trait 操作。",{"type":17,"tag":31,"props":456,"children":457},{},[458,460,466,468,474],{"type":35,"value":459},"但问题来了，这个通告并不涉及 ",{"type":17,"tag":107,"props":461,"children":463},{"className":462},[],[464],{"type":35,"value":465},"read/write",{"type":35,"value":467},"，更多的是 ",{"type":17,"tag":107,"props":469,"children":471},{"className":470},[],[472],{"type":35,"value":473},"get_slice",{"type":35,"value":475}," 方法，例如：",{"type":17,"tag":424,"props":477,"children":478},{},[479,488,497,506,515],{"type":17,"tag":428,"props":480,"children":481},{},[482],{"type":17,"tag":107,"props":483,"children":485},{"className":484},[],[486],{"type":35,"value":487},"get_atomic_ref",{"type":17,"tag":428,"props":489,"children":490},{},[491],{"type":17,"tag":107,"props":492,"children":494},{"className":493},[],[495],{"type":35,"value":496},"aligned_as_ref",{"type":17,"tag":428,"props":498,"children":499},{},[500],{"type":17,"tag":107,"props":501,"children":503},{"className":502},[],[504],{"type":35,"value":505},"aligned_as_mut",{"type":17,"tag":428,"props":507,"children":508},{},[509],{"type":17,"tag":107,"props":510,"children":512},{"className":511},[],[513],{"type":35,"value":514},"get_ref",{"type":17,"tag":428,"props":516,"children":517},{},[518],{"type":17,"tag":107,"props":519,"children":521},{"className":520},[],[522],{"type":35,"value":523},"get_array_ref",{"type":17,"tag":31,"props":525,"children":526},{},[527,529,535,537,543],{"type":35,"value":528},"上述方法有个共同点，都是利用 ",{"type":17,"tag":107,"props":530,"children":532},{"className":531},[],[533],{"type":35,"value":534},"ref",{"type":35,"value":536}," 类方法引起的。它们都尝试返回指向底层内存的 Rust 类型引用（如 &T、",{"type":17,"tag":107,"props":538,"children":540},{"className":539},[],[541],{"type":35,"value":542},"&[T]",{"type":35,"value":544}," 等），而不是直接读写原始字节数据。它们的实现通常会调用 get_slice，假设返回的内存区域长度足够大。",{"type":17,"tag":31,"props":546,"children":547},{},[548],{"type":35,"value":549},"如果自定义实现的 get_slice 返回的切片长度不足，就会导致这些 ref 方法产生越界引用，造成内存安全风险。例如：",{"type":17,"tag":424,"props":551,"children":552},{},[553,558,563],{"type":17,"tag":428,"props":554,"children":555},{},[556],{"type":35,"value":557},"这些方法假设 get_slice 返回的 VolatileSlice 长度是你要求的大小（比如 T 是 u32，就要 4 字节）。",{"type":17,"tag":428,"props":559,"children":560},{},[561],{"type":35,"value":562},"如果自定义实现的 get_slice 返回的 VolatileSlice 比你要求的短（比如只返回了2字节）",{"type":17,"tag":428,"props":564,"children":565},{},[566],{"type":35,"value":567},"这些方法还是会照常把这块内存强转成 &T，这时你访问 &T 时就可能会读到超出实际内存范围以外的内容",{"type":17,"tag":31,"props":569,"children":570},{},[571,573,579],{"type":35,"value":572},"仔细欣赏 ",{"type":17,"tag":87,"props":574,"children":577},{"href":575,"rel":576},"https://github.com/rust-vmm/vm-memory/commit/aff1dd4a5259f7deba56692840f7a2d9ca34c9c8#diff-0870facad91de878abbdf4dc43212b8de558021cf0971f62148c2cab381bd150R109-R275",[91],[578],{"type":35,"value":291},{"type":35,"value":580}," 你会发现：",{"type":17,"tag":31,"props":582,"children":583},{},[584,586,592,594,599,601,607],{"type":35,"value":585},"这些方法内部，都会调用 ",{"type":17,"tag":107,"props":587,"children":589},{"className":588},[],[590],{"type":35,"value":591},"get_slice(offset, count)",{"type":35,"value":593}," 拿到一块内存切片，然后把它 reinterpret_cast 成你要的类型引用。因此给 ",{"type":17,"tag":107,"props":595,"children":597},{"className":596},[],[598],{"type":35,"value":473},{"type":35,"value":600}," 加上 ",{"type":17,"tag":107,"props":602,"children":604},{"className":603},[],[605],{"type":35,"value":606},"assert_eq!",{"type":35,"value":608}," 就意味着：",{"type":17,"tag":31,"props":610,"children":611},{},[612],{"type":35,"value":613},"“如果你要 8 字节引用，必须实际拿到 8 字节的内存切片，否则直接 panic，不做 unsafe 操作！”",{"type":17,"tag":58,"props":615,"children":616},{},[],{"type":17,"tag":62,"props":618,"children":620},{"id":619},"cve-2023-38497-1",[621],{"type":35,"value":622},"CVE-2023-38497 1",{"type":17,"tag":69,"props":624,"children":628},{":type":625,"cve":394,"to":626,"cwe":627},"3","https://nvd.nist.gov/vuln/detail/cve-2023-38497","278,732",[629],{"type":17,"tag":31,"props":630,"children":631},{},[632,634,637],{"type":35,"value":633},"732: 关键资源的权限分配错误",{"type":17,"tag":194,"props":635,"children":636},{},[],{"type":35,"value":638},"\n278: 不安全的保留继承权限",{"title":7,"searchDepth":640,"depth":640,"links":641},2,[],"markdown","content:book:cve-learn.md","content","book/cve-learn.md","md",1751044096436]