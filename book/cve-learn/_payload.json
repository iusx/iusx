[{"data":1,"prerenderedAt":917},["Reactive",2],{"content-query-UW67z4wVLQ":3},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":7,"director":9,"time":10,"img":11,"plan":12,"body":13,"_type":912,"_id":913,"_source":914,"_file":915,"_extension":916},"/book/cve-learn","book",false,"","CVE learn","My","2025","14/1.png","100,100",{"type":14,"children":15,"toc":905},"root",[16],{"type":17,"tag":18,"props":19,"children":24},"element","book-content",{":by":20,":img":21,":plan":22,":title":23},"director","img","plan","title",[25,30,37,42,47,52,57,61,68,75,88,131,145,157,179,182,188,204,226,263,287,309,325,333,341,353,361,382,390,393,399,410,430,457,462,483,531,552,557,575,588,616,621,624,630,653,705,757,777,800,810,838,846,851,859,872,880],{"type":17,"tag":26,"props":27,"children":29},"text-title",{":t":28},"CVE is my dream.",[],{"type":17,"tag":31,"props":32,"children":33},"p",{},[34],{"type":35,"value":36},"text","早在我上小学时，就觉得 CVE 很帅。步入初中时，在初三那年我拿到了广东电信 IPTV 的通用漏洞。步入社会时，我拿到了 Github 的 Bug bounty。但我始终没有去拿一个 CVE 的编号。因为水是可以水的，但我已经水了 CNVD 和 Hackerone，我希望我的第一个 CVE 编号可以是不那么水的，有一点含金量的。",{"type":17,"tag":31,"props":38,"children":39},{},[40],{"type":35,"value":41},"虽然我并不是 Security 行业或领域的从业人员，只是一个爱好者。但我一直觉得 Security 很帅。同样的，虽然我不是 Design 行业的从业人员，但我觉得可以让自己做出来的 project 会好看，有个性。",{"type":17,"tag":31,"props":43,"children":44},{},[45],{"type":35,"value":46},"我并不是一个专精的人。很多时候我每项感兴趣的领域单拎出来都会被降维打击。虽然我单项领域无法媲美专业的从业者，但我感兴趣的领域都有点建树和作品。将 Security、Design、Animation、Computer 合在一起，与之能媲美的人可能会少那么一点。",{"type":17,"tag":31,"props":48,"children":49},{},[50],{"type":35,"value":51},"而现在，我只有 Design 的代表作，而 Security、Animation、Computer 还没有一个能拿得出手的作品。因此我希望会在未来三年，尽可能的补全这些我感兴趣领域的代表作。可能因为 Work 比较闲的缘故，我的时间总会多那么一点来放到我感兴趣的领域上。即使达不到也没有关系，至少也是努力过了，无论如何三年后的自己总会比现在的自己稍微厉害那么一点点。",{"type":17,"tag":31,"props":53,"children":54},{},[55],{"type":35,"value":56},"因此这个页面会记录一些我感兴趣的 CVE 和 CWE 的编号来让我学习，可能会获取到一些新的思路和对某个方面的理解。来帮助我实现这个目标，顺便看看冷门的 CWE 方向，毕竟 OWASP TOP 10 个人没有太大的兴趣。",{"type":17,"tag":58,"props":59,"children":60},"hr",{},[],{"type":17,"tag":62,"props":63,"children":65},"h1",{"id":64},"rust-3",[66],{"type":35,"value":67},"rust 3",{"type":17,"tag":69,"props":70,"children":72},"h2",{"id":71},"cve-2022-36114-1",[73],{"type":35,"value":74},"CVE-2022-36114 1",{"type":17,"tag":76,"props":77,"children":82},"cve-info",{":type":78,"cve":79,"to":80,":cwe":81},"2","CVE-2022-36114","https://nvd.nist.gov/vuln/detail/CVE-2022-36114","400",[83],{"type":17,"tag":31,"props":84,"children":85},{},[86],{"type":35,"value":87},"不受控制的资源消耗",{"type":17,"tag":31,"props":89,"children":90},{},[91,93,102,104,111,113,120,122,129],{"type":35,"value":92},"利用 Cargo 的 ",{"type":17,"tag":94,"props":95,"children":99},"a",{"href":96,"rel":97},"https://doc.rust-lang.org/cargo/reference/build-scripts.html",[98],"nofollow",[100],{"type":35,"value":101},"build script",{"type":35,"value":103}," 在构建阶段编译第三方的非 Rust code，同时结合 ",{"type":17,"tag":94,"props":105,"children":108},{"href":106,"rel":107},"https://doc.rust-lang.org/book/ch20-05-macros.html#how-to-write-a-custom-derive-macro",[98],[109],{"type":35,"value":110},"procedural macros",{"type":35,"value":112},"，在执行 ",{"type":17,"tag":114,"props":115,"children":117},"code",{"className":116},[],[118],{"type":35,"value":119},"cargo run",{"type":35,"value":121}," 的过程中触发了一个 ",{"type":17,"tag":94,"props":123,"children":126},{"href":124,"rel":125},"https://en.wikipedia.org/wiki/Zip_bomb",[98],[127],{"type":35,"value":128},"Zip Bomb",{"type":35,"value":130}," 行为。",{"type":17,"tag":31,"props":132,"children":133},{},[134,136,143],{"type":35,"value":135},"对于这个问题的修复，rust-lang 已经给出了一个 ",{"type":17,"tag":94,"props":137,"children":140},{"href":138,"rel":139},"https://github.com/rust-lang/wg-security-response/blob/4bbe734e6404ece6f4e85027564f8995d4ab70e0/patches/CVE-2022-36114/0001-CVE-2022-36114-limit-the-maximum-unpacked-size-of-a-.patch",[98],[141],{"type":35,"value":142},"补丁修复",{"type":35,"value":144}," Zip_bomb 的问题:",{"type":17,"tag":146,"props":147,"children":152},"pre",{"code":148,"language":149,"meta":7,"className":150},"// 在解压 .crate 文件（tar.gz）时，限制最多只能解压出 512MB 的内容。\n+const MAX_UNPACK_SIZE: u64 = 512 * 1024 * 1024;\n","c",[151],"language-c",[153],{"type":17,"tag":114,"props":154,"children":155},{"__ignoreMap":7},[156],{"type":35,"value":148},{"type":17,"tag":31,"props":158,"children":159},{},[160,162,168,170,177],{"type":35,"value":161},"同时引入了 ",{"type":17,"tag":114,"props":163,"children":165},{"className":164},[],[166],{"type":35,"value":167},"LimitErrorReader",{"type":35,"value":169},": 超过就抛出错误，避免资源被耗尽（比如磁盘写爆）。除此之外并没有对 macros、build 加以限制，只是建议尽可能的用 ",{"type":17,"tag":94,"props":171,"children":174},{"href":172,"rel":173},"https://crates.io/",[98],[175],{"type":35,"value":176},"crates",{"type":35,"value":178}," 上提交的 crate。",{"type":17,"tag":58,"props":180,"children":181},{},[],{"type":17,"tag":69,"props":183,"children":185},{"id":184},"cve-2023-40030-1",[186],{"type":35,"value":187},"CVE-2023-40030 1",{"type":17,"tag":76,"props":189,"children":194},{":type":190,"cve":191,"to":192,":cwe":193},"1","CVE-2023-40030","https://nvd.nist.gov/vuln/detail/cve-2023-40030","79",[195],{"type":17,"tag":31,"props":196,"children":197},{},[198,200],{"type":35,"value":199},"{OWASP TOP TEN}: 不恰当的网页生成输入中和 XSS",{"type":17,"tag":201,"props":202,"children":203},"br",{},[],{"type":17,"tag":31,"props":205,"children":206},{},[207,209,215,217,224],{"type":35,"value":208},"看到这篇通告的时候，我就回想起为什么我看 ",{"type":17,"tag":114,"props":210,"children":212},{"className":211},[],[213],{"type":35,"value":214},"cargo build --timings",{"type":35,"value":216}," 的时候肿么没想到会有 CWE-79。",{"type":17,"tag":94,"props":218,"children":221},{"href":219,"rel":220},"https://doc.rust-lang.org/cargo/reference/timings.html",[98],[222],{"type":35,"value":223},"--timings",{"type":35,"value":225}," 是一个生成 build 时间的 html 报告。",{"type":17,"tag":31,"props":227,"children":228},{},[229,231,237,239,245,247,253,255,261],{"type":35,"value":230},"可以通过在 ",{"type":17,"tag":114,"props":232,"children":234},{"className":233},[],[235],{"type":35,"value":236},"Cargo.toml",{"type":35,"value":238}," 中加入 ",{"type":17,"tag":114,"props":240,"children":242},{"className":241},[],[243],{"type":35,"value":244},"features = [\"\u003Cimg src='' onerror=alert(0)\"]",{"type":35,"value":246}," 来触发一个 CWE-79, 因此对这个问题的修复就是，将之前的 ",{"type":17,"tag":114,"props":248,"children":250},{"className":249},[],[251],{"type":35,"value":252},"Warning",{"type":35,"value":254},", 换成了 ",{"type":17,"tag":114,"props":256,"children":258},{"className":257},[],[259],{"type":35,"value":260},"bail!",{"type":35,"value":262}," 机制。",{"type":17,"tag":264,"props":265,"children":267},"text-space",{"type":266},"tip",[268],{"type":17,"tag":31,"props":269,"children":270},{},[271,276,278,285],{"type":17,"tag":114,"props":272,"children":274},{"className":273},[],[275],{"type":35,"value":260},{"type":35,"value":277}," 宏来自 ",{"type":17,"tag":94,"props":279,"children":282},{"href":280,"rel":281},"https://docs.rs/anyhow/latest/anyhow/macro.bail.html",[98],[283],{"type":35,"value":284},"anyhow",{"type":35,"value":286}," 用于方便地提前返回错误。",{"type":17,"tag":31,"props":288,"children":289},{},[290,292,299,301,307],{"type":35,"value":291},"可以看一下 ",{"type":17,"tag":94,"props":293,"children":296},{"href":294,"rel":295},"https://github.com/rust-lang/cargo/commit/9835622853f08be9a4b58ebe29dcec8f43b64b33#diff-99a8f4b284589e7db1aec698aa8f9ef9390f3ee3ecddc399dd6be1aa9ee00388L440-L446",[98],[297],{"type":35,"value":298},"fix pr",{"type":35,"value":300},"，非常有意思，比如 ",{"type":17,"tag":114,"props":302,"children":304},{"className":303},[],[305],{"type":35,"value":306},"validate_feature_name",{"type":35,"value":308}," 函数。",{"type":17,"tag":31,"props":310,"children":311},{},[312,314,320,322],{"type":35,"value":313},"原来：遇到非法 feature name，只输出 ",{"type":17,"tag":114,"props":315,"children":317},{"className":316},[],[318],{"type":35,"value":319},"warning",{"type":35,"value":321},"，流程继续。",{"type":17,"tag":201,"props":323,"children":324},{},[],{"type":17,"tag":146,"props":326,"children":328},{"code":327},"if let Some(ch) = chars.next() {Add commentMore actions\n        if !(unicode_xid::UnicodeXID::is_xid_start(ch) || ch == '_' || ch.is_digit(10)) {\n            config.shell().warn(&format!(\n                \"invalid character `{}` in feature `{}` in package {}, \\\n                the first character must be a Unicode XID start character or digit \\\n                (most letters or `_` or `0` to `9`)\\n\\\n                {}\",\n                ch, name, pkg_id, FUTURE\n            ))?;\n\n        }\n    }\n",[329],{"type":17,"tag":114,"props":330,"children":331},{"__ignoreMap":7},[332],{"type":35,"value":327},{"type":17,"tag":264,"props":334,"children":335},{"type":266},[336],{"type":17,"tag":31,"props":337,"children":338},{},[339],{"type":35,"value":340},"我本来想看看 2025-6-27 的 src/cargo/core/summary.rs 这个 fix pr 的区别。但我发现了一个流量密码，那就是 Rc → Arc, 问就是 Thread Safety！",{"type":17,"tag":31,"props":342,"children":343},{},[344,346,351],{"type":35,"value":345},"现在：遇到非法 feature name，直接 ",{"type":17,"tag":114,"props":347,"children":349},{"className":348},[],[350],{"type":35,"value":260},{"type":35,"value":352},"，构建中止，用户必须修正。",{"type":17,"tag":146,"props":354,"children":356},{"code":355}," if let Some(ch) = chars.next() {Add commentMore actions\n        if !(unicode_xid::UnicodeXID::is_xid_start(ch) || ch == '_' || ch.is_digit(10)) {\n            bail!(\n                \"invalid character `{}` in feature `{}` in package {}, \\\n                the first character must be a Unicode XID start character or digit \\\n                (most letters or `_` or `0` to `9`)\",\n                ch,\n                name,\n                pkg_id\n            );\n        }\n    }\n",[357],{"type":17,"tag":114,"props":358,"children":359},{"__ignoreMap":7},[360],{"type":35,"value":355},{"type":17,"tag":31,"props":362,"children":363},{},[364,366,372,374,380],{"type":35,"value":365},"在单元测试中，来验证 feature name 是否合法，例如只有 ",{"type":17,"tag":114,"props":367,"children":369},{"className":368},[],[370],{"type":35,"value":371},"is_ok()",{"type":35,"value":373}," 是合法的，而 ",{"type":17,"tag":114,"props":375,"children":377},{"className":376},[],[378],{"type":35,"value":379},"is_err()",{"type":35,"value":381}," 是不合法的：",{"type":17,"tag":146,"props":383,"children":385},{"code":384}," #[test]Add commentMore actions\n    fn valid_feature_names() {\n        let loc = CRATES_IO_INDEX.into_url().unwrap();\n        let source_id = SourceId::for_registry(&loc).unwrap();\n        let pkg_id = PackageId::new(\"foo\", \"1.0.0\", source_id).unwrap();\n\n        assert!(validate_feature_name(pkg_id, \"c++17\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"128bit\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"_foo\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"feat-name\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"feat_name\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"foo.bar\").is_ok());\n\n        assert!(validate_feature_name(pkg_id, \"+foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"-foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \".foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"foo:bar\").is_err());\n        assert!(validate_feature_name(pkg_id, \"foo?\").is_err());\n        assert!(validate_feature_name(pkg_id, \"?foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"ⒶⒷⒸ\").is_err());\n        assert!(validate_feature_name(pkg_id, \"a¼\").is_err());\n    }\n",[386],{"type":17,"tag":114,"props":387,"children":388},{"__ignoreMap":7},[389],{"type":35,"value":384},{"type":17,"tag":58,"props":391,"children":392},{},[],{"type":17,"tag":69,"props":394,"children":396},{"id":395},"cve-2023-41051-1",[397],{"type":35,"value":398},"CVE-2023-41051 1",{"type":17,"tag":76,"props":400,"children":404},{":type":190,"cve":401,"to":402,":cwe":403},"CVE-2023-51051","https://nvd.nist.gov/vuln/detail/cve-2023-41051","125",[405],{"type":17,"tag":31,"props":406,"children":407},{},[408],{"type":35,"value":409},"越界访问（out-of-bounds）: 访问了本不属于该内存区域的数据。",{"type":17,"tag":31,"props":411,"children":412},{},[413,420,422,428],{"type":17,"tag":94,"props":414,"children":417},{"href":415,"rel":416},"https://github.com/rust-vmm/vm-memory",[98],[418],{"type":35,"value":419},"vm-memory",{"type":35,"value":421}," 的 ",{"type":17,"tag":114,"props":423,"children":425},{"className":424},[],[426],{"type":35,"value":427},"VolatileMemory",{"type":35,"value":429}," 实现未对边界进行严格校验，导致有可能读取到非法的内存区域：",{"type":17,"tag":431,"props":432,"children":433},"ol",{},[434,446],{"type":17,"tag":435,"props":436,"children":437},"li",{},[438,444],{"type":17,"tag":114,"props":439,"children":441},{"className":440},[],[442],{"type":35,"value":443},"VolatileMemory::get_slice",{"type":35,"value":445},": 返回一段“易失性切片”（VolatileSlice），用于后续的底层操作",{"type":17,"tag":435,"props":447,"children":448},{},[449,455],{"type":17,"tag":114,"props":450,"children":452},{"className":451},[],[453],{"type":35,"value":454},"VolatileMemory::read/write",{"type":35,"value":456},": 直接从这块内存读/写数据，保证每次都实际发生内存访问",{"type":17,"tag":31,"props":458,"children":459},{},[460],{"type":35,"value":461},"VolatileMemory trait 就是定义了一套访问“虚拟机物理内存”或“特殊硬件内存区域”的低层接口，保证每次读写都真实发生，且不被编译器优化。它让不同的底层实现都能用统一的 trait 操作。",{"type":17,"tag":31,"props":463,"children":464},{},[465,467,473,475,481],{"type":35,"value":466},"但问题来了，这个通告并不涉及 ",{"type":17,"tag":114,"props":468,"children":470},{"className":469},[],[471],{"type":35,"value":472},"read/write",{"type":35,"value":474},"，更多的是 ",{"type":17,"tag":114,"props":476,"children":478},{"className":477},[],[479],{"type":35,"value":480},"get_slice",{"type":35,"value":482}," 方法，例如：",{"type":17,"tag":431,"props":484,"children":485},{},[486,495,504,513,522],{"type":17,"tag":435,"props":487,"children":488},{},[489],{"type":17,"tag":114,"props":490,"children":492},{"className":491},[],[493],{"type":35,"value":494},"get_atomic_ref",{"type":17,"tag":435,"props":496,"children":497},{},[498],{"type":17,"tag":114,"props":499,"children":501},{"className":500},[],[502],{"type":35,"value":503},"aligned_as_ref",{"type":17,"tag":435,"props":505,"children":506},{},[507],{"type":17,"tag":114,"props":508,"children":510},{"className":509},[],[511],{"type":35,"value":512},"aligned_as_mut",{"type":17,"tag":435,"props":514,"children":515},{},[516],{"type":17,"tag":114,"props":517,"children":519},{"className":518},[],[520],{"type":35,"value":521},"get_ref",{"type":17,"tag":435,"props":523,"children":524},{},[525],{"type":17,"tag":114,"props":526,"children":528},{"className":527},[],[529],{"type":35,"value":530},"get_array_ref",{"type":17,"tag":31,"props":532,"children":533},{},[534,536,542,544,550],{"type":35,"value":535},"上述方法有个共同点，都是利用 ",{"type":17,"tag":114,"props":537,"children":539},{"className":538},[],[540],{"type":35,"value":541},"ref",{"type":35,"value":543}," 类方法引起的。它们都尝试返回指向底层内存的 Rust 类型引用（如 &T、",{"type":17,"tag":114,"props":545,"children":547},{"className":546},[],[548],{"type":35,"value":549},"&[T]",{"type":35,"value":551}," 等），而不是直接读写原始字节数据。它们的实现通常会调用 get_slice，假设返回的内存区域长度足够大。",{"type":17,"tag":31,"props":553,"children":554},{},[555],{"type":35,"value":556},"如果自定义实现的 get_slice 返回的切片长度不足，就会导致这些 ref 方法产生越界引用，造成内存安全风险。例如：",{"type":17,"tag":431,"props":558,"children":559},{},[560,565,570],{"type":17,"tag":435,"props":561,"children":562},{},[563],{"type":35,"value":564},"这些方法假设 get_slice 返回的 VolatileSlice 长度是你要求的大小（比如 T 是 u32，就要 4 字节）。",{"type":17,"tag":435,"props":566,"children":567},{},[568],{"type":35,"value":569},"如果自定义实现的 get_slice 返回的 VolatileSlice 比你要求的短（比如只返回了2字节）",{"type":17,"tag":435,"props":571,"children":572},{},[573],{"type":35,"value":574},"这些方法还是会照常把这块内存强转成 &T，这时你访问 &T 时就可能会读到超出实际内存范围以外的内容",{"type":17,"tag":31,"props":576,"children":577},{},[578,580,586],{"type":35,"value":579},"仔细欣赏 ",{"type":17,"tag":94,"props":581,"children":584},{"href":582,"rel":583},"https://github.com/rust-vmm/vm-memory/commit/aff1dd4a5259f7deba56692840f7a2d9ca34c9c8#diff-0870facad91de878abbdf4dc43212b8de558021cf0971f62148c2cab381bd150R109-R275",[98],[585],{"type":35,"value":298},{"type":35,"value":587}," 你会发现：",{"type":17,"tag":31,"props":589,"children":590},{},[591,593,599,601,606,608,614],{"type":35,"value":592},"这些方法内部，都会调用 ",{"type":17,"tag":114,"props":594,"children":596},{"className":595},[],[597],{"type":35,"value":598},"get_slice(offset, count)",{"type":35,"value":600}," 拿到一块内存切片，然后把它 reinterpret_cast 成你要的类型引用。因此给 ",{"type":17,"tag":114,"props":602,"children":604},{"className":603},[],[605],{"type":35,"value":480},{"type":35,"value":607}," 加上 ",{"type":17,"tag":114,"props":609,"children":611},{"className":610},[],[612],{"type":35,"value":613},"assert_eq!",{"type":35,"value":615}," 就意味着：",{"type":17,"tag":31,"props":617,"children":618},{},[619],{"type":35,"value":620},"“如果你要 8 字节引用，必须实际拿到 8 字节的内存切片，否则直接 panic，不做 unsafe 操作！”",{"type":17,"tag":58,"props":622,"children":623},{},[],{"type":17,"tag":69,"props":625,"children":627},{"id":626},"cve-2023-38497-1",[628],{"type":35,"value":629},"CVE-2023-38497 1",{"type":17,"tag":76,"props":631,"children":635},{":type":632,"cve":401,"to":633,"cwe":634},"3","https://nvd.nist.gov/vuln/detail/cve-2023-38497","278,732",[636,644],{"type":17,"tag":31,"props":637,"children":638},{},[639,641],{"type":35,"value":640},"278: 不安全的保留继承权限",{"type":17,"tag":201,"props":642,"children":643},{},[],{"type":17,"tag":645,"props":646,"children":647},"ul",{},[648],{"type":17,"tag":435,"props":649,"children":650},{},[651],{"type":35,"value":652},"732: 关键资源的权限分配错误",{"type":17,"tag":31,"props":654,"children":655},{},[656,658,665,667,673,675,680,682,687,689,695,697,703],{"type":35,"value":657},"CWE-278 还是较为冷门的，毕竟只有一个参考，既 ",{"type":17,"tag":94,"props":659,"children":662},{"href":660,"rel":661},"https://www.cve.org/CVERecord?id=CVE-2005-1724",[98],[663],{"type":35,"value":664},"CVE-2005-1724",{"type":35,"value":666},"。CWE-278 这个类的漏洞常见表现之一就是 ",{"type":17,"tag":668,"props":669,"children":670},"strong",{},[671],{"type":35,"value":672},"umask 未生效”",{"type":35,"value":674},"。总的来说 umask 是 ",{"type":17,"tag":668,"props":676,"children":677},{},[678],{"type":35,"value":679},"限制新建文件或目录默认权限的一个机制。",{"type":35,"value":681},"，可以看看 ",{"type":17,"tag":683,"props":684,"children":685},"sup",{},[686],{"type":35,"value":190},{"type":35,"value":688},"，我清晰记得有时候需要执行什么 ",{"type":17,"tag":114,"props":690,"children":692},{"className":691},[],[693],{"type":35,"value":694},"bash",{"type":35,"value":696}," 脚本的时候，会使用 ",{"type":17,"tag":114,"props":698,"children":700},{"className":699},[],[701],{"type":35,"value":702},"chmod 777",{"type":35,"value":704},", 要不然运行不了。",{"type":17,"tag":264,"props":706,"children":707},{"type":266},[708,718,723,744,752],{"type":17,"tag":31,"props":709,"children":710},{},[711,713],{"type":35,"value":712},"CVE-2005-1724 是一个典型的“配置安全限制无效”型漏洞，使得 NFS 导出的目录被所有人都能访问，造成权限绕过和潜在的数据泄露/篡改风险。其归类于 CWE-278 ",{"type":17,"tag":668,"props":714,"children":715},{},[716],{"type":35,"value":717},"属于权限/访问控制失效问题。",{"type":17,"tag":31,"props":719,"children":720},{},[721],{"type":35,"value":722},"而 CWE-732 又是 CWE-278 的子类，因此会有两个 CWE 的分配。",{"type":17,"tag":31,"props":724,"children":725},{},[726,728,734,736,742],{"type":35,"value":727},"比如 CVE-2005-1724 在正常情况下，在导出（export）NFS 文件系统时，通常会用 ",{"type":17,"tag":114,"props":729,"children":731},{"className":730},[],[732],{"type":35,"value":733},"-network",{"type":35,"value":735}," 和 ",{"type":17,"tag":114,"props":737,"children":739},{"className":738},[],[740],{"type":35,"value":741},"-mask",{"type":35,"value":743},"：",{"type":17,"tag":146,"props":745,"children":747},{"code":746},"/some/dir -network 192.168.1.0 -mask 255.255.255.0\n",[748],{"type":17,"tag":114,"props":749,"children":750},{"__ignoreMap":7},[751],{"type":35,"value":746},{"type":17,"tag":31,"props":753,"children":754},{},[755],{"type":35,"value":756},"这样本应只有 192.168.1.0/24 网络内的主机可以访问该目录。但在 Mac OS X 10.4.x 的 NFS 服务实现没有正确处理/生效这些参数。因此构成了 CWE-278",{"type":17,"tag":31,"props":758,"children":759},{},[760,762,767,769,775],{"type":35,"value":761},"要想理解本次的 CVE，我们首先需要理解标题 ",{"type":17,"tag":668,"props":763,"children":764},{},[765],{"type":35,"value":766},"Cargo 在解压 crate 包时未按照 umask 限制文件权限",{"type":35,"value":768},"。而 ",{"type":17,"tag":114,"props":770,"children":772},{"className":771},[],[773],{"type":35,"value":774},"umask",{"type":35,"value":776}," 是默认权限，翻译成人话就是：",{"type":17,"tag":778,"props":779,"children":781},"text-tip",{"type":780},"big",[782],{"type":17,"tag":31,"props":783,"children":784},{},[785,787,793,795,798],{"type":35,"value":786},"Cargo 在解压 crate 包时，没有按照 umask 分个默认的权限。攻击者可以利用这一点也就是 ",{"type":17,"tag":114,"props":788,"children":790},{"className":789},[],[791],{"type":35,"value":792},"777",{"type":35,"value":794}," 权限构建攻击脚本。",{"type":17,"tag":201,"props":796,"children":797},{},[],{"type":35,"value":799},"\n↑ 可能不是很严谨",{"type":17,"tag":31,"props":801,"children":802},{},[803,805],{"type":35,"value":804},"过去 Cargo 解压 .crate 包时，直接采用了压缩包内的文件权限（比如 777/666），",{"type":17,"tag":668,"props":806,"children":807},{},[808],{"type":35,"value":809},"没有结合操作系统的 umask，导致解压后的文件权限过宽，其他本地用户可能能写入、篡改这些源码文件。",{"type":17,"tag":31,"props":811,"children":812},{},[813,815,821,823,829,831,836],{"type":35,"value":814},"在 ",{"type":17,"tag":114,"props":816,"children":818},{"className":817},[],[819],{"type":35,"value":820},"src/cargo/util/mod.rs",{"type":35,"value":822}," 中新增了 ",{"type":17,"tag":114,"props":824,"children":826},{"className":825},[],[827],{"type":35,"value":828},"get_umask()",{"type":35,"value":830}," 函数。以在解压文件时，强制用 ",{"type":17,"tag":114,"props":832,"children":834},{"className":833},[],[835],{"type":35,"value":774},{"type":35,"value":837}," 限制新文件的权限。：",{"type":17,"tag":146,"props":839,"children":841},{"code":840},"#[cfg(unix)]\npub fn get_umask() -> u32 {\n    use std::sync::OnceLock;\n    static UMASK: OnceLock\u003Clibc::mode_t> = OnceLock::new();\n    // SAFETY: Syscalls are unsafe. Calling `umask` twice is even unsafer for\n    // multithreading program, since it doesn't provide a way to retrive the\n    // value without modifications. We use a static `OnceLock` here to ensure\n    // it only gets call once during the entire program lifetime.\n    *UMASK.get_or_init(|| unsafe {\n        let umask = libc::umask(0o022);\n        libc::umask(umask);\n        umask\n    }) as u32 // it is u16 on macos\n}\n",[842],{"type":17,"tag":114,"props":843,"children":844},{"__ignoreMap":7},[845],{"type":35,"value":840},{"type":17,"tag":31,"props":847,"children":848},{},[849],{"type":35,"value":850},"以及很有艺术性的一行 code:",{"type":17,"tag":146,"props":852,"children":854},{"code":853},"fs::set_permissions(path, Permissions::from_mode(final_mode)).unwrap();\n",[855],{"type":17,"tag":114,"props":856,"children":857},{"__ignoreMap":7},[858],{"type":35,"value":853},{"type":17,"tag":31,"props":860,"children":861},{},[862,864,870],{"type":35,"value":863},"解压 crate 时，读取每个文件的原始权限（如 0o777），实际写入磁盘时，会用 原始权限 & ",{"type":17,"tag":114,"props":865,"children":867},{"className":866},[],[868],{"type":35,"value":869},"!umask",{"type":35,"value":871}," 得到最终权限，再 chmod 到文件上:",{"type":17,"tag":146,"props":873,"children":875},{"code":874},"assert_eq!(metadata.mode() & 0o777, 0o644 & !umask);\n",[876],{"type":17,"tag":114,"props":877,"children":878},{"__ignoreMap":7},[879],{"type":35,"value":874},{"type":17,"tag":881,"props":882,"children":885},"div",{"id":883,"className":884},"refer-anchor-1",[541],[886],{"type":17,"tag":645,"props":887,"children":888},{},[889],{"type":17,"tag":435,"props":890,"children":891},{},[892,897,899],{"type":17,"tag":893,"props":894,"children":895},"span",{},[896],{"type":35,"value":190},{"type":35,"value":898}," ",{"type":17,"tag":94,"props":900,"children":903},{"href":901,"rel":902},"https://langzi989.github.io/2017/09/13/Linux%E4%B8%ADumash%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/",[98],[904],{"type":35,"value":901},{"title":7,"searchDepth":906,"depth":906,"links":907},2,[908,909,910,911],{"id":71,"depth":906,"text":74},{"id":184,"depth":906,"text":187},{"id":395,"depth":906,"text":398},{"id":626,"depth":906,"text":629},"markdown","content:book:cve-learn.md","content","book/cve-learn.md","md",1751134868906]