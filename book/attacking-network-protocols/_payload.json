[{"data":1,"prerenderedAt":795},["Reactive",2],{"content-query-SBsbQ6yWni":3},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":7,"director":9,"time":10,"img":11,"plan":12,"body":13,"_type":790,"_id":791,"_source":792,"_file":793,"_extension":794},"/book/attacking-network-protocols","book",false,"","Attacking Network Protocols: A Hacker's Guide to Capture, Analysis, and Exploitation","James Forshaw","2024","01/1.png","1",{"type":14,"children":15,"toc":787},"root",[16],{"type":17,"tag":18,"props":19,"children":24},"element","book-content",{":by":20,":img":21,":plan":22,":title":23},"director","img","plan","title",[25,30,38,62,64,146,160,169,183,196,200,205,210,213,217,223,228,233,238,240,339,344,356,357,423,428,436,441,444,448,454,459,461,523,528,543,548,553,558,560,705,713,718,726,731,735,758,782],{"type":17,"tag":26,"props":27,"children":29},"text-title",{":t":28},"Google Project Zero",[],{"type":17,"tag":31,"props":32,"children":34},"h1",{"id":33},"作者-1",[35],{"type":36,"value":37},"text","作者 1",{"type":17,"tag":39,"props":40,"children":41},"p",{},[42,44,52,54,60],{"type":36,"value":43},"本书的作者是 ",{"type":17,"tag":45,"props":46,"children":50},"a",{"href":47,"rel":48},"https://github.com/tyranid",[49],"nofollow",[51],{"type":36,"value":9},{"type":36,"value":53},"，也是著名的 ",{"type":17,"tag":45,"props":55,"children":58},{"href":56,"rel":57},"https://googleprojectzero.blogspot.com/",[49],[59],{"type":36,"value":28},{"type":36,"value":61}," 成员之一。他负责维护很多开源的分析工具，同时自己也根据多年的经验总结出自己想要的工具。并在一些会议中分享，甚至是 open source。到目前，他已经是一位高级猎食者，从当初的破解游戏机，到揭秘操作系统中的复杂问题，具有十余年应用网络协议分析、利用经验。",{"type":36,"value":63},"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",{"type":17,"tag":65,"props":66,"children":67},"table",{},[68,87],{"type":17,"tag":69,"props":70,"children":71},"thead",{},[72],{"type":17,"tag":73,"props":74,"children":75},"tr",{},[76,82],{"type":17,"tag":77,"props":78,"children":79},"th",{},[80],{"type":36,"value":81},"会议",{"type":17,"tag":77,"props":83,"children":84},{},[85],{"type":36,"value":86},"描述",{"type":17,"tag":88,"props":89,"children":90},"tbody",{},[91,110,128],{"type":17,"tag":73,"props":92,"children":93},{},[94,105],{"type":17,"tag":95,"props":96,"children":97},"td",{},[98],{"type":17,"tag":45,"props":99,"children":102},{"href":100,"rel":101},"https://www.blackhat.com/",[49],[103],{"type":36,"value":104},"BlackHat",{"type":17,"tag":95,"props":106,"children":107},{},[108],{"type":36,"value":109},"国际公认的网络安全活动系列，提供最具技术性和相关性的信息安全研究",{"type":17,"tag":73,"props":111,"children":112},{},[113,123],{"type":17,"tag":95,"props":114,"children":115},{},[116],{"type":17,"tag":45,"props":117,"children":120},{"href":118,"rel":119},"https://www.secwest.net/",[49],[121],{"type":36,"value":122},"CanSecWest",{"type":17,"tag":95,"props":124,"children":125},{},[126],{"type":36,"value":127},"加拿大著名的国际信息安全会议，负责举办 Pwn2Own",{"type":17,"tag":73,"props":129,"children":130},{},[131,141],{"type":17,"tag":95,"props":132,"children":133},{},[134],{"type":17,"tag":45,"props":135,"children":138},{"href":136,"rel":137},"https://events.ccc.de/",[49],[139],{"type":36,"value":140},"Chaos Computer Conference",{"type":17,"tag":95,"props":142,"children":143},{},[144],{"type":36,"value":145},"由德国 CCC 组织，以其独特的社区文化、技术讨论和社会议题探讨而闻名",{"type":17,"tag":39,"props":147,"children":148},{},[149,151,158],{"type":36,"value":150},"作者的经历非常 Nice! 有一个良好的家庭，无论做什么都鼓励孩子的家长。走入职场有 Richard Nea 这样不内耗的好 ",{"type":17,"tag":45,"props":152,"children":155},{"href":153,"rel":154},"https://en.wikipedia.org/wiki/Line_management",[49],[156],{"type":36,"value":157},"Leader(line manager)",{"type":36,"value":159}," 同时发现了作者对 Security 领域有浓厚的兴趣并符合其性格。",{"type":17,"tag":161,"props":162,"children":163},"text-tip",{},[164],{"type":17,"tag":39,"props":165,"children":166},{},[167],{"type":36,"value":168},"直线领导(Line manager) 通常指的是直接参与工作并需要对同事工作负责的领导，通常负责指导同事能在特定的职能领域下完成团队或公司的目标。",{"type":17,"tag":39,"props":170,"children":171},{},[172,174,181],{"type":36,"value":173},"在规划职业路径阶段认识了 ",{"type":17,"tag":45,"props":175,"children":178},{"href":176,"rel":177},"https://www.linkedin.com/in/mike-jordon-72193719/",[49],[179],{"type":36,"value":180},"Mike Jordon",{"type":36,"value":182}," 在初创阶段进入到了 Context Information Security。与公司的创始团队学习，并培养其网络协议分析方面的技能，并开发了 Canape 等工具。这些不内耗的好 Leader，给了其充足的时间进行有前途的安全研究。",{"type":17,"tag":161,"props":184,"children":185},{},[186,191],{"type":17,"tag":39,"props":187,"children":188},{},[189],{"type":36,"value":190},"2020 年 3 月，世界 500 TOP 之一的 NYSE: ACN 已收购领先的网络防御咨询公司 Context Information Security，该公司之前由母公司 Babcock International Group 所有。Context 成立于 1998 年，总部位于伦敦，是英国和全球金融服务领域最知名、最受尊敬的信息安全服务提供商之一。该公司提供高端网络防御、情报驱动的红队、漏洞研究和事件响应服务。他们曾参与处理业内一些最先进的事件响应案例。",{"type":17,"tag":39,"props":192,"children":193},{},[194],{"type":36,"value":195},"Mike Jordon 曾经是 Context 的首席信息顾问，自 2020 年起为 Airis Security Technologies 的首席技术官。",{"type":17,"tag":197,"props":198,"children":199},"hr",{},[],{"type":17,"tag":39,"props":201,"children":202},{},[203],{"type":36,"value":204},"我之所以阅读这本书，是因为在我的生活中，几乎还未遇到和协议有关的事情（除了一些常见的场景，如 burp、nmap 这些基础的，或者一些涉及到流量分析的题目）。虽然我见过通过 Wireshark 来调试 API 的，但我认为这些远远不是 Wireshark 的全部功能。",{"type":17,"tag":39,"props":206,"children":207},{},[208],{"type":36,"value":209},"在本书中虽然几乎都是用作者所开发的 Canape ，还包括了很多网络协议工具包，这些工具很多都是家喻户晓的，但成体系和系统性的学习，是我经历所缺少的部分。同时也希望提升自己在网络协议上面的见解，并扩充下眼界。",{"type":17,"tag":197,"props":211,"children":212},{},[],{"type":17,"tag":26,"props":214,"children":216},{":t":215},"协议是一切的基础",[],{"type":17,"tag":31,"props":218,"children":220},{"id":219},"基础-2",[221],{"type":36,"value":222},"基础 2",{"type":17,"tag":39,"props":224,"children":225},{},[226],{"type":36,"value":227},"\"对常见网络的构建和功能了解得越多，就越容易将这些知识应用于捕获、分析和利用新协议。\" 这句话出在第一章的概述，小时候。我就对 IETF 非常崇拜，并不是因为他们的宣传，而是朴实无华的运行风格。",{"type":17,"tag":39,"props":229,"children":230},{},[231],{"type":36,"value":232},"还记得第一次看到 IETF 的出版物，被 RFC 的简洁所震撼。这种朴实无华的风格，不仅简洁还充满了复古风味内容也相当丰富，记录了一个协议和提案标准的各类信息。以及协议提案的流程，该提案所经aaaa历过的所有环节依次公开。",{"type":17,"tag":39,"props":234,"children":235},{},[236],{"type":36,"value":237},"一个标准的协议具有很多或很少的功能，但他们几乎或多或少符合下面六项特点中的一项：",{"type":36,"value":239},"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",{"type":17,"tag":65,"props":241,"children":242},{},[243,258],{"type":17,"tag":69,"props":244,"children":245},{},[246],{"type":17,"tag":73,"props":247,"children":248},{},[249,254],{"type":17,"tag":77,"props":250,"children":251},{},[252],{"type":36,"value":253},"功能",{"type":17,"tag":77,"props":255,"children":256},{},[257],{"type":36,"value":86},{"type":17,"tag":88,"props":259,"children":260},{},[261,274,287,300,313,326],{"type":17,"tag":73,"props":262,"children":263},{},[264,269],{"type":17,"tag":95,"props":265,"children":266},{},[267],{"type":36,"value":268},"维护会话状态",{"type":17,"tag":95,"props":270,"children":271},{},[272],{"type":36,"value":273},"创建新的连接或终止连接",{"type":17,"tag":73,"props":275,"children":276},{},[277,282],{"type":17,"tag":95,"props":278,"children":279},{},[280],{"type":36,"value":281},"通过寻址识别节点",{"type":17,"tag":95,"props":283,"children":284},{},[285],{"type":36,"value":286},"数据需要传输到对应的节点，因此协议通过寻址来识别特定的节点或组",{"type":17,"tag":73,"props":288,"children":289},{},[290,295],{"type":17,"tag":95,"props":291,"children":292},{},[293],{"type":36,"value":294},"控制流量",{"type":17,"tag":95,"props":296,"children":297},{},[298],{"type":36,"value":299},"一次性通过网络传输的量是有限的。协议通过实施管理数据流，以提高吞吐减少延迟",{"type":17,"tag":73,"props":301,"children":302},{},[303,308],{"type":17,"tag":95,"props":304,"children":305},{},[306],{"type":36,"value":307},"保证传输数据的顺序",{"type":17,"tag":95,"props":309,"children":310},{},[311],{"type":36,"value":312},"将发送和接收到分散且混乱的数据重新排序，以保证数据的正确顺序",{"type":17,"tag":73,"props":314,"children":315},{},[316,321],{"type":17,"tag":95,"props":317,"children":318},{},[319],{"type":36,"value":320},"检测和纠正错误",{"type":17,"tag":95,"props":322,"children":323},{},[324],{"type":36,"value":325},"网络不是 100% 可靠的;数据可能会损坏。检测损坏并理想情况下纠正它非常重要",{"type":17,"tag":73,"props":327,"children":328},{},[329,334],{"type":17,"tag":95,"props":330,"children":331},{},[332],{"type":36,"value":333},"格式化和编码数据",{"type":17,"tag":95,"props":335,"children":336},{},[337],{"type":36,"value":338},"数据并不适合在网络中传输，例如将英语文本编码为二进制值；协议可以指定对数据进行编码甚至加密",{"type":17,"tag":39,"props":340,"children":341},{},[342],{"type":36,"value":343},"我们都了解很多传输协议，这些协议是基础的。但很多时候，这些协议都是背后的一条条数据流，我们浏览网页，使用 APP 不需要思考这些是如何进行的，死记硬背不仅内耗自己，还花了很多时间，但在工作中几乎只有面试时才会用到。而基础章节中，作者总结出了自己的一套模型：",{"type":17,"tag":345,"props":346,"children":350},"pre",{"code":347,"language":36,"meta":7,"className":348},"┌──────────────────────────────┐\n│        Protocol model        │\n│                              │\n│  ┌────────────────────────┐  │\n│  │     Content layer      │  │   I would like to get the file image.png\n│  │     (File request)     │  │\n│  └───────────▲────────────┘  │\n│              │               │\n│  ┌───────────▼────────────┐  │\n│  │     Encoding layer     │  │   GET /image.png HTTP/1.1\n│  │         (HTTP)         │  │\n│  └───────────▲────────────┘  │\n│              │               │\n│  ┌───────────▼────────────┐  │\n│  │    Transport layer     │  │   4500 0043 50d1 4000 8000 c0a8 0a6d\n│  │        (TCP/IP)        │  │   d83a d544 40e0 0050 5dff a4e6 6ac2\n│  └────────────────────────┘  │   ……\n│                              │\n└──────────────────────────────┘\n",[349],"language-text",[351],{"type":17,"tag":352,"props":353,"children":354},"code",{"__ignoreMap":7},[355],{"type":36,"value":347},{"type":36,"value":63},{"type":17,"tag":65,"props":358,"children":359},{},[360,375],{"type":17,"tag":69,"props":361,"children":362},{},[363],{"type":17,"tag":73,"props":364,"children":365},{},[366,371],{"type":17,"tag":77,"props":367,"children":368},{},[369],{"type":36,"value":370},"协议模型",{"type":17,"tag":77,"props":372,"children":373},{},[374],{"type":36,"value":86},{"type":17,"tag":88,"props":376,"children":377},{},[378,391,404],{"type":17,"tag":73,"props":379,"children":380},{},[381,386],{"type":17,"tag":95,"props":382,"children":383},{},[384],{"type":36,"value":385},"内容层 (文件请求)",{"type":17,"tag":95,"props":387,"children":388},{},[389],{"type":36,"value":390},"我想要一个 image.png 图片",{"type":17,"tag":73,"props":392,"children":393},{},[394,399],{"type":17,"tag":95,"props":395,"children":396},{},[397],{"type":36,"value":398},"编码层 (HTTP)",{"type":17,"tag":95,"props":400,"children":401},{},[402],{"type":36,"value":403},"GET /image.png HTTP/1.1",{"type":17,"tag":73,"props":405,"children":406},{},[407,412],{"type":17,"tag":95,"props":408,"children":409},{},[410],{"type":36,"value":411},"传输层 (TCP/IP)",{"type":17,"tag":95,"props":413,"children":414},{},[415,417,421],{"type":36,"value":416},"4500 0043 50d1 4000 8000 c0a8 0a6d ",{"type":17,"tag":418,"props":419,"children":420},"br",{},[],{"type":36,"value":422}," d83a d544 40e0 0050 5dff a4e6 6ac2 ……",{"type":17,"tag":39,"props":424,"children":425},{},[426],{"type":36,"value":427},"作者的这套网络模型，几乎概述了传输所涵盖的三个特点，即内容、寻址、传输等三个功能的概念化，因此适用于总结或对一个陌生的协议时的理解步骤。毕竟协议是可以自定义的，例如通过 Matrix 就可以自定义一个通信协议。",{"type":17,"tag":161,"props":429,"children":430},{},[431],{"type":17,"tag":39,"props":432,"children":433},{},[434],{"type":36,"value":435},"\"以这种方式拆分模型可以降低特定于应用程序的协议的复杂性，因为它允许我们过滤掉不相关的网络协议详细信息。例如，因为我们并不真正关心 TCP/IP 是如何发送到远程节点的（我们理所当然地认为它会以某种方式到达那里），所以我们只是将 TCP/IP 数据视为正常工作的二进制传输。\"",{"type":17,"tag":39,"props":437,"children":438},{},[439],{"type":36,"value":440},"这一章节非常有意思，可以看一下原文 第一章：My Model for Network Protocol Analysis，给出了很多贴近该模型的案例。作者是一个不内耗的人，不会解说一堆 RFC 文件和 Wikipedia 中的内容，仅列举其作用和描述，让读者感兴趣的地方可以深入了解，并得出自己的见解。",{"type":17,"tag":197,"props":442,"children":443},{},[],{"type":17,"tag":26,"props":445,"children":447},{":t":446},"流量捕获",[],{"type":17,"tag":31,"props":449,"children":451},{"id":450},"捕获-3",[452],{"type":36,"value":453},"捕获 3",{"type":17,"tag":39,"props":455,"children":456},{},[457],{"type":36,"value":458},"针对流量的捕获分为主动和被动捕获，他们分别在不同的场景有不同的用处，对于主动捕获，甚至可以进行中间人攻击，如经常用到的 Burp Suite。",{"type":36,"value":460},"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",{"type":17,"tag":65,"props":462,"children":463},{},[464,484],{"type":17,"tag":69,"props":465,"children":466},{},[467],{"type":17,"tag":73,"props":468,"children":469},{},[470,475,479],{"type":17,"tag":77,"props":471,"children":472},{},[473],{"type":36,"value":474},"名称",{"type":17,"tag":77,"props":476,"children":477},{},[478],{"type":36,"value":86},{"type":17,"tag":77,"props":480,"children":481},{},[482],{"type":36,"value":483},"特点",{"type":17,"tag":88,"props":485,"children":486},{},[487,505],{"type":17,"tag":73,"props":488,"children":489},{},[490,495,500],{"type":17,"tag":95,"props":491,"children":492},{},[493],{"type":36,"value":494},"被动捕获",{"type":17,"tag":95,"props":496,"children":497},{},[498],{"type":36,"value":499},"在线路上传输时提取数据，如 Wireshark",{"type":17,"tag":95,"props":501,"children":502},{},[503],{"type":36,"value":504},"不直接与流量交互",{"type":17,"tag":73,"props":506,"children":507},{},[508,513,518],{"type":17,"tag":95,"props":509,"children":510},{},[511],{"type":36,"value":512},"主动捕获",{"type":17,"tag":95,"props":514,"children":515},{},[516],{"type":36,"value":517},"干扰客户端应用程序与服务器之间的流量，类似 Burp 中通过代理进行拦截。",{"type":17,"tag":95,"props":519,"children":520},{},[521],{"type":36,"value":522},"直接与服务器之间的流量产生干扰甚至是拦截、篡改",{"type":17,"tag":39,"props":524,"children":525},{},[526],{"type":36,"value":527},"除了 Wireshark 和 Burp，还有很多针对不同场景下会使用的工具，这里作者列举了几个我很感兴趣的场景，是不适用于被动捕获的：",{"type":17,"tag":529,"props":530,"children":531},"ol",{},[532,538],{"type":17,"tag":533,"props":534,"children":535},"li",{},[536],{"type":36,"value":537},"在没有管理访问权限的系统或具有有限权限 shell 的移动设备上执行审计",{"type":17,"tag":533,"props":539,"children":540},{},[541],{"type":36,"value":542},"只查看正在测试的应用程序的流量",{"type":17,"tag":39,"props":544,"children":545},{},[546],{"type":36,"value":547},"作者演示了通过各种工具，从系统的工作原理来实现如何从本地应用程序提取网络流量的演示，这是我非常感兴趣的。其中有很多涉及到了操作系统原理和设计，想必这就是为什么要学操作系统设计和原理吧。",{"type":17,"tag":26,"props":549,"children":552},{":t":550,":type":551},"系统调用跟踪","2",[],{"type":17,"tag":39,"props":554,"children":555},{},[556],{"type":36,"value":557},"许多现代系统提供了两种执行模式，分别为用户模式和内核模式。以提高系统的稳定性和安全性，保护系统免受不可信用户代码的影响。我体验过 Windows、Macos、Linux 这三个生态的系统，我的感受就是。",{"type":36,"value":559},"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",{"type":17,"tag":65,"props":561,"children":562},{},[563,582],{"type":17,"tag":69,"props":564,"children":565},{},[566],{"type":17,"tag":73,"props":567,"children":568},{},[569,574,578],{"type":17,"tag":77,"props":570,"children":571},{},[572],{"type":36,"value":573},"模式",{"type":17,"tag":77,"props":575,"children":576},{},[577],{"type":36,"value":86},{"type":17,"tag":77,"props":579,"children":580},{},[581],{"type":36,"value":483},{"type":17,"tag":88,"props":583,"children":584},{},[585,603,617,631,645,663,677,691],{"type":17,"tag":73,"props":586,"children":587},{},[588,593,598],{"type":17,"tag":95,"props":589,"children":590},{},[591],{"type":36,"value":592},"用户模式",{"type":17,"tag":95,"props":594,"children":595},{},[596],{"type":36,"value":597},"操作系统普通应用程序和用户空间进程运行的模式",{"type":17,"tag":95,"props":599,"children":600},{},[601],{"type":36,"value":602},"权限限制",{"type":17,"tag":73,"props":604,"children":605},{},[606,609,612],{"type":17,"tag":95,"props":607,"children":608},{},[],{"type":17,"tag":95,"props":610,"children":611},{},[],{"type":17,"tag":95,"props":613,"children":614},{},[615],{"type":36,"value":616},"隔离",{"type":17,"tag":73,"props":618,"children":619},{},[620,623,626],{"type":17,"tag":95,"props":621,"children":622},{},[],{"type":17,"tag":95,"props":624,"children":625},{},[],{"type":17,"tag":95,"props":627,"children":628},{},[629],{"type":36,"value":630},"限制对系统资源的直接访问",{"type":17,"tag":73,"props":632,"children":633},{},[634,637,640],{"type":17,"tag":95,"props":635,"children":636},{},[],{"type":17,"tag":95,"props":638,"children":639},{},[],{"type":17,"tag":95,"props":641,"children":642},{},[643],{"type":36,"value":644},"日常应用程序的运行",{"type":17,"tag":73,"props":646,"children":647},{},[648,653,658],{"type":17,"tag":95,"props":649,"children":650},{},[651],{"type":36,"value":652},"内核模式",{"type":17,"tag":95,"props":654,"children":655},{},[656],{"type":36,"value":657},"操作系统核心代码，具有对系统资源的完全访问权限",{"type":17,"tag":95,"props":659,"children":660},{},[661],{"type":36,"value":662},"完全权限",{"type":17,"tag":73,"props":664,"children":665},{},[666,669,672],{"type":17,"tag":95,"props":667,"children":668},{},[],{"type":17,"tag":95,"props":670,"children":671},{},[],{"type":17,"tag":95,"props":673,"children":674},{},[675],{"type":36,"value":676},"关键操作",{"type":17,"tag":73,"props":678,"children":679},{},[680,683,686],{"type":17,"tag":95,"props":681,"children":682},{},[],{"type":17,"tag":95,"props":684,"children":685},{},[],{"type":17,"tag":95,"props":687,"children":688},{},[689],{"type":36,"value":690},"直接访问和控制系统资源",{"type":17,"tag":73,"props":692,"children":693},{},[694,697,700],{"type":17,"tag":95,"props":695,"children":696},{},[],{"type":17,"tag":95,"props":698,"children":699},{},[],{"type":17,"tag":95,"props":701,"children":702},{},[703],{"type":36,"value":704},"系统级调用",{"type":17,"tag":161,"props":706,"children":707},{},[708],{"type":17,"tag":39,"props":709,"children":710},{},[711],{"type":36,"value":712},"总结来说，内核模式以高权限运行，并包含实现操作系统核心功能的代码。用户模式是运行日常流程的地方，内核通过导出一组特殊系统调用为用户模式提供服务，允许用户访问文件、创建进程。",{"type":17,"tag":39,"props":714,"children":715},{},[716],{"type":36,"value":717},"在 Windows 系统中，你是 Administrators；在 Linux 中，你是 Developers；而在 macOS 中，你只是一个普普通通的 User。这是我对这三个生态中系统执行模式的切身感受。",{"type":17,"tag":345,"props":719,"children":721},{"code":720},"┌─────────────────────────────────────────────────┐                                 \n│                                                 │                      ┌──────   ┐\n│                                                 │                      │       S │\n│   ┌────────────────────────┬────────────────┐   │                      │       e │\n│   │                        │    Network     │   │                      │       r │\n│   │         Kernel         │   subsystem    │◀──┼─────  Network  ──────┤       v │\n│   │                        │                │   │                      │       i │\n│   └────────────────────────┴─────────────▲──┘   │                      │       c │\n│                                          │      │                      │       e │\n│                                          │      │                      └──────   ┘\n│                                                 │                                 \n│                                          S      │                                 \n│                                          y      │                                 \n│                                          s      │                                 \n│                                          t      │                                 \n│                                          e      │                                 \n│   ──────────   Kernel/User model    ──── m      │                                 \n│                                                 │                                 \n│                                          c      │                                 \n│                                          a      │                                 \n│                                          l      │                                 \n│                                          l      │                                 \n│                                                 │                                 \n│                                          │      │                                 \n│                                          │      │                                 \n│   ┌──────────────────────────────────────┴──┐   │                                 \n│   │                                         │   │                                 \n│   │             System libraies             │   │                                 \n│   │                                         │   │                                 \n│   ├─────────────────────────────────────────┤   │                                 \n│   │                                         │   │                                 \n│   │                                         │   │                                 \n│   │           Client application            │   │                                 \n│   │                                         │   │                                 \n│   │                                         │   │                                 \n│   └─────────────────────────────────────────┘   │                                 \n│                                                 │                                 \n│                                                 │                                 \n└─────────────────────────────────────────────────┘                                 \n",[722],{"type":17,"tag":352,"props":723,"children":724},{"__ignoreMap":7},[725],{"type":36,"value":720},{"type":17,"tag":39,"props":727,"children":728},{},[729],{"type":36,"value":730},"当应用程序想要连接远程服务器时，应用程序会向操作系统内核发出系统调用以打开连接。之后应用程序读取和写入网络数据，因此我们可以通过监测这之间的过程，而实现对目标应用程序的网络捕获，作者给出了一个非常通俗易懂的图，简单的概括了这其中的一系列过程，简洁明了。",{"type":17,"tag":26,"props":732,"children":734},{":t":733,":type":551},"网络编程的基础",[],{"type":17,"tag":39,"props":736,"children":737},{},[738,740,747,749,756],{"type":36,"value":739},"大多时候，我们在学习各类 code 语言的时。或多或少都会接触网络编程，比如耳熟能详的 Socket。这就要说到 IP 协议的首个实现是在 ",{"type":17,"tag":45,"props":741,"children":744},{"href":742,"rel":743},"https://en.wikipedia.org/wiki/Berkeley_Software_Distribution",[49],[745],{"type":36,"value":746},"Berkeley Software Distribution（BSD）",{"type":36,"value":748}," 完成的。因此在网络通信领域中，就离不开 ",{"type":17,"tag":45,"props":750,"children":753},{"href":751,"rel":752},"https://en.wikipedia.org/wiki/Berkeley_sockets",[49],[754],{"type":36,"value":755},"Berkeley Sockets",{"type":36,"value":757},"，它作为网络编程的基础，提供了不同主机之间进行网络通信的标准接口。",{"type":17,"tag":161,"props":759,"children":760},{},[761],{"type":17,"tag":39,"props":762,"children":763},{},[764,766,772,774,780],{"type":36,"value":765},"如果你是类 Unix 系统，可以在终端输入 ",{"type":17,"tag":352,"props":767,"children":769},{"className":768},[],[770],{"type":36,"value":771},"man 2 syscall_name",{"type":36,"value":773}," 在终端中查看手册，比如 ",{"type":17,"tag":352,"props":775,"children":777},{"className":776},[],[778],{"type":36,"value":779},"man 2 open",{"type":36,"value":781}," 就可以查看系统调用第二章有关 open 的内容。",{"type":17,"tag":39,"props":783,"children":784},{},[785],{"type":36,"value":786},"它主要定义了一系列的系统调用，允许应用程序通过网络发送和接收数据。广为人知的就是 close()、connect()、socket()、listen()、send(), 这些 Berkeley_sockets 被纳入 POSIX 标准的一部分。",{"title":7,"searchDepth":788,"depth":788,"links":789},2,[],"markdown","content:book:attacking-network-protocols.md","content","book/attacking-network-protocols.md","md",1724082841945]