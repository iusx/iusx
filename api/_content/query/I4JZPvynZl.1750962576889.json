{"_path":"/book/cve-learn","_dir":"book","_draft":false,"_partial":false,"_locale":"","title":"CVE learn","description":"","director":"My","time":"2025","img":"14/1.png","plan":"100,100","body":{"type":"root","children":[{"type":"element","tag":"book-content","props":{":by":"director",":img":"img",":plan":"plan",":title":"title"},"children":[{"type":"element","tag":"text-title","props":{":t":"CVE is my dream."},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"早在我上小学时，就觉得 CVE 很帅。步入初中时，在初三那年我拿到了广东电信 IPTV 的通用漏洞。步入社会时，我拿到了 Github 的 Bug bounty。但我始终没有去拿一个 CVE 的编号。因为水是可以水的，但我已经水了 CNVD 和 Hackerone，我希望我的第一个 CVE 编号可以是不那么水的，有一点含金量的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"虽然我并不是 Security 行业或领域的从业人员，只是一个爱好者。但我一直觉得 Security 很帅。同样的，虽然我不是 Design 行业的从业人员，但我觉得可以让自己做出来的 project 会好看，有个性。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我并不是一个专精的人。很多时候我每项感兴趣的领域单拎出来都会被降维打击。虽然我单项领域无法媲美专业的从业者，但我感兴趣的领域都有点建树和作品。将 Security、Design、Animation、Computer 合在一起，与之能媲美的人可能会少那么一点。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而现在，我只有 Design 的代表作，而 Security、Animation、Computer 还没有一个能拿得出手的作品。因此我希望会在未来三年，尽可能的补全这些我感兴趣领域的代表作。可能因为 Work 比较闲的缘故，我的时间总会多那么一点来放到我感兴趣的领域上。即使达不到也没有关系，至少也是努力过了，无论如何三年后的自己总会比现在的自己稍微厉害那么一点点。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因此这个页面会记录一些我感兴趣的 CVE 和 CWE 的编号来让我学习，可能会获取到一些新的思路和对某个方面的理解。来帮助我实现这个目标，顺便看看冷门的 CWE 方向，毕竟 OWASP TOP 10 个人没有太大的兴趣。"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h1","props":{"id":"cve-2022-36114-1"},"children":[{"type":"text","value":"CVE-2022-36114 1"}]},{"type":"element","tag":"cve-info","props":{":cwe":"400",":type":"2","cve":"CVE-2022-36114","to":"https://nvd.nist.gov/vuln/detail/CVE-2022-36114"},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不受控制的资源消耗"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"利用 Cargo 的 "},{"type":"element","tag":"a","props":{"href":"https://doc.rust-lang.org/cargo/reference/build-scripts.html","rel":["nofollow"]},"children":[{"type":"text","value":"build script"}]},{"type":"text","value":" 在构建阶段编译第三方的非 Rust code，同时结合 "},{"type":"element","tag":"a","props":{"href":"https://doc.rust-lang.org/book/ch20-05-macros.html#how-to-write-a-custom-derive-macro","rel":["nofollow"]},"children":[{"type":"text","value":"procedural macros"}]},{"type":"text","value":"，在执行 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"cargo run"}]},{"type":"text","value":" 的过程中触发了一个 "},{"type":"element","tag":"a","props":{"href":"https://en.wikipedia.org/wiki/Zip_bomb","rel":["nofollow"]},"children":[{"type":"text","value":"Zip Bomb"}]},{"type":"text","value":" 行为。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于这个问题的修复，rust-lang 已经给出了一个 "},{"type":"element","tag":"a","props":{"href":"https://github.com/rust-lang/wg-security-response/blob/4bbe734e6404ece6f4e85027564f8995d4ab70e0/patches/CVE-2022-36114/0001-CVE-2022-36114-limit-the-maximum-unpacked-size-of-a-.patch","rel":["nofollow"]},"children":[{"type":"text","value":"补丁修复"}]},{"type":"text","value":" Zip_bomb 的问题:"}]},{"type":"element","tag":"pre","props":{"code":"// 在解压 .crate 文件（tar.gz）时，限制最多只能解压出 512MB 的内容。\n+const MAX_UNPACK_SIZE: u64 = 512 * 1024 * 1024;\n","language":"c","meta":"","className":["language-c"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// 在解压 .crate 文件（tar.gz）时，限制最多只能解压出 512MB 的内容。\n+const MAX_UNPACK_SIZE: u64 = 512 * 1024 * 1024;\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"同时引入了 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LimitErrorReader"}]},{"type":"text","value":": 超过就抛出错误，避免资源被耗尽（比如磁盘写爆）。除此之外并没有对 macros、build 加以限制，只是建议尽可能的用 "},{"type":"element","tag":"a","props":{"href":"https://crates.io/","rel":["nofollow"]},"children":[{"type":"text","value":"crates"}]},{"type":"text","value":" 上提交的 crate。"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h1","props":{"id":"cve-2023-40030-1"},"children":[{"type":"text","value":"CVE-2023-40030 1"}]},{"type":"element","tag":"cve-info","props":{":cwe":"79",":type":"1","cve":"CVE-2023-40030","to":"https://nvd.nist.gov/vuln/detail/cve-2023-40030"},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"{OWASP TOP TEN}: 不恰当的网页生成输入中和 XSS"},{"type":"element","tag":"br","props":{},"children":[]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"看到这篇通告的时候，我就回想起为什么我看 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"cargo build --timings"}]},{"type":"text","value":" 的时候肿么没想到会有 CWE-79。"},{"type":"element","tag":"a","props":{"href":"https://doc.rust-lang.org/cargo/reference/timings.html","rel":["nofollow"]},"children":[{"type":"text","value":"--timings"}]},{"type":"text","value":" 是一个生成 build 时间的 html 报告。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以通过在 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Cargo.toml"}]},{"type":"text","value":" 中加入 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"features = [\"<img src='' onerror=alert(0)\"]"}]},{"type":"text","value":" 来触发一个 CWE-79, 因此对这个问题的修复就是，将之前的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Warning"}]},{"type":"text","value":", 换成了 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"bail!"}]},{"type":"text","value":" 机制。"}]},{"type":"element","tag":"text-space","props":{"type":"tip"},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"bail!"}]},{"type":"text","value":" 宏来自 "},{"type":"element","tag":"a","props":{"href":"https://docs.rs/anyhow/latest/anyhow/macro.bail.html","rel":["nofollow"]},"children":[{"type":"text","value":"anyhow"}]},{"type":"text","value":" 用于方便地提前返回错误。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以看一下 "},{"type":"element","tag":"a","props":{"href":"https://github.com/rust-lang/cargo/commit/9835622853f08be9a4b58ebe29dcec8f43b64b33#diff-99a8f4b284589e7db1aec698aa8f9ef9390f3ee3ecddc399dd6be1aa9ee00388L440-L446","rel":["nofollow"]},"children":[{"type":"text","value":"fix pr"}]},{"type":"text","value":"，非常有意思，比如 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"validate_feature_name"}]},{"type":"text","value":" 函数。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"原来：遇到非法 feature name，只输出 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"warning"}]},{"type":"text","value":"，流程继续。"},{"type":"element","tag":"br","props":{},"children":[]}]},{"type":"element","tag":"pre","props":{"code":"if let Some(ch) = chars.next() {Add commentMore actions\n        if !(unicode_xid::UnicodeXID::is_xid_start(ch) || ch == '_' || ch.is_digit(10)) {\n            config.shell().warn(&format!(\n                \"invalid character `{}` in feature `{}` in package {}, \\\n                the first character must be a Unicode XID start character or digit \\\n                (most letters or `_` or `0` to `9`)\\n\\\n                {}\",\n                ch, name, pkg_id, FUTURE\n            ))?;\n\n        }\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"if let Some(ch) = chars.next() {Add commentMore actions\n        if !(unicode_xid::UnicodeXID::is_xid_start(ch) || ch == '_' || ch.is_digit(10)) {\n            config.shell().warn(&format!(\n                \"invalid character `{}` in feature `{}` in package {}, \\\n                the first character must be a Unicode XID start character or digit \\\n                (most letters or `_` or `0` to `9`)\\n\\\n                {}\",\n                ch, name, pkg_id, FUTURE\n            ))?;\n\n        }\n    }\n"}]}]},{"type":"element","tag":"text-space","props":{"type":"tip"},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我本来想看看 2025-6-27 的 src/cargo/core/summary.rs 这个 fix pr 的区别。但我发现了一个流量密码，那就是 Rc → Arc, 问就是 Thread Safety！"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在：遇到非法 feature name，直接 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"bail!"}]},{"type":"text","value":"，构建中止，用户必须修正。"}]},{"type":"element","tag":"pre","props":{"code":" if let Some(ch) = chars.next() {Add commentMore actions\n        if !(unicode_xid::UnicodeXID::is_xid_start(ch) || ch == '_' || ch.is_digit(10)) {\n            bail!(\n                \"invalid character `{}` in feature `{}` in package {}, \\\n                the first character must be a Unicode XID start character or digit \\\n                (most letters or `_` or `0` to `9`)\",\n                ch,\n                name,\n                pkg_id\n            );\n        }\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" if let Some(ch) = chars.next() {Add commentMore actions\n        if !(unicode_xid::UnicodeXID::is_xid_start(ch) || ch == '_' || ch.is_digit(10)) {\n            bail!(\n                \"invalid character `{}` in feature `{}` in package {}, \\\n                the first character must be a Unicode XID start character or digit \\\n                (most letters or `_` or `0` to `9`)\",\n                ch,\n                name,\n                pkg_id\n            );\n        }\n    }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在单元测试中，来验证 feature name 是否合法，例如只有 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"is_ok()"}]},{"type":"text","value":" 是合法的，而 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"is_err()"}]},{"type":"text","value":" 是不合法的："}]},{"type":"element","tag":"pre","props":{"code":" #[test]Add commentMore actions\n    fn valid_feature_names() {\n        let loc = CRATES_IO_INDEX.into_url().unwrap();\n        let source_id = SourceId::for_registry(&loc).unwrap();\n        let pkg_id = PackageId::new(\"foo\", \"1.0.0\", source_id).unwrap();\n\n        assert!(validate_feature_name(pkg_id, \"c++17\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"128bit\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"_foo\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"feat-name\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"feat_name\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"foo.bar\").is_ok());\n\n        assert!(validate_feature_name(pkg_id, \"+foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"-foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \".foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"foo:bar\").is_err());\n        assert!(validate_feature_name(pkg_id, \"foo?\").is_err());\n        assert!(validate_feature_name(pkg_id, \"?foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"ⒶⒷⒸ\").is_err());\n        assert!(validate_feature_name(pkg_id, \"a¼\").is_err());\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" #[test]Add commentMore actions\n    fn valid_feature_names() {\n        let loc = CRATES_IO_INDEX.into_url().unwrap();\n        let source_id = SourceId::for_registry(&loc).unwrap();\n        let pkg_id = PackageId::new(\"foo\", \"1.0.0\", source_id).unwrap();\n\n        assert!(validate_feature_name(pkg_id, \"c++17\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"128bit\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"_foo\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"feat-name\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"feat_name\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"foo.bar\").is_ok());\n\n        assert!(validate_feature_name(pkg_id, \"+foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"-foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \".foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"foo:bar\").is_err());\n        assert!(validate_feature_name(pkg_id, \"foo?\").is_err());\n        assert!(validate_feature_name(pkg_id, \"?foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"ⒶⒷⒸ\").is_err());\n        assert!(validate_feature_name(pkg_id, \"a¼\").is_err());\n    }\n"}]}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h1","props":{"id":"cve-2023-41051-1"},"children":[{"type":"text","value":"CVE-2023-41051 1"}]},{"type":"element","tag":"cve-info","props":{":cwe":"125",":type":"1","cve":"CVE-2023-51051","to":"https://nvd.nist.gov/vuln/detail/cve-2023-41051"},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"越界访问（out-of-bounds）: 访问了本不属于该内存区域的数据。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/rust-vmm/vm-memory","rel":["nofollow"]},"children":[{"type":"text","value":"vm-memory"}]},{"type":"text","value":" 的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"VolatileMemory"}]},{"type":"text","value":" 实现未对边界进行严格校验，导致有可能读取到非法的内存区域："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"VolatileMemory::get_slice"}]},{"type":"text","value":": 返回一段“易失性切片”（VolatileSlice），用于后续的底层操作"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"VolatileMemory::read/write"}]},{"type":"text","value":": 直接从这块内存读/写数据，保证每次都实际发生内存访问"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"VolatileMemory trait 就是定义了一套访问“虚拟机物理内存”或“特殊硬件内存区域”的低层接口，保证每次读写都真实发生，且不被编译器优化。它让不同的底层实现都能用统一的 trait 操作。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但问题来了，这个通告并不涉及 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"read/write"}]},{"type":"text","value":"，更多的是 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"get_slice"}]},{"type":"text","value":" 方法，例如："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"get_atomic_ref"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"aligned_as_ref"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"aligned_as_mut"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"get_ref"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"get_array_ref"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上述方法有个共同点，都是利用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ref"}]},{"type":"text","value":" 类方法引起的。它们都尝试返回指向底层内存的 Rust 类型引用（如 &T、"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"&[T]"}]},{"type":"text","value":" 等），而不是直接读写原始字节数据。它们的实现通常会调用 get_slice，假设返回的内存区域长度足够大。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果自定义实现的 get_slice 返回的切片长度不足，就会导致这些 ref 方法产生越界引用，造成内存安全风险。例如："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"这些方法假设 get_slice 返回的 VolatileSlice 长度是你要求的大小（比如 T 是 u32，就要 4 字节）。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果自定义实现的 get_slice 返回的 VolatileSlice 比你要求的短（比如只返回了2字节）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"这些方法还是会照常把这块内存强转成 &T，这时你访问 &T 时就可能会读到超出实际内存范围以外的内容"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"仔细欣赏 "},{"type":"element","tag":"a","props":{"href":"https://github.com/rust-vmm/vm-memory/commit/aff1dd4a5259f7deba56692840f7a2d9ca34c9c8#diff-0870facad91de878abbdf4dc43212b8de558021cf0971f62148c2cab381bd150R109-R275","rel":["nofollow"]},"children":[{"type":"text","value":"fix pr"}]},{"type":"text","value":" 你会发现："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这些方法内部，都会调用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"get_slice(offset, count)"}]},{"type":"text","value":" 拿到一块内存切片，然后把它 reinterpret_cast 成你要的类型引用。因此给 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"get_slice"}]},{"type":"text","value":" 加上 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"assert_eq!"}]},{"type":"text","value":" 就意味着："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"“如果你要 8 字节引用，必须实际拿到 8 字节的内存切片，否则直接 panic，不做 unsafe 操作！”"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:book:cve-learn.md","_source":"content","_file":"book/cve-learn.md","_extension":"md"}