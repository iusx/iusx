{"_path":"/plan/security/cve-learn","_dir":"security","_draft":false,"_partial":false,"_locale":"","title":"CVE learn","description":"","director":"My","time":"2025","img":"14/1.png","plan":"100,100","target":100,"current":1,"displayType":"percent","body":{"type":"root","children":[{"type":"element","tag":"book-content","props":{":by":"director",":img":"img",":plan":"plan",":title":"title"},"children":[{"type":"element","tag":"text-title","props":{":t":"CVE is my dream."},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"早在我上小学时，就觉得 CVE 很帅。步入初中时，在初三那年我拿到了广东电信 IPTV 的通用漏洞。步入社会时，我拿到了 Github 的 Bug bounty。但我始终没有去拿一个 CVE 的编号。因为水是可以水的，但我已经水了 CNVD 和 Hackerone，我希望我的第一个 CVE 编号可以是不那么水的，有一点含金量的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"虽然我并不是 Security 行业或领域的从业人员，只是一个爱好者。但我一直觉得 Security 很帅。同样的，虽然我不是 Design 行业的从业人员，但我觉得可以让自己做出来的 project 会好看，有个性。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我并不是一个专精的人。很多时候我每项感兴趣的领域单拎出来都会被降维打击。虽然我单项领域无法媲美专业的从业者，但我感兴趣的领域都有点建树和作品。将 Security、Design、Animation、Computer 合在一起，与之能媲美的人可能会少那么一点。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而现在，我只有 Design 的代表作，而 Security、Animation、Computer 还没有一个能拿得出手的作品。因此我希望会在未来三年，尽可能的补全这些我感兴趣领域的代表作。可能因为 Work 比较闲的缘故，我的时间总会多那么一点来放到我感兴趣的领域上。即使达不到也没有关系，至少也是努力过了，无论如何三年后的自己总会比现在的自己稍微厉害那么一点点。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因此这个页面会记录一些我感兴趣的 CVE 和 CWE 的编号来让我学习，可能会获取到一些新的思路和对某个方面的理解。来帮助我实现这个目标，顺便看看冷门的 CWE 方向，毕竟 OWASP TOP 10 个人没有太大的兴趣。"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h1","props":{"id":"rust-3"},"children":[{"type":"text","value":"rust 3"}]},{"type":"element","tag":"h2","props":{"id":"cve-2022-36114-1"},"children":[{"type":"text","value":"CVE-2022-36114 1"}]},{"type":"element","tag":"cve-info","props":{":type":"2","cve":"CVE-2022-36114","to":"https://nvd.nist.gov/vuln/detail/CVE-2022-36114",":cwe":"400"},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不受控制的资源消耗"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"利用 Cargo 的 "},{"type":"element","tag":"a","props":{"href":"https://doc.rust-lang.org/cargo/reference/build-scripts.html","rel":["nofollow"]},"children":[{"type":"text","value":"build script"}]},{"type":"text","value":" 在构建阶段编译第三方的非 Rust code，同时结合 "},{"type":"element","tag":"a","props":{"href":"https://doc.rust-lang.org/book/ch20-05-macros.html#how-to-write-a-custom-derive-macro","rel":["nofollow"]},"children":[{"type":"text","value":"procedural macros"}]},{"type":"text","value":"，在执行 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"cargo run"}]},{"type":"text","value":" 的过程中触发了一个 "},{"type":"element","tag":"a","props":{"href":"https://en.wikipedia.org/wiki/Zip_bomb","rel":["nofollow"]},"children":[{"type":"text","value":"Zip Bomb"}]},{"type":"text","value":" 行为。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对于这个问题的修复，rust-lang 已经给出了一个 "},{"type":"element","tag":"a","props":{"href":"https://github.com/rust-lang/wg-security-response/blob/4bbe734e6404ece6f4e85027564f8995d4ab70e0/patches/CVE-2022-36114/0001-CVE-2022-36114-limit-the-maximum-unpacked-size-of-a-.patch","rel":["nofollow"]},"children":[{"type":"text","value":"补丁修复"}]},{"type":"text","value":" Zip_bomb 的问题:"}]},{"type":"element","tag":"pre","props":{"code":"// 在解压 .crate 文件（tar.gz）时，限制最多只能解压出 512MB 的内容。\n+const MAX_UNPACK_SIZE: u64 = 512 * 1024 * 1024;\n","language":"c","meta":"","className":["language-c"]},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// 在解压 .crate 文件（tar.gz）时，限制最多只能解压出 512MB 的内容。\n+const MAX_UNPACK_SIZE: u64 = 512 * 1024 * 1024;\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"同时引入了 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"LimitErrorReader"}]},{"type":"text","value":": 超过就抛出错误，避免资源被耗尽（比如磁盘写爆）。除此之外并没有对 macros、build 加以限制，只是建议尽可能的用 "},{"type":"element","tag":"a","props":{"href":"https://crates.io/","rel":["nofollow"]},"children":[{"type":"text","value":"crates"}]},{"type":"text","value":" 上提交的 crate。"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h2","props":{"id":"cve-2023-40030-1"},"children":[{"type":"text","value":"CVE-2023-40030 1"}]},{"type":"element","tag":"cve-info","props":{":type":"1","cve":"CVE-2023-40030","to":"https://nvd.nist.gov/vuln/detail/cve-2023-40030",":cwe":"79"},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"{OWASP TOP TEN}: 不恰当的网页生成输入中和 XSS"},{"type":"element","tag":"br","props":{},"children":[]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"看到这篇通告的时候，我就回想起为什么我看 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"cargo build --timings"}]},{"type":"text","value":" 的时候肿么没想到会有 CWE-79。"},{"type":"element","tag":"a","props":{"href":"https://doc.rust-lang.org/cargo/reference/timings.html","rel":["nofollow"]},"children":[{"type":"text","value":"--timings"}]},{"type":"text","value":" 是一个生成 build 时间的 html 报告。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以通过在 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Cargo.toml"}]},{"type":"text","value":" 中加入 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"features = [\"<img src='' onerror=alert(0)\"]"}]},{"type":"text","value":" 来触发一个 CWE-79, 因此对这个问题的修复就是，将之前的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"Warning"}]},{"type":"text","value":", 换成了 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"bail!"}]},{"type":"text","value":" 机制。"}]},{"type":"element","tag":"text-space","props":{"type":"tip"},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"bail!"}]},{"type":"text","value":" 宏来自 "},{"type":"element","tag":"a","props":{"href":"https://docs.rs/anyhow/latest/anyhow/macro.bail.html","rel":["nofollow"]},"children":[{"type":"text","value":"anyhow"}]},{"type":"text","value":" 用于方便地提前返回错误。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"可以看一下 "},{"type":"element","tag":"a","props":{"href":"https://github.com/rust-lang/cargo/commit/9835622853f08be9a4b58ebe29dcec8f43b64b33#diff-99a8f4b284589e7db1aec698aa8f9ef9390f3ee3ecddc399dd6be1aa9ee00388L440-L446","rel":["nofollow"]},"children":[{"type":"text","value":"fix pr"}]},{"type":"text","value":"，非常有意思，比如 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"validate_feature_name"}]},{"type":"text","value":" 函数。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"原来：遇到非法 feature name，只输出 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"warning"}]},{"type":"text","value":"，流程继续。"},{"type":"element","tag":"br","props":{},"children":[]}]},{"type":"element","tag":"pre","props":{"code":"if let Some(ch) = chars.next() {Add commentMore actions\n        if !(unicode_xid::UnicodeXID::is_xid_start(ch) || ch == '_' || ch.is_digit(10)) {\n            config.shell().warn(&format!(\n                \"invalid character `{}` in feature `{}` in package {}, \\\n                the first character must be a Unicode XID start character or digit \\\n                (most letters or `_` or `0` to `9`)\\n\\\n                {}\",\n                ch, name, pkg_id, FUTURE\n            ))?;\n\n        }\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"if let Some(ch) = chars.next() {Add commentMore actions\n        if !(unicode_xid::UnicodeXID::is_xid_start(ch) || ch == '_' || ch.is_digit(10)) {\n            config.shell().warn(&format!(\n                \"invalid character `{}` in feature `{}` in package {}, \\\n                the first character must be a Unicode XID start character or digit \\\n                (most letters or `_` or `0` to `9`)\\n\\\n                {}\",\n                ch, name, pkg_id, FUTURE\n            ))?;\n\n        }\n    }\n"}]}]},{"type":"element","tag":"text-space","props":{"type":"tip"},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我本来想看看 2025-6-27 的 src/cargo/core/summary.rs 这个 fix pr 的区别。但我发现了一个流量密码，那就是 Rc → Arc, 问就是 Thread Safety！"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"现在：遇到非法 feature name，直接 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"bail!"}]},{"type":"text","value":"，构建中止，用户必须修正。"}]},{"type":"element","tag":"pre","props":{"code":" if let Some(ch) = chars.next() {Add commentMore actions\n        if !(unicode_xid::UnicodeXID::is_xid_start(ch) || ch == '_' || ch.is_digit(10)) {\n            bail!(\n                \"invalid character `{}` in feature `{}` in package {}, \\\n                the first character must be a Unicode XID start character or digit \\\n                (most letters or `_` or `0` to `9`)\",\n                ch,\n                name,\n                pkg_id\n            );\n        }\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" if let Some(ch) = chars.next() {Add commentMore actions\n        if !(unicode_xid::UnicodeXID::is_xid_start(ch) || ch == '_' || ch.is_digit(10)) {\n            bail!(\n                \"invalid character `{}` in feature `{}` in package {}, \\\n                the first character must be a Unicode XID start character or digit \\\n                (most letters or `_` or `0` to `9`)\",\n                ch,\n                name,\n                pkg_id\n            );\n        }\n    }\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在单元测试中，来验证 feature name 是否合法，例如只有 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"is_ok()"}]},{"type":"text","value":" 是合法的，而 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"is_err()"}]},{"type":"text","value":" 是不合法的："}]},{"type":"element","tag":"pre","props":{"code":" #[test]Add commentMore actions\n    fn valid_feature_names() {\n        let loc = CRATES_IO_INDEX.into_url().unwrap();\n        let source_id = SourceId::for_registry(&loc).unwrap();\n        let pkg_id = PackageId::new(\"foo\", \"1.0.0\", source_id).unwrap();\n\n        assert!(validate_feature_name(pkg_id, \"c++17\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"128bit\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"_foo\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"feat-name\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"feat_name\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"foo.bar\").is_ok());\n\n        assert!(validate_feature_name(pkg_id, \"+foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"-foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \".foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"foo:bar\").is_err());\n        assert!(validate_feature_name(pkg_id, \"foo?\").is_err());\n        assert!(validate_feature_name(pkg_id, \"?foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"ⒶⒷⒸ\").is_err());\n        assert!(validate_feature_name(pkg_id, \"a¼\").is_err());\n    }\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":" #[test]Add commentMore actions\n    fn valid_feature_names() {\n        let loc = CRATES_IO_INDEX.into_url().unwrap();\n        let source_id = SourceId::for_registry(&loc).unwrap();\n        let pkg_id = PackageId::new(\"foo\", \"1.0.0\", source_id).unwrap();\n\n        assert!(validate_feature_name(pkg_id, \"c++17\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"128bit\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"_foo\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"feat-name\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"feat_name\").is_ok());\n        assert!(validate_feature_name(pkg_id, \"foo.bar\").is_ok());\n\n        assert!(validate_feature_name(pkg_id, \"+foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"-foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \".foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"foo:bar\").is_err());\n        assert!(validate_feature_name(pkg_id, \"foo?\").is_err());\n        assert!(validate_feature_name(pkg_id, \"?foo\").is_err());\n        assert!(validate_feature_name(pkg_id, \"ⒶⒷⒸ\").is_err());\n        assert!(validate_feature_name(pkg_id, \"a¼\").is_err());\n    }\n"}]}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h2","props":{"id":"cve-2023-41051-1"},"children":[{"type":"text","value":"CVE-2023-41051 1"}]},{"type":"element","tag":"cve-info","props":{":type":"1","cve":"CVE-2023-51051","to":"https://nvd.nist.gov/vuln/detail/cve-2023-41051",":cwe":"125"},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"越界访问（out-of-bounds）: 访问了本不属于该内存区域的数据。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/rust-vmm/vm-memory","rel":["nofollow"]},"children":[{"type":"text","value":"vm-memory"}]},{"type":"text","value":" 的 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"VolatileMemory"}]},{"type":"text","value":" 实现未对边界进行严格校验，导致有可能读取到非法的内存区域："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"VolatileMemory::get_slice"}]},{"type":"text","value":": 返回一段“易失性切片”（VolatileSlice），用于后续的底层操作"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"VolatileMemory::read/write"}]},{"type":"text","value":": 直接从这块内存读/写数据，保证每次都实际发生内存访问"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"VolatileMemory trait 就是定义了一套访问“虚拟机物理内存”或“特殊硬件内存区域”的低层接口，保证每次读写都真实发生，且不被编译器优化。它让不同的底层实现都能用统一的 trait 操作。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但问题来了，这个通告并不涉及 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"read/write"}]},{"type":"text","value":"，更多的是 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"get_slice"}]},{"type":"text","value":" 方法，例如："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"get_atomic_ref"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"aligned_as_ref"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"aligned_as_mut"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"get_ref"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"get_array_ref"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上述方法有个共同点，都是利用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ref"}]},{"type":"text","value":" 类方法引起的。它们都尝试返回指向底层内存的 Rust 类型引用（如 &T、"},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"&[T]"}]},{"type":"text","value":" 等），而不是直接读写原始字节数据。它们的实现通常会调用 get_slice，假设返回的内存区域长度足够大。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果自定义实现的 get_slice 返回的切片长度不足，就会导致这些 ref 方法产生越界引用，造成内存安全风险。例如："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"这些方法假设 get_slice 返回的 VolatileSlice 长度是你要求的大小（比如 T 是 u32，就要 4 字节）。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果自定义实现的 get_slice 返回的 VolatileSlice 比你要求的短（比如只返回了2字节）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"这些方法还是会照常把这块内存强转成 &T，这时你访问 &T 时就可能会读到超出实际内存范围以外的内容"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"仔细欣赏 "},{"type":"element","tag":"a","props":{"href":"https://github.com/rust-vmm/vm-memory/commit/aff1dd4a5259f7deba56692840f7a2d9ca34c9c8#diff-0870facad91de878abbdf4dc43212b8de558021cf0971f62148c2cab381bd150R109-R275","rel":["nofollow"]},"children":[{"type":"text","value":"fix pr"}]},{"type":"text","value":" 你会发现："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这些方法内部，都会调用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"get_slice(offset, count)"}]},{"type":"text","value":" 拿到一块内存切片，然后把它 reinterpret_cast 成你要的类型引用。因此给 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"get_slice"}]},{"type":"text","value":" 加上 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"assert_eq!"}]},{"type":"text","value":" 就意味着："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"“如果你要 8 字节引用，必须实际拿到 8 字节的内存切片，否则直接 panic，不做 unsafe 操作！”"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h2","props":{"id":"cve-2023-38497-1"},"children":[{"type":"text","value":"CVE-2023-38497 1"}]},{"type":"element","tag":"cve-info","props":{":type":"3","cve":"CVE-2023-38497","to":"https://nvd.nist.gov/vuln/detail/cve-2023-38497","cwe":"278,732"},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"278: 不安全的保留继承权限"},{"type":"element","tag":"br","props":{},"children":[]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"732: 关键资源的权限分配错误"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"CWE-278 还是较为冷门的，毕竟只有一个参考，既 "},{"type":"element","tag":"a","props":{"href":"https://www.cve.org/CVERecord?id=CVE-2005-1724","rel":["nofollow"]},"children":[{"type":"text","value":"CVE-2005-1724"}]},{"type":"text","value":"。CWE-278 这个类的漏洞常见表现之一就是 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"权限限制”"}]},{"type":"text","value":"。总的来说 umask 是 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"限制新建文件或目录默认权限的一个机制。"}]},{"type":"text","value":"，可以看看 "},{"type":"element","tag":"sup","props":{},"children":[{"type":"text","value":"1"}]},{"type":"text","value":"，我清晰记得有时候需要执行什么 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"bash"}]},{"type":"text","value":" 脚本的时候，会使用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"chmod 777"}]},{"type":"text","value":", 要不然运行不了。"}]},{"type":"element","tag":"text-space","props":{"type":"tip"},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"CVE-2005-1724 是一个典型的“配置安全限制无效”型漏洞，使得 NFS 导出的目录被所有人都能访问，造成权限绕过和潜在的数据泄露/篡改风险。其归类于 CWE-278 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"属于权限/访问控制失效问题。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"而 CWE-732 又是 CWE-278 的子类，因此会有两个 CWE 的分配。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"比如 CVE-2005-1724 在正常情况下，在导出（export）NFS 文件系统时，通常会用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"-network"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"-mask"}]},{"type":"text","value":"："}]},{"type":"element","tag":"pre","props":{"code":"/some/dir -network 192.168.1.0 -mask 255.255.255.0\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"/some/dir -network 192.168.1.0 -mask 255.255.255.0\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这样本应只有 192.168.1.0/24 网络内的主机可以访问该目录。但在 Mac OS X 10.4.x 的 NFS 服务实现没有正确处理/生效这些参数。因此构成了 CWE-278"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"要想理解本次的 CVE，我们首先需要理解标题 "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Cargo 在解压 crate 包时未按照 umask 限制文件权限"}]},{"type":"text","value":"。而 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"umask"}]},{"type":"text","value":" 是默认权限，翻译成人话就是："}]},{"type":"element","tag":"text-tip","props":{"type":"big"},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Cargo 在解压 crate 包时，没有按照 umask 分个默认的权限。攻击者可以利用这一点也就是 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"777"}]},{"type":"text","value":" 权限构建攻击脚本。"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n↑ 可能不是很严谨"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"过去 Cargo 解压 .crate 包时，直接采用了压缩包内的文件权限（比如 777/666），"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"没有结合操作系统的 umask，导致解压后的文件权限过宽，其他本地用户可能能写入、篡改这些源码文件。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"src/cargo/util/mod.rs"}]},{"type":"text","value":" 中新增了 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"get_umask()"}]},{"type":"text","value":" 函数。以在解压文件时，强制用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"umask"}]},{"type":"text","value":" 限制新文件的权限。："}]},{"type":"element","tag":"pre","props":{"code":"#[cfg(unix)]\npub fn get_umask() -> u32 {\n    use std::sync::OnceLock;\n    static UMASK: OnceLock<libc::mode_t> = OnceLock::new();\n    // SAFETY: Syscalls are unsafe. Calling `umask` twice is even unsafer for\n    // multithreading program, since it doesn't provide a way to retrive the\n    // value without modifications. We use a static `OnceLock` here to ensure\n    // it only gets call once during the entire program lifetime.\n    *UMASK.get_or_init(|| unsafe {\n        let umask = libc::umask(0o022);\n        libc::umask(umask);\n        umask\n    }) as u32 // it is u16 on macos\n}\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"#[cfg(unix)]\npub fn get_umask() -> u32 {\n    use std::sync::OnceLock;\n    static UMASK: OnceLock<libc::mode_t> = OnceLock::new();\n    // SAFETY: Syscalls are unsafe. Calling `umask` twice is even unsafer for\n    // multithreading program, since it doesn't provide a way to retrive the\n    // value without modifications. We use a static `OnceLock` here to ensure\n    // it only gets call once during the entire program lifetime.\n    *UMASK.get_or_init(|| unsafe {\n        let umask = libc::umask(0o022);\n        libc::umask(umask);\n        umask\n    }) as u32 // it is u16 on macos\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以及很有艺术性的一行 code:"}]},{"type":"element","tag":"pre","props":{"code":"fs::set_permissions(path, Permissions::from_mode(final_mode)).unwrap();\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"fs::set_permissions(path, Permissions::from_mode(final_mode)).unwrap();\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"解压 crate 时，读取每个文件的原始权限（如 0o777），实际写入磁盘时，会用 原始权限 & "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"!umask"}]},{"type":"text","value":" 得到最终权限，再 chmod 到文件上:"}]},{"type":"element","tag":"pre","props":{"code":"assert_eq!(metadata.mode() & 0o777, 0o644 & !umask);\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"assert_eq!(metadata.mode() & 0o777, 0o644 & !umask);\n"}]}]},{"type":"element","tag":"div","props":{"id":"refer-anchor-1","className":["ref"]},"children":[{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"1"}]},{"type":"text","value":" "},{"type":"element","tag":"a","props":{"href":"https://langzi989.github.io/2017/09/13/Linux%E4%B8%ADumash%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/","rel":["nofollow"]},"children":[{"type":"text","value":"https://langzi989.github.io/2017/09/13/Linux%E4%B8%ADumash%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"}]}]}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"cve-2022-36114-1","depth":2,"text":"CVE-2022-36114 1"},{"id":"cve-2023-40030-1","depth":2,"text":"CVE-2023-40030 1"},{"id":"cve-2023-41051-1","depth":2,"text":"CVE-2023-41051 1"},{"id":"cve-2023-38497-1","depth":2,"text":"CVE-2023-38497 1"}]}},"_type":"markdown","_id":"content:plan:security:cve-learn.md","_source":"content","_file":"plan/security/cve-learn.md","_extension":"md"}